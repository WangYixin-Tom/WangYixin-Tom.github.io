<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="python必知必会, python rabbitmq redis flask kafka">
    <meta name="baidu-site-verification" content="code-KoKq36g1n2">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="语言特性解释型语言。Python不需要在运行之前进行编译。
动态语言，不需要声明变量的类型，动态增加类方法。
适合面向对象的编程，允许类的定义和继承。
python2和python3区别
Python2 的默认编码是 ascii，Pytho">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>python必知必会 | 好好学习</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">好好学习</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">好好学习</div>
        <div class="logo-desc">
            
            业精于勤荒于嬉，行成于思毁于随
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/20.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        python必知必会
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/interview/" target="_blank">
                            <span class="chip bg-color">interview</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/interview/" class="post-category" target="_blank">
                            interview
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-04-13
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    wangyixin-tom
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    65 分
                </div>
                
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>解释型语言。Python不需要在运行之前进行编译。</p>
<p>动态语言，不需要声明变量的类型，动态增加类方法。</p>
<p>适合面向对象的编程，允许类的定义和继承。</p>
<h2 id="python2和python3区别"><a href="#python2和python3区别" class="headerlink" title="python2和python3区别"></a>python2和python3区别</h2><ul>
<li>Python2 的默认编码是 ascii，Python 3 默认编码 UTF-8，不需要在文件顶部写 <code># coding=utf-8</code>。</li>
<li>python2默认是按照相对路径导入模块和包，python3默认则是按照绝对路径导入</li>
<li>Python3里只有新式类；Python2里面继承object的是新式类，没有写父类的是经典类，多重继承的属性搜索顺序不一样，新式类是采用广度优先搜索，旧式类采用深度优先搜索。</li>
</ul>
<ul>
<li>Python3，新增了关键字 nonlcoal，支持嵌套函数中，变量声明为非局部变量。</li>
<li>python3提供注解，但是解释器<strong>并不会</strong>因为这些注解而提供额外的校验，没有任何的类型检查工作。也就是说，这些类型注解加不加，对你的代码来说<strong>没有任何影响</strong>，好处是易懂。</li>
</ul>
<ul>
<li>在Python2 中，字符串有两个类型， unicode和 str，前者表示文本字符串，后者表示字节序列，python2 会自动将字符串转换为合适编码的字节字符串（utf-8/gbk…），<code>decode(&#39;utf-8&#39;)</code>之后转换为unicode，可以显示指定字符串类型为unicode类型；Python3  str 表示字符串，byte 表示字节序列，字符串默认是Unicode，不能显示指定u”xx”，转换字节序列需要<code>encode(&#39;utf-8&#39;)</code>。</li>
<li>True 和 False 在 Python2 中是全局变量，分别对应 1 和 0，可以指向其它对象。 Python3  True 和 False 变为关键字，不允许再被重新赋值。</li>
<li>在Python2中，3/2是整数，在Python 3中浮点数，如果相除还想得到整数，就需要改成//相除。</li>
<li>原来在py2里，4字节以内的整数类型为int，超过就是long，而py3里没有long类型，只有int，而带来的问题是，大量整数计算时，py3要比py2占用更多内存，计算也明显更慢。</li>
<li>py3里dict没有<code>has_key()</code>方法，统一使用in表达式</li>
</ul>
<ul>
<li>Python 2中print/exec是特殊语句，Python 3中print/exec是函数，需要加上括号。</li>
<li>python2 range返回列表，python3 range中返回可迭代对象，节约内存。</li>
<li>Python 2 map、zip、filter函数返回list，Python3返回迭代器。</li>
<li>python2中的raw_input/input函数，python3中改名为input函数，危险的input被删掉了</li>
</ul>
<h2 id="python2和3代码如何兼容"><a href="#python2和3代码如何兼容" class="headerlink" title="python2和3代码如何兼容"></a>python2和3代码如何兼容</h2><ul>
<li><p>使用 2to3 工具（python自带的转换工具）对代码检查</p>
<p>查看输出信息，并修正相关问题。</p>
</li>
<li><p>使用python -3执行python程序</p>
<p>程序在运行时会在控制台上将python2和python3不一致，同时2to3无法处理的问题提示出来</p>
</li>
<li><p><code>from __future__ import</code>在python2使用python的未来特性了</p>
</li>
<li><p>import问题</p>
<p>python3中“少”了很多python2的包，在大多情况下这些包之是改了个名字而已。我们可以在import的时候捕获ImportError，重新import。</p>
</li>
<li><p>使用python3的方式写程序</p>
<p>python2中print是关键字，到了python3中print变成了函数。</p>
</li>
<li><p>检查当前运行的python版本</p>
<p>有时候你或许必须为python2和python3写不同的代码，可以先获取版本。</p>
</li>
<li><p>使用six</p>
<p>six 提供了一些简单的工具用来封装 Python 2 和 Python 3 之间的差异性。支持3向2的兼容。</p>
</li>
</ul>
<h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><h3 id="import机制"><a href="#import机制" class="headerlink" title="import机制"></a>import机制</h3><ul>
<li>当 import 一个模块时首先会在sys.modules列表中查找是否已经加载了此模块，如果加载了则只是将模块的名字加入到正在调用 import 的模块的 Local 名字空间中。如果没有加载则从 sys.path 目录中按照模块名称查找模块文件，模块可以是py、pyc、pyd，找到后将模块载入内存，并加到 sys.modules 中，并将名称导入到当前的 Local 名字空间。</li>
<li>包导入的过程和模块的基本一致，只是导入包的时候会执行此包目录下的<code>__init__.py</code> 而不是模块里面的语句了。另外，如果只是单纯的导入包，而包的<code>__init__.py</code>中又没有明确的其他初始化操作，那么此包下面的模块是不会自动导入的。</li>
</ul>
<blockquote>
<p>搜索路径查找模块：</p>
<ol>
<li>py 所在文件的目录</li>
<li>PYTHONPATH 中的目录</li>
<li>python安装目录，UNIX下，默认路径一般为/usr/local/lib/python/</li>
<li>3.x 中.pth 文件内容</li>
</ol>
</blockquote>
<h3 id="可变数据类型和不可变数据类型"><a href="#可变数据类型和不可变数据类型" class="headerlink" title="可变数据类型和不可变数据类型"></a>可变数据类型和不可变数据类型</h3><p>可变数据类型（引用类型）：当该数据类型对应的变量值发生了变化时，对应的内存地址不发生改变。</p>
<p>不可变数据类型（值类型）：当该数据类型对应的变量值发生了变化时，对应的内存地址发生了改变。</p>
<p>可变数据类型：list和dict；</p>
<p>不可变数据类型：int、float、string和tuple、bytes。</p>
<h3 id="array-与内置list-有什么区别"><a href="#array-与内置list-有什么区别" class="headerlink" title="array 与内置list 有什么区别"></a>array 与内置list 有什么区别</h3><p>array 是数组, 数组是只能够保存一种类型, 初始化的时候就决定了数据类型.</p>
<p>而list 里面 几乎可以放任意类型</p>
<h3 id="扁平序列"><a href="#扁平序列" class="headerlink" title="扁平序列"></a>扁平序列</h3><p>存放的都是原子级元素，此时存放的是值而不会是引用。</p>
<p>常见的扁平序列包括：str，bytes，bytearray, memoryview, array.array等。</p>
<h3 id="python2中xrange和range的区别"><a href="#python2中xrange和range的区别" class="headerlink" title="python2中xrange和range的区别"></a>python2中xrange和range的区别</h3><p><code>range()</code>返回的是一个list对象，而xrange返回的是一个可迭代对象。</p>
<p><code>xrange()</code>则不会直接生成一个list，而是每次调用返回其中的一个值，内存空间使用极少。因而性能非常好。</p>
<h3 id="变量的作用域-查找顺序"><a href="#变量的作用域-查找顺序" class="headerlink" title="变量的作用域/查找顺序"></a>变量的作用域/查找顺序</h3><p>函数作用域的LEGB顺序</p>
<p>L：local ，局部作用域；</p>
<p>E：enclosing，嵌套的父级函数的局部作用域；</p>
<p>G：global ，全局变量；</p>
<p>B：build-in， 系统固定模块里面的变量。</p>
<p>Python除了def/class/lambda 外，其他如: if/elif/else/ try/except for/while并不能改变其作用域。</p>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p><code>reduce()</code> 函数会对参数序列中元素进行累积。</p>
<p>先对数据集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据做函数运算。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 两数相加</span>
   <span class="token keyword">return</span> x <span class="token operator">+</span> y
reduce<span class="token punctuation">(</span>add<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 计算列表和：1+2+3+4+5</span>
reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x<span class="token operator">+</span>y<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 使用 lambda 匿名函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>filter()</code> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p>
<p>序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">is_odd</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">return</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span>

newlist <span class="token operator">=</span> filter<span class="token punctuation">(</span>is_odd<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>newlist<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>map()</code> 会根据提供的函数对指定序列做映射。</p>
<p>序列中的每一个元素调用 函数，返回包含每次函数返回值的新列表（python2），python3是会返回可迭代对象的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 计算平方数</span>
   <span class="token keyword">return</span> x <span class="token operator">**</span> <span class="token number">2</span>
map<span class="token punctuation">(</span>square<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 计算列表各个元素的平方</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>repr()</code>函数将对象转化为供解释器读取的形式</p>
<pre class="line-numbers language-python"><code class="language-python">dict1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'runoob'</span><span class="token punctuation">:</span> <span class="token string">'runoob.com'</span><span class="token punctuation">,</span> <span class="token string">'google'</span><span class="token punctuation">:</span> <span class="token string">'google.com'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
repr<span class="token punctuation">(</span>dict1<span class="token punctuation">)</span>
str<span class="token punctuation">(</span>dict1<span class="token punctuation">)</span>

<span class="token string">"{'google': 'google.com', 'runoob': 'runoob.com'}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>vars()</code>函数返回对象object的属性和属性值的字典对象。</p>
<pre><code>class Runoob:
   a = 1
print(vars(Runoob))
{&#39;a&#39;: 1, &#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None}</code></pre><p><strong>ord</strong></p>
<p>一个长度为1的字符串作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。</p>
<h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>不带参数时，返回当前范围内的变量、方法和定义的类型列表；</p>
<p>带参数时，返回参数的属性、方法列表。</p>
<p>如果参数包含方法<code>__dir__()</code>，该方法将被调用。</p>
<h4 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a><strong>isinstance</strong></h4><p><code>isinstance()</code>判断一个对象是否是一个已知的类型，<code>type()</code>查看一个类型或变量的类型。</p>
<p><code>type()</code>不会认为子类是一种父类类型。<code>isinstance()</code>会认为子类是一种父类类型。</p>
<h4 id="raw-input、input"><a href="#raw-input、input" class="headerlink" title="raw_input、input"></a>raw_input、input</h4><p>1、在 Python2.x 中<code>raw_input()</code>和<code>input()</code>，两个函数都存在，其中区别为:</p>
<ul>
<li><code>raw_input()</code>将所有输入作为字符串看待，返回字符串类型。</li>
<li><code>input()</code> 只能接收“数字”的输入，它返回所输入的数字的类型。</li>
</ul>
<p>2、在 Python3.x 中 仅保留了<code>input()</code> 函数，将所有输入作为字符串处理，并返回字符串类型。</p>
<h4 id="sort-sorted"><a href="#sort-sorted" class="headerlink" title="sort sorted"></a>sort sorted</h4><p><strong>区别</strong></p>
<p>对于一个无序的列表a，调用<code>a.sort()</code>，对a进行排序后返回None，<code>sort()</code>函数修改待排序的列表内容。</p>
<p>而对于同样一个无序的列表a，调用<code>sorted(a)</code>，对a进行排序后返回一个新的列表，而对a不产生影响。</p>
<h3 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h3><p>在特殊的情况下被Python所调用的方法。</p>
<p><code>__init__</code>构造器，当一个实例被创建的时候用于初始化的方法。</p>
<p><code>__new__</code>实例化对象调用的第一个方法，用来创造一个类的实例的，取下cls参数，把其他参数传给<code>__init__</code>.</p>
<p><code>__slot__</code>:让解释器在元组中存储实例属性，而不用字典，告诉解释器：“这个类中的所有实例属性都在这儿了！”</p>
<p><code>__call__</code>让一个类的实例像函数一样被调用</p>
<p><code>__getitem__</code>定义获取容器中指定元素的行为，相当于<code>self[key]</code></p>
<p><code>__getattr__</code>定义当用户试图访问一个不存在属性的时候的行为</p>
<p><code>__setattr__</code>定义当一个属性被设置的时候的行为</p>
<p><code>__getattribute___</code>定义当一个属性被访问的时候的行为</p>
<p><code>__del__</code>删除对象执行的方法</p>
<p><code>__str__</code>强调可读性，面向用户，在<code>print()</code>或者<code>str()</code>函数调用的时候才会被调用；</p>
<p><code>__repr__</code>强调标准性，面向开发者。</p>
<p>%s调用<code>__str__</code>方法，而%r调用<code>__repr__</code>方法</p>
<p><code>__repr__</code>在表示类时，是一级的，如果只定义它，那么<code>__str__</code> = <code>__repr__</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Callable</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">return</span> a <span class="token operator">+</span> b


func <span class="token operator">=</span> Callable<span class="token punctuation">(</span><span class="token punctuation">)</span> 
result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 像函数一样调用</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="读取obj-field时-发生了什么"><a href="#读取obj-field时-发生了什么" class="headerlink" title="读取obj.field时, 发生了什么?"></a>读取obj.field时, 发生了什么?</h3><ol>
<li>如果定义了<code>__getattribute__</code>，访问该方法获取属性值。逐级查找父类的<code>__getattribute__</code></li>
<li>对应描述符<code>__get__()</code>方法</li>
<li>如果obj 实例有这个属性, 返回. </li>
<li>非数据描述符<code>__get__()</code></li>
<li>如果obj 的class 有这个属性, 返回. 逐级查找父类的属性</li>
<li>执行<code>obj.__getattr__</code>方法.逐级查找父类的<code>__getattr__</code>方法</li>
</ol>
<h3 id="new-amp-init区别"><a href="#new-amp-init区别" class="headerlink" title="new &amp; init区别"></a>new &amp; init区别</h3><p>1、<code>__new__</code>有参数cls，代表当前类，从而产生一个实例；<code>__new__</code>必须要有返回值，返回实例化出来的实例，可以return父类（<code>super(当前类名, cls)</code>）<code>__new__</code>出来的实例，或object的<code>__new__</code>出来的实例</p>
<p>2、<code>__init__</code>有参数self，完成一些初始化的动作，<code>__init__</code>不需要返回值</p>
<p>3、如果<code>__new__</code>创建的是当前类的实例，会自动调用<code>__init__</code>（return语句里面调用的<code>__new__</code>函数的第一个参数是cls，保证是当前类实例）；如果<code>__new__</code>返回一个已经存在的实例，<code>__init__</code>不会被调用。</p>
<p>4、如果我们在<code>__new__</code>函数中不返回任何对象，则<code>__init__</code>函数也不会被调用。</p>
<blockquote>
<p>Python的旧类中实际上并没有<code>__new__</code>方法。因为旧类中的<code>__init__</code>实际上起构造器的作用</p>
</blockquote>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>避免转义，给字符串加r表示原始字符串。</p>
<h3 id="is-和-区别"><a href="#is-和-区别" class="headerlink" title="is 和 ==区别"></a>is 和 ==区别</h3><p>is：比较俩对象是否为同一个实例对象，是否指向同一个内存地址。</p>
<p>== ： 比较的两个对象的内容/值是否相等，默认会调用对象的<code>eq()</code>方法</p>
<h3 id="set去重"><a href="#set去重" class="headerlink" title="set去重"></a>set去重</h3><p>set的去重是通过两个函数<code>__hash__</code>和<code>__eq__</code>结合实现的。</p>
<p>1、当两个变量的哈希值不相同时，就认为这两个变量是不同的</p>
<p>2、当两个变量哈希值一样时，调用<code>__eq__</code>方法，当返回值为True时认为这两个变量是同一个。返回FALSE时，不去重。</p>
<h3 id="list切片"><a href="#list切片" class="headerlink" title="list切片"></a>list切片</h3><p>索引操作本身基于<code>__getitem__</code>和<code>__setitem__</code></p>
<p>python向<code>__getitem__</code>传入了一个<code>slice</code>的对象，这个类有start, stop, step三个属性，缺省值都是None。</p>
<pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
x <span class="token operator">=</span> a <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># x = a.__getitem__(slice( 1, 5, None))</span>
a <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># a.__setitem__(slice(1, 3, None), [ 10, 11, 12 ])</span>
<span class="token keyword">del</span> a <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># a.__delitem__(slice(1, 4, None))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="三元算子"><a href="#三元算子" class="headerlink" title="三元算子"></a>三元算子</h3><p><code>[on true] if [expression] else [on false]</code></p>
<h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>1、一般作为占位符或者创建占位程序，pass语句不会执行任何操作</p>
<p>2、保证格式、语义完整 </p>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>创建匿名函数的一个特殊语法，即用即仍，</p>
<p>1.一般用来给filter，map这样的函数式编程服务</p>
<p>2.作为回调函数</p>
<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><strong>迭代器协议</strong>： <code>__iter__()</code> 返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 并通过 <code>StopIteration</code> 异常，标识迭代的完成。</p>
<p><strong>迭代器对象</strong>：实现了迭代器协议的对象/被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器。</p>
<p><strong>例子</strong></p>
<p>Python的内置工具（如for循环，sum，min，max函数等）使用迭代器协议访问对象</p>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p><strong>使用了 yield 的函数被称为生成器</strong>。<strong>只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个生成器</strong></p>
<p>生成器是一种特殊的迭代器，生成器自动实现了“迭代器协议”。</p>
<p>好处：不用占用很多内存，只需要在用的时候计算元素的值就行了。</p>
<p>生成器在迭代的过程中可以改变当前迭代值，而修改普通迭代器的当前迭代值往往会发生异常，影响程序的执行。</p>
<p><strong>yield</strong></p>
<p>yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator。</p>
<p>它和普通函数不同，生成一个 generator 看起来像函数调用，<strong>但不会执行任何函数代码，直到对其调用</strong> <code>next()</code>（在 for 循环中会自动调用 <code>next()</code>）才开始执行。虽然执行流程仍按函数的流程执行，<strong>但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行</strong>。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。</p>
<p><strong>激活</strong></p>
<ul>
<li>除了 next，还可以使用 send 激活生成器，两者可以交替使用。</li>
<li>第一次当生成器处于 started 状态时，只能 send(None)，否则会报错</li>
</ul>
<h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h4><p>实现<code>__iter__</code>方法的对象。可迭代对象包含文件对象、序列（字符串、列表、元组、集合）、字典。</p>
<h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> Iterable<span class="token punctuation">,</span> Iterator
<span class="token keyword">from</span> inspect <span class="token keyword">import</span> isgenerator

isinstance<span class="token punctuation">(</span>a<span class="token punctuation">,</span> Iterable<span class="token punctuation">)</span>
isinstance<span class="token punctuation">(</span>a<span class="token punctuation">,</span> Iterator<span class="token punctuation">)</span>
isgenerator<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器本质上是一个<strong>Python函数或者类</strong>，让其他函数在不做任何代码变动，从而增加额外功能，装饰器的返回值也是一个函数对象。</p>
<p>场景：<strong>插入日志</strong>、性能测试、<strong>事务处理</strong>、缓存、<strong>权限校验、异常处理</strong>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> functools

<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span>

add  <span class="token operator">=</span> functools<span class="token punctuation">.</span>partial<span class="token punctuation">(</span>add<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># 输出：3</span>
add<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>经过partial包装之后，a参数的值被固定为了1，新的add对象（注意此处add已经是一个可调用对象）只需要接收一个参数即可。</p>
<p><strong>把原函数的部分参数固定了初始值，新的调用只需要传递其它参数。</strong></p>
<p><code>@functools.wraps(func)</code>底层逻辑，就是把wrapped函数的属性拷贝到wrapper函数中。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">outer</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
  @functools<span class="token punctuation">.</span>wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>
  <span class="token keyword">def</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"before..."</span><span class="token punctuation">)</span>
     func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"after..."</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> inner

@outer
<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">"""
  求和运算
  """</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>1、原函数为add。</p>
<p>2、@outer会去执行outer装饰器，传入add函数，返回一个inner函数。</p>
<p>3、执行outer函数时，加载inner函数，此时会直接执行<code>functools.wraps(func)</code>返回一个可调用对象，即partial对象。</p>
<p>4、此时inner的装饰器实际上是@partial，partial会被调用，传入inner函数，执行partial内部的update_wrapper函数，将func的相应属性拷贝给inner函数，最后返回inner函数。这一步并没有生成新的函数，仅仅是改变了inner函数的属性。</p>
<p>5、把add指向inner函数。</p>
<p>6、调用add实际调用的是inner函数，inner函数内部持有原add函数的引用即func。</p>
<p> <strong>总结</strong></p>
<p>1）functools.wraps 旨在消除装饰器对原函数造成的影响，即对原函数的相关属性进行拷贝。</p>
<p>2）wraps内部通过partial对象和update_wrapper函数实现。</p>
<p>3）partial是一个类，通过实现<code>__new__</code>，<strong>自定义实例化对象过程，使得对象内部保留原函数和固定参数</strong>，通过实现<code>__call__</code>，使得对象可以像函数一样被调用，再通过内部保留的原函数和固定参数以及传入的其它参数进行原函数调用。</p>
<h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a><strong>类装饰器</strong></h4><p>类装饰器具有<strong>灵活度大、高内聚、封装性</strong>等优点。</p>
<p>依靠<code>__call__</code>方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>
     self<span class="token punctuation">.</span>_func <span class="token operator">=</span> func

<span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'class decorator runing'</span><span class="token punctuation">)</span>
   self<span class="token punctuation">.</span>_func<span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'class decorator ending'</span><span class="token punctuation">)</span>

@Foo
<span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>

bar<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="动态属性property"><a href="#动态属性property" class="headerlink" title="动态属性property"></a>动态属性property</h3><p>让方法像属性一样使用.</p>
<p>大量的@property修饰的方法在同一个类，这是不符合设计原则的，代码的分离性和可读性大大降低。建议使用属性描述符。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>

  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
     self<span class="token punctuation">.</span>_x <span class="token operator">=</span> None

  @property
  <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token triple-quoted-string string">"""I'm the 'x' property."""</span>
     <span class="token keyword">return</span> self<span class="token punctuation">.</span>_x

  @x<span class="token punctuation">.</span>setter
  <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>value<span class="token punctuation">,</span>numbers<span class="token punctuation">.</span>Integral<span class="token punctuation">)</span><span class="token punctuation">:</span>
         self<span class="token punctuation">.</span>_x <span class="token operator">=</span> value

  @x<span class="token punctuation">.</span>deleter
  <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">del</span> self<span class="token punctuation">.</span>_x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用property装饰后，x不再是一个函数，而是property类的一个实例。所以第二个函数可以使用 x.setter 来装饰，本质是调用property.setter 来产生一个新的 property实例赋值给第二个x。</p>
<p>第一个 x和第二个 x 是两个不同 property实例。但他们都属于同一个描述符类（property），当赋值时，就会进入 <code>property.__set__</code>，取值时，就会进入 <code>property.__get__</code>。</p>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p><strong>位置参数：</strong>传参数时，按照顺序，依次传值。</p>
<p><strong>默认参数：</strong>参数提供默认值。默认参数一定要指向不变对象。</p>
<p><strong>可变参数：</strong>可变参数就是传入的参数个数是可变的。特征：*args</p>
<p><strong>关键字参数：</strong>允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。特征：**kw</p>
<p><strong>命名关键字参数：</strong>如果要限制关键字参数的名字，就可以用命名关键字参数。特征：命名关键字参数需要一个特殊分隔符<code>*</code>，而后面的参数被视为命名关键字参数。如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要特殊分隔符了</p>
<p>参数定义的<strong>顺序</strong>必须是：位置参数–&gt;默认参数–&gt;可变参数–&gt;命名关键字参数–&gt;关键字参数</p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>拉链函数， 将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表迭代器。</p>
<p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="and-和or"><a href="#and-和or" class="headerlink" title="and 和or"></a>and 和or</h3><p> 在不加括号时候, and优先级大于or </p>
<p>x or y：x为真是x, x为假是y </p>
<p>x and y ： x为真就是y, x为假就是x</p>
<pre class="line-numbers language-python"><code class="language-python">v <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">2</span> <span class="token operator">or</span> <span class="token number">3</span> <span class="token operator">and</span> <span class="token number">4</span> 
<span class="token keyword">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><strong>通过调用<code>iter()</code>方法执行（字符串，元组，字典，集合，文件）对象内部的<code>__iter__</code>方法，获取一个迭代器，然后使用迭代器协议去实现循环访问，</strong>当元素循环完时，会触发StopIteration异常，for循环会捕捉到这种异常，终止迭代</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素地址的拷贝。也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。</p>
<p>深拷贝：在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。（ 新瓶装新酒 ）。</p>
<p>1、复制不可变数据类型， copy /deepcopy，都指向原地址对象</p>
<p>2、复制的值是可变对象</p>
<p><strong>浅拷贝copy有两种情况：</strong></p>
<p>复制对象中包含的非可变数据类型：改变值，会开辟新的内存，有新的引用。原来值的改变并不会影响浅复制的值。</p>
<p>复制对象中包含的可变数据类型：改变原来的值，会影响浅复制的值。</p>
<p><strong>深拷贝deepcopy</strong></p>
<p>完全复制独立，包括内层列表和字典</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p><strong>值传递：</strong>实参把值传递给形参，形参的改变不影响实参值。</p>
<p><strong>引用传递（地址传递）：</strong>把实参地址传递形参，形参值的改变会影响实参的值。</p>
<ul>
<li>函数中修改字典某一个键值对是有效的</li>
<li>函数中交换两个字典并无法生效</li>
</ul>
<p>因此不是严格意义上的引用传递，而是<strong>基于引用地址的值传递</strong>，传递的是对象地址的拷贝。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>高阶函数</strong>：函数为入参，或者函数作为返回结果。</p>
<p><strong>闭包</strong>：在外函数中定义了内函数，内函数里使用了外函数的临时变量，并且外函数的返回值是内函数的引用。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">timer</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
     start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
     func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#此处拿到了被装饰的函数func</span>
     time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#模拟耗时操作</span>
     long <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start
      <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'共耗时{long}秒。'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> wrapper <span class="token comment" spellcheck="true">#返回内层函数的引用</span>

@timer
<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span>

add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#正常调用add</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>模块加载</strong></p>
<ul>
<li>遇到@，执行timer函数，传入add函数 </li>
<li>生成<code>timer.&lt;locals&gt;.wrapper</code>函数并命名为add，其实是覆盖了原同名函数 </li>
<li>调用<code>add(1, 2)</code></li>
<li>去执行<code>timer.&lt;locals&gt;.wrapper(1, 2)</code></li>
<li>wrapper内部持有原add函数引用<code>(func)</code>，调用<code>func(1, 2)</code></li>
<li>继续执行完wrapper函数</li>
</ul>
<p><strong>带参数的装饰器</strong></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">auth</span><span class="token punctuation">(</span>permission<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">_auth</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
       <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"验证权限[{permission}]..."</span><span class="token punctuation">)</span>
       func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
       <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"执行完毕..."</span><span class="token punctuation">)</span>
     <span class="token keyword">return</span> wrapper
  <span class="token keyword">return</span> _auth

@auth<span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">"""
  求和运算
  """</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>真正调用的是装饰后生成的新函数。</p>
<p>为了消除装饰器对原函数的影响，需要伪装成原函数，拥有原函数的属性。可以利用functools：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">auth</span><span class="token punctuation">(</span>permission<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">_auth</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
     @functools<span class="token punctuation">.</span>wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 注意此处</span>
     <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
       <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"验证权限[{permission}]..."</span><span class="token punctuation">)</span>
       func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
       <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"执行完毕..."</span><span class="token punctuation">)</span>
     <span class="token keyword">return</span> wrapper
  <span class="token keyword">return</span> _auth

@auth<span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">"""
  求和运算
  """</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="特殊例子"><a href="#特殊例子" class="headerlink" title="特殊例子"></a>特殊例子</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token keyword">lambda</span> x <span class="token punctuation">:</span> i<span class="token operator">*</span>x <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span>m<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">for</span> m <span class="token keyword">in</span> multi<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [9,9,9,9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>闭包的延迟绑定导致的，在<strong>闭包中的变量是在内部函数被调用的时候被查找的</strong>，最后函数被调用的时候，for循环已经完成， i 的值最后是3，因此每一个返回值的i都是3，所以最后的结果是[9,9,9,9]</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># [0, 3, 6, 9]</span>
<span class="token keyword">def</span> <span class="token function">multipliers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">yield</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> i <span class="token operator">*</span>x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h3><p>在一个类里，实现了<code>__enter__</code>和<code>__exit__</code>的方法，这个类的实例就是一个上下文管理器。</p>
<p><strong>基本使用语法</strong></p>
<pre class="line-numbers language-pyt"><code class="language-pyt">with EXPR as VAR:
    BLOCK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>为什么要使用上下文管理器？</strong></p>
<p>一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接；处理异常；</p>
<p><strong>使用contextlib</strong></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> contextlib

@contextlib<span class="token punctuation">.</span>contextmanager
<span class="token keyword">def</span> <span class="token function">open_func</span><span class="token punctuation">(</span>file_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># __enter__方法</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'open file:'</span><span class="token punctuation">,</span> file_name<span class="token punctuation">,</span> <span class="token string">'in __enter__'</span><span class="token punctuation">)</span>
    file_handler <span class="token operator">=</span> open<span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>

    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">yield</span> file_handler
    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> exc<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># deal with exception</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'the exception was thrown'</span><span class="token punctuation">)</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'close file:'</span><span class="token punctuation">,</span> file_name<span class="token punctuation">,</span> <span class="token string">'in __exit__'</span><span class="token punctuation">)</span>
        file_handler<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">return</span>

<span class="token keyword">with</span> open_func<span class="token punctuation">(</span><span class="token string">'/Users/MING/mytest.txt'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> file_in<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> file_in<span class="token punctuation">:</span>
        <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h3><h4 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h4><ul>
<li>ascii ：一个字节表示一个字符，最多只能表示 256 个符号，是针对英语字符与二进制位之间的关系的统一规定。</li>
<li>unicode：将世界上所有的符号都纳入其中，每一个符号都给予一个独一无二的编码，用于解决乱码问题。只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</li>
<li>utf-8：互联网上使用最广的一种 Unicode 的实现方式，完成了统一的编码方式。UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。一般来说，<strong>英文字符1个字节、 欧洲字符2个字节， 中文字符3个字节</strong><ul>
<li>对于单字节的符号，字节的第一位设为<code>0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</li>
<li>对于<code>n</code>字节的符号（<code>n &gt; 1</code>），第一个字节的前<code>n</code>位都设为<code>1</code>，第<code>n + 1</code>位设为<code>0</code>，后面字节的前两位一律设为<code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</li>
</ul>
</li>
<li>gbk：英文字符1个字节，中文字符两个字节</li>
</ul>
<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>
<p>python2 的默认编码方式为ASCII码，python3默认的文件编码是UTF-8</p>
<blockquote>
<p>Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p>
<p>如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法；</p>
<p>如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code></p>
<p><code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数</p>
<p>如果没有特殊业务要求，请牢记仅使用<code>UTF-8</code>编码</p>
</blockquote>
<h4 id="unicode、utf-8和utf-16的区别"><a href="#unicode、utf-8和utf-16的区别" class="headerlink" title="unicode、utf-8和utf-16的区别"></a>unicode、utf-8和utf-16的区别</h4><p>Unicode 是字符集，UTF-8 是编码规则</p>
<ul>
<li>字符集：为每一个字符分配一个唯一的 ID（学名为码位 / 码点 / Code Point）</li>
<li>编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）</li>
</ul>
<p>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码……</p>
<p>Unicode 字符集为每一个字符分配一个码位，例如「知」的码位是 30693，记作 U+77E5（30693 的十六进制为 0x77E5）。</p>
<p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个码位编码为 1 到 4 个字节。</p>
<p>utf-16是用两个字节来编码所有的字符。</p>
<h3 id="pickling和unpickling？"><a href="#pickling和unpickling？" class="headerlink" title="pickling和unpickling？"></a>pickling和unpickling？</h3><p>模块 pickle 实现了对一个 Python 对象结构的二进制序列化和反序列化。</p>
<p> “pickling” 是将 Python 对象及转化为一个字节流的过程</p>
<p>“unpickling” 将字节流转化回一个对象层次结构。</p>
<p>Pickle 协议和 JSON 间有着本质的<strong>不同</strong>：</p>
<ul>
<li>JSON 是一个文本序列化格式，而 pickle 是一个二进制序列化格式；</li>
<li>JSON 是我们可以直观阅读的，而 pickle 不是；</li>
<li>JSON在Python之外广泛使用，而pickle则是Python专用的；</li>
<li>JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型。</li>
</ul>
<h3 id="说一下namedtuple的用法和作用"><a href="#说一下namedtuple的用法和作用" class="headerlink" title="说一下namedtuple的用法和作用"></a>说一下<code>namedtuple</code>的用法和作用</h3><p>只有属性没有方法的类，用于组织数据，称为<strong>数据类</strong>。</p>
<p>在Python中可以用<code>namedtuple</code>（命名元组）来替代这种类。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple

Card <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Card'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'suite'</span><span class="token punctuation">,</span> <span class="token string">'face'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
card1 <span class="token operator">=</span> Card<span class="token punctuation">(</span><span class="token string">'红桃'</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span>
card2 <span class="token operator">=</span> Card<span class="token punctuation">(</span><span class="token string">'草花'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'{card1.suite}{card1.face}'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'{card2.suite}{card2.face}'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>命名元组与普通元组一样是不可变容器，</strong>一旦将数据存储在<code>namedtuple</code>的顶层属性中，数据就不能再修改了，</p>
<p>对象上的所有属性都遵循“一次写入，多次读取”的原则。</p>
<p>和普通元组不同的是，命名元组中的数据有访问名称，可以<strong>通过名称而不是索引来获取保存的数据</strong></p>
<p><strong>命名元组的本质就是一个类，所以它还可以作为父类创建子类。</strong></p>
<p>除此之外，命名元组内置了一系列的方法，例如，可以通过<code>_asdict</code>方法将命名元组处理成字典，也可以通过<code>_replace</code>方法创建命名元组对象的浅拷贝。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyCard</span><span class="token punctuation">(</span>Card<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        faces <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token string">'J'</span><span class="token punctuation">,</span> <span class="token string">'Q'</span><span class="token punctuation">,</span> <span class="token string">'K'</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span> f<span class="token string">'{self.suite}{faces[self.face]}'</span>


<span class="token keyword">print</span><span class="token punctuation">(</span>Card<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># &lt;class '__main__.Card'></span>
card3 <span class="token operator">=</span> MyCard<span class="token punctuation">(</span><span class="token string">'方块'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>card3<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 方块Q</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>dict<span class="token punctuation">(</span>card1<span class="token punctuation">.</span>_asdict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># {'suite': '红桃', 'face': 13}</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>card2<span class="token punctuation">.</span>_replace<span class="token punctuation">(</span>suite<span class="token operator">=</span><span class="token string">'方块'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Card(suite='方块', face=5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>继承：将多个类的共同属性和方法封装到一个父类下面，然后在用这些类来继承这个类的属性和方法</p>
<p>封装：将有共同的属性和方法封装到同一个类下面</p>
<p>多态：Python天生是支持多态的。指的是基类的同一个方法在不同的派生类中有着不同的功能</p>
<h3 id="新式类和经典类"><a href="#新式类和经典类" class="headerlink" title="新式类和经典类"></a>新式类和经典类</h3><p>Python3里只有新式类；Python2里面继承object的是新式类，没有写父类的是经典类</p>
<p><strong>区别</strong></p>
<ul>
<li>新式类 保持class与type的统一，对新式类的实例执行<code>a.__class__</code>与<code>type(a)</code>的结果是一致的</li>
<li>旧式类的<code>type(a)</code>返回instance。</li>
<li>多重继承的属性搜索顺序不一样，新式类是采用广度优先搜索，旧式类采用深度优先搜索。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">foo1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">print</span> <span class="token string">"A"</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">foo2</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">foo1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">print</span> <span class="token string">"C"</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">pass</span>


d <span class="token operator">=</span> D<span class="token punctuation">(</span><span class="token punctuation">)</span>
d<span class="token punctuation">.</span>foo1<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>缺点：</strong>经典类的查找顺序是深度优先的规则，在访问<code>d.foo1()</code>的时候,D-&gt;B-&gt;A,找到了<code>foo1()</code>,调用A的<code>foo1()</code>，导致C重写的<code>foo1()</code>被绕过</p>
<h3 id="类方法、类实例方法、静态方法"><a href="#类方法、类实例方法、静态方法" class="headerlink" title="类方法、类实例方法、静态方法"></a>类方法、类实例方法、静态方法</h3><ul>
<li><p>类方法: 是类对象的方法，使用 @classmethod 进行装饰，形参有cls，表示类对象</p>
</li>
<li><p>类实例方法: 是类实例化对象的方法，形参为self，指代对象本身;</p>
</li>
<li><p>静态方法: 是一个任意函数，使用 @staticmethod 进行装饰</p>
<blockquote>
<p>实例方法只能通过实例对象调用；</p>
<p>类方法和静态方法可以通过类对象或者实例对象调用，</p>
<p>使用实例对象调用的类方法或静态方法，最终通过类对象调用。</p>
</blockquote>
</li>
</ul>
<h3 id="如何判断是函数还是方法？"><a href="#如何判断是函数还是方法？" class="headerlink" title="如何判断是函数还是方法？"></a>如何判断是函数还是方法？</h3><p>如果是以函数的形式定义或者是静态方法，一定是函数</p>
<p>如果是类方法，一定是方法。</p>
<p>实例方法是方法，如果类直接调用实例方法，则是函数（直接调用运行是有问题的）。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> types <span class="token keyword">import</span> MethodType<span class="token punctuation">,</span>FunctionType
<span class="token keyword">print</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>obj<span class="token punctuation">.</span>func<span class="token punctuation">,</span> FunctionType<span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token keyword">print</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>obj<span class="token punctuation">.</span>func<span class="token punctuation">,</span> MethodType<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="接口类与抽象类"><a href="#接口类与抽象类" class="headerlink" title="接口类与抽象类"></a>接口类与抽象类</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Operate_database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 接口类1</span>
    <span class="token keyword">def</span> <span class="token function">query</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sql<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> NotImplementedError

    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sql<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> NotImplementedError

<span class="token keyword">from</span> abc <span class="token keyword">import</span> ABCMeta<span class="token punctuation">,</span>abstractmethod
<span class="token keyword">class</span> <span class="token class-name">Operate_database</span><span class="token punctuation">(</span>metaclass<span class="token operator">=</span>ABCMeta<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 接口类2</span>
    @abstractmethod
    <span class="token keyword">def</span> <span class="token function">query</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sql<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>

    @abstractmethod
    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sql<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> Python 原生仅支持抽象类，不支持接口类，abc模块就是用来实现抽象类的。</p>
<p>若是类中所有的方法都没有实现，则认为这是一个接口，</p>
<p>若是有部分方法实现，则认为这是一个抽象类。</p>
<p>抽象类和接口类都仅用于被继承，不能被实例化.</p>
<h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><ul>
<li>一个实现了<code>__get__()</code>、<code>__set__()</code>、<code>__delete__()</code>其中至少一个方法的类就是一个描述符。</li>
<li>只实现了<code>__get__()</code>的称作非数据描述符</li>
<li>实现了<code>__get__()</code>和<code>__set__()</code>方法的称作数据描述符。</li>
</ul>
<p><code>__get__</code>： 用于访问属性。它返回属性的值，若属性不存在、不合法等都可以抛出对应的异常。</p>
<p><code>__set__</code>：将在属性分配操作中调用。</p>
<p><code>__delete__</code>：控制删除操作。</p>
<p>描述符的作用和优势，以弥补Python动态类型的缺点。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Score</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
     self<span class="token punctuation">.</span>_score <span class="token operator">=</span> default

  <span class="token keyword">def</span> <span class="token function">__set__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">if</span> <span class="token operator">not</span> isinstance<span class="token punctuation">(</span>value<span class="token punctuation">,</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>
       <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">'Score must be integer'</span><span class="token punctuation">)</span>

     <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> value <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">:</span>
       <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'Valid value must be in [0, 100]'</span><span class="token punctuation">)</span>

     self<span class="token punctuation">.</span>_score <span class="token operator">=</span> value

  <span class="token keyword">def</span> <span class="token function">__get__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> owner<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">return</span> self<span class="token punctuation">.</span>_score

  <span class="token keyword">def</span> <span class="token function">__delete__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">del</span> self<span class="token punctuation">.</span>_score    

<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
  math <span class="token operator">=</span> Score<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  chinese <span class="token operator">=</span> Score<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  english <span class="token operator">=</span> Score<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> math<span class="token punctuation">,</span> chinese<span class="token punctuation">,</span> english<span class="token punctuation">)</span><span class="token punctuation">:</span>
     self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
     self<span class="token punctuation">.</span>math <span class="token operator">=</span> math
     self<span class="token punctuation">.</span>chinese <span class="token operator">=</span> chinese
     self<span class="token punctuation">.</span>english <span class="token operator">=</span> english<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>staticmethod</strong></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>
  @staticmethod
  <span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># 上下两种写法等价</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true"># 重点：这就是描述符的体现</span>
  <span class="token comment" spellcheck="true"># 每调用一次，它都会经过描述符类的 __get__</span>
  myfunc <span class="token operator">=</span> staticmethod<span class="token punctuation">(</span>myfunc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>classmethod</strong></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">classmethod</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">:</span>
     self<span class="token punctuation">.</span>f <span class="token operator">=</span> f
  <span class="token keyword">def</span> <span class="token function">__get__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> owner<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"in classmethod __get__"</span><span class="token punctuation">)</span>
     <span class="token keyword">def</span> <span class="token function">newfunc</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
       <span class="token keyword">return</span> self<span class="token punctuation">.</span>f<span class="token punctuation">(</span>owner<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
     <span class="token keyword">return</span> newfunc

<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">myfunc</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true"># 重点：这就是描述符的体现</span>
  myfunc <span class="token operator">=</span> classmethod<span class="token punctuation">(</span>myfunc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p><strong>元类是用来创建类的类。</strong></p>
<p>如果类属性中定义了<code>__metaclass__</code>，则在创建类的时候用元类来创建；</p>
<p>如果没有则向其父类查找<code>__metaclass__</code>。</p>
<p>如果都没有，则用<code>type()</code>创建类。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># metaclass是类的模板，所以必须从`type`类型派生：</span>
<span class="token keyword">class</span> <span class="token class-name">ListMetaclass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> name<span class="token punctuation">,</span> bases<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        attrs<span class="token punctuation">[</span><span class="token string">'add'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">lambda</span> self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> self<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token keyword">return</span> type<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> name<span class="token punctuation">,</span> bases<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">MyList</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> metaclass<span class="token operator">=</span>ListMetaclass<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>传入关键字参数<code>metaclass</code>时，指示Python解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建</p>
<p>在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>
<p><code>__new__()</code>方法接收到的参数依次是：</p>
<ol>
<li>当前准备创建的类的对象；</li>
<li>类的名字；</li>
<li>类继承的父类集合；</li>
<li>类的方法集合。</li>
</ol>
<p><strong>元类作用</strong></p>
<ul>
<li>拦截类的创建</li>
<li>修改类</li>
<li>返回修改后的类</li>
</ul>
<p><strong>应用场景</strong></p>
<p>ORM：所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>
<blockquote>
<p>元类中的<code>__call__</code>会在你每次实例化的时候调用, 其实和<code>Foo.__new__</code>是一样的, 如果你的Foo定义了<code>__new__</code>, 元类中的<code>__call__</code>便不会执行</p>
<p>元类中的<code>__new__</code>会在加载类的时候执行一次，在创建类的时候会调用类的<code>__new__</code>或者元类的<code>__call__</code></p>
</blockquote>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典的查询、添加、删除的平均时间复杂度都是<code>O(1)</code>。因为字典是通过哈希表来实现的.</p>
<ul>
<li><p>计算key的hash值<code>hash(key)</code>，再和mask做与操作【mask=字典最小长度（DictMinSize） - 1】，运算后会得到一个数字【index】，这个index就是要插入的enteies哈希表中的下标位置</p>
</li>
<li><p>若index下标位置已经被占用，则会判断enteies的key是否与要插入的key是否相等</p>
<ul>
<li><p>如果key相等就表示key已存在，则更新value值</p>
</li>
<li><p>如果key不相等，就表示hash冲突，则会继续向下寻找空位置，一直到找到剩余空位为止。</p>
</li>
</ul>
</li>
</ul>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a><strong>开放寻址法</strong></h3><p>开放寻址法中，所有的元素都存放在散列表里，当产生哈希冲突时，通过一个探测函数计算出下一个候选位置，如果下一个获选位置还是有冲突，不断通过探测函数往下找，直到找个一个空槽来存放待插入元素。</p>
<blockquote>
<p>开放寻址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法</p>
</blockquote>
<p>采用哈希表，dict的哈希表里每个slot都是一个自定义的entry结构：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   Py_ssize_t me_hash<span class="token punctuation">;</span>
   PyObject <span class="token operator">*</span>me_key<span class="token punctuation">;</span>
   PyObject <span class="token operator">*</span>me_value<span class="token punctuation">;</span>
<span class="token punctuation">}</span> PyDictEntry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个entry有三种状态Active, Unused, Dummy。</p>
<ul>
<li><p>Unused:me_key == me_value == NULL，即未使用的空闲状态。</p>
</li>
<li><p>Active:me_key != NULL, me_value != NULL，即该entry已被占用</p>
</li>
<li><p>Dummy:me_key == dummy, me_value == NULL。</p>
</li>
</ul>
<p><strong>为什么entry有Dummy状态呢？</strong></p>
<p>用开放寻址法中，<strong>遇到哈希冲突时会找到下一个合适的位置，</strong>例如ABC构成了探测链，查找元素时如果hash值相同，那么也是<strong>顺着这条探测链不断往后找</strong>，当删除探测链中的某个元素时，如果直接把B从哈希表中移除，即变成Unused状态，那么C就不可能再找到了，因此需要Dummy保证探测链的连续性。</p>
<p>dict对象的定义为：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> _dictobject <span class="token punctuation">{</span>
  PyObject _HEAD
  Py_ssize_t ma_fill<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* # Active + # Dummy */</span>
  Py_ssize_t ma_used<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* # Active */</span>
  Py_ssize_t ma_mask<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//slot -1</span>
  PyDictEntry <span class="token operator">*</span>ma_table<span class="token punctuation">;</span>
  PyDictEntry <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>ma_lookup<span class="token punctuation">)</span><span class="token punctuation">(</span>PyDictObject <span class="token operator">*</span>mp<span class="token punctuation">,</span> PyObject <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">long</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 搜索函数指针</span>
  PyDictEntry ma_smalltable<span class="token punctuation">[</span>PyDict_MINSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//默认的slot</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="dict对象的创建"><a href="#dict对象的创建" class="headerlink" title="dict对象的创建"></a><strong>dict对象的创建</strong></h3><p>dict对象的创建很简单，先看看缓冲的对象池里有没有可用对象，如果有就直接用，没有就从堆上申请。</p>
<h3 id="dict对象的插入"><a href="#dict对象的插入" class="headerlink" title="dict对象的插入"></a><strong>dict对象的插入</strong></h3><p>如果不存在key-value则插入，存在则覆盖。</p>
<ul>
<li>生成Hash</li>
<li>如果可用的entry&lt;0，字典扩容</li>
<li>基于key、hash，查找可用哈希位置，以便于存储<ul>
<li>字典中是否有空余的值，或者如果找到了满足 hash 值与 key 相同的,就将 value 设置为找到的值</li>
</ul>
</li>
<li>保存key、Hash、value值</li>
</ul>
<h3 id="dict对象的删除"><a href="#dict对象的删除" class="headerlink" title="dict对象的删除"></a><strong>dict对象的删除</strong></h3><p>算出哈希值，找到entry，将其从Active转换成Dummy，并调整table的容量。</p>
<p><strong>注意</strong></p>
<p>（1） dict的key 或者 set的值都必须是可hash的不可变对象，都是可hash的</p>
<p>（2）当发现内存空间中的“空”只有1/3时，便会触发扩容操作。</p>
<h3 id="OrderedDict实现"><a href="#OrderedDict实现" class="headerlink" title="OrderedDict实现"></a>OrderedDict实现</h3><p>使用了双向循环链表+哈希的方法</p>
<ol>
<li>哈希用来快速获取LinkNode，从而获取value，也支持快速定位</li>
<li>双向链表可以快速删除一个元素，使用哈希可以实现基于key快速查找</li>
<li>循环链表可以使得处理变得更加简单，不需要保存dummy的head和tail，以快速获取收尾节点。只需要保存实际的head，通过head.prev来快速定位尾结点。</li>
</ol>
<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><h3 id="小整数对象池"><a href="#小整数对象池" class="headerlink" title="小整数对象池"></a>小整数对象池</h3><p>Python使用<strong>小整数对象池</strong>small_ints缓存了[-5，257）之间的整数，该范围内的整数在Python系统中是共享的，值相同就属于同一个对象。</p>
<p>对于同一个代码块中值不在<code>small_ints</code>缓存范围内的整数，如果同一个代码块中已经存在一个值与其相同的整数对象，那么就直接引用该对象，否则创建新的<code>int</code>对象。</p>
<h3 id="整型不会溢出原理"><a href="#整型不会溢出原理" class="headerlink" title="整型不会溢出原理"></a>整型不会溢出原理</h3><p>1、用动态的可变长的结构，显然，数组的形式能够胜任</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">[</span>longintrepr<span class="token punctuation">.</span>h<span class="token punctuation">]</span>
<span class="token keyword">struct</span> _longobject <span class="token punctuation">{</span>
    PyObject_VAR_HEAD
    <span class="token keyword">int</span> <span class="token operator">*</span>ob_digit<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2、保存形式：数组中每个int存放它的上限（2^31 - 1），这样表示大数时，数组长度更短，更省空间。但是，空间确实是更省了，但操作会代码麻烦，比方大数做乘积操作，由于元素之间存在乘法溢出问题，所以只保存 <code>15</code>位，这样元素之间的乘积就可以只用 <code>int</code> 类型保存即可, 对乘积结果做位移操作就能得到尾部和进位 <code>carry</code>了</p>
<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><p>Python解释器中使用了 intern（字符串驻留）的技术来提高字符串效率，值同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池中，是共用的。</p>
<p><strong>简单原理</strong></p>
<p>维护一个字符串存储池，这个池子是一个字典结构</p>
<p>如果字符串已经存在于池子中，直接返回之前创建好的字符串对象，</p>
<p>如果不存在，则构造一个字符串对象并加入到池子中去。</p>
<blockquote>
<p>在shell中，并非全部的字符串都会采用intern机制。仅仅包括下划线、数字、字母的字符串才会被intern。不能超过20个字符。因为如果超过xx个字符的话，解释器认为这个字符串不常用，不用放入字符串池中。</p>
<p>字符串拼接时，运行时拼接，不会intern；例如”hell” + “o”在编译时完成拼接的才会intern</p>
</blockquote>
<h3 id="字符串不等"><a href="#字符串不等" class="headerlink" title="字符串不等"></a>字符串不等</h3><p><strong>字符串打印出来看着一样，但是判断却是False</strong>？</p>
<p>如果两个字符串末尾有其他符号，比如回车‘\n’，print的时候无法发现的</p>
<p><strong>==判断是 True ，is 判断却是 False?<em>**</em></strong></p>
<p>字符串来自不同的内存块，内存地址不一样</p>
<p><strong>is判断是False，用id判断却是True</strong></p>
<pre class="line-numbers language-python"><code class="language-python">In <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> foo<span class="token punctuation">.</span>bar <span class="token keyword">is</span> Foo<span class="token punctuation">.</span>bar
Out<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">False</span>

In <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> id<span class="token punctuation">(</span>foo<span class="token punctuation">.</span>bar<span class="token punctuation">)</span> <span class="token operator">==</span> id<span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>bar<span class="token punctuation">)</span>
Out<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>foo.bar本身并不是简单的名字，而是表达式的计算结果，是一个 method object，method object只是一个临时的中间变量而已，对临时的中间变量做id是没有意义的。</p>
<p>只有你能保证对象不会被销毁的前提下，你才能用 id 来比较两个对象。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="不同列表表达式的区别"><a href="#不同列表表达式的区别" class="headerlink" title="不同列表表达式的区别"></a>不同列表表达式的区别</h3><p>a = a <em> 10<br>b </em>= 10</p>
<p>不同的操作，乘法操作会调用 <code>list_repeat()</code> ；<code>*=</code> 会调用 <code>list_inplace_repeat()</code></p>
<p><code>list_repeat</code> 需要多少空间就申请多少空间，<code>list_inplace_repeat()</code>会申请比所需的空间还要大点的内存</p>
<h2 id="堆-栈"><a href="#堆-栈" class="headerlink" title="堆 栈"></a>堆 栈</h2><p>在Python中，变量也称为：对象的引用。变量存储的就是对象的地址。</p>
<p><strong>变量位于：栈内存。</strong></p>
<p><strong>对象位于：堆内存。</strong></p>
<p>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。</p>
<p><strong>代码区：</strong>程序中的代码数据、二进制数据、方法数据等等程序运行需要的预加载数据。</p>
<p><strong>静态数据区：</strong>存储<strong>全局变量、静态变量</strong>。</p>
<p><strong>栈区：</strong>存储变量。存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。</p>
<p><strong>堆区</strong>：对象真实数据。</p>
<h2 id="内存回收机制"><a href="#内存回收机制" class="headerlink" title="内存回收机制"></a>内存回收机制</h2><p>python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h3><p><strong>原理：</strong>每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数加1，每当该对象的引用失效时，计数减1，一旦对象的引用计数为0，该对象立即被回收，占用的内存空间将被释放。</p>
<p><strong>缺点：</strong>不能解决对象的循环引用</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>解决容器对象可能产生的循环引用问题。（只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等）</p>
<p><strong>A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达</strong>；</p>
<p>B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>标记清除时，应用程序会被暂停，为了减少应用程序暂停的时间。</p>
<p><strong>对象存在时间越长，越可能不是垃圾，应该越少去收集</strong>。</p>
<p>给对象定义了三种世代，每一个新生对象在0代中，如果它在一轮gc扫描中活了下来，那么它将被移至1代，在那里他将较少的被扫描，如果它又活过了一轮gc，它又将被移至2代，在那里它被扫描的次数将会更少。</p>
<h3 id="gc的扫描在什么时候会被触发呢"><a href="#gc的扫描在什么时候会被触发呢" class="headerlink" title="gc的扫描在什么时候会被触发呢?"></a><strong>gc的扫描在什么时候会被触发呢</strong>?</h3><p>年轻代链表的总数达到上限时。</p>
<p>当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。</p>
<h3 id="调优手段"><a href="#调优手段" class="headerlink" title="调优手段"></a><strong>调优手段</strong></h3><p>1.手动垃圾回收</p>
<p>2.调高垃圾回收阈值</p>
<p>3.避免循环引用</p>
<h3 id="退出Python时，是否释放全部内存？"><a href="#退出Python时，是否释放全部内存？" class="headerlink" title="退出Python时，是否释放全部内存？"></a>退出Python时，是否释放全部内存？</h3><p>进程退出的时候，资源最终都会释放掉，这是操作系统负责的。</p>
<p>如果是一段程序运行结束之后：</p>
<ol>
<li>CPython会通过引用计数立即释放引用数量为0的对象（其它版本解释器并不保证）；循环引用的对象会在下一次GC时释放，除非有两个对象都带有<code>__del__</code>析构函数，且直接或间接循环引用。这种情况下，所有循环引用的对象都无法被释放。原因在于无法确定<code>__del__</code>的执行顺序。</li>
<li>全局引用的对象无法被回收，但也不只是模块中直接或间接保存的对象，还包括未退出的线程使用的对象，解释器缓存的小整数和字符串，还有C模块里间接引用的对象等等。</li>
<li>C扩展直接通过malloc分配的内存自然无法通过gc来回收，但一般如果存在没有被回收的内存说明是有内存泄漏的，这属于实现的bug</li>
</ol>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。在Python中，进程适合计算密集型任务。</p>
<h4 id="进程间的通信（IPC）"><a href="#进程间的通信（IPC）" class="headerlink" title="进程间的通信（IPC）"></a>进程间的通信（IPC）</h4><p><strong>1）管道（Pipe</strong>）：通过<code>send()</code>和<code>recv()</code>来发送和接受信息，适合父子进程关系或者两个子进程之间。 </p>
<p>2）<strong>有名管道（FIFO）</strong>：有名管道也是半双工的通信方式。 将自己注册到文件系统里一个文件，通过读写这个文件进行通信。允许在没有亲缘关系的进程之间使用。要求读写双方必须同时打开才可以继续进行读写操作，否则打开操作会堵塞直到对方也打开。</p>
<p>3）<strong>信号量（Semaphore）</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 创建子进程时将信号量my_semaphore作为参数传入子进程任务函数，子进程中使用semaphore.acquire() 尝试获取信号量，semaphore.release()尝试 释放信号量。</p>
<p><strong>4）队列（Queue）</strong>。 使用get/put在父子进程关系或者两个子进程之间通信。</p>
<p>5）<strong>信号 （signal）</strong>：用于通知接收进程某个事件已经发生，可以设置信号处理函数。 </p>
<p>6）共享内存（shared memory）：操作系统负责将同一份物理地址的内存映射到多个进程的不同的虚拟地址空间中。进而每个进程都可以操作这份内存。需要在进程访问时做好并发控制，比如使用信号量。 python标准库mmap，apache开源的pyarrow都是。</p>
<p>7）套接字（socket）：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。 </p>
<p><strong>8）文件</strong> </p>
<p>（1）仅进程同步不涉及数据传输，可以使用信号、信号量；<br>（2）若进程间需要传递少量数据，可以使用管道、有名管道、队列；<br>（3）若进程间需要传递大量数据，最佳方式是使用共享内存，推荐使用pyarrow，这样减少数据拷贝、传输的时间内存代价；<br>（4）跨主机的进程间通信（RPC）可以使用socket通信。</p>
<p><strong>共享变量</strong></p>
<p>使用 Process 定义的多进程之间（父子或者兄弟）共享变量可以直接使用 multiprocessing 下的 Value，Array，Queue 等，如果要共享 list，dict，可以使用强大的 Manager 模块。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是cpu调度执行的最小单位，依赖进程存在，一个进程至少有一个线程。在python中，线程适合IO密集型任务。</p>
<p>同一个进程下的线程共享程序的内存空间<strong>（如代码段，全局变量，堆等）</strong></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>继承Thread，重写run方法，通过start方法开线程</p>
<p>将要执行的方法作为参数传给Thread的构造方法</p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>线程有五种状态:创建、就绪、运行、阻塞、死亡。 </p>
<ul>
<li><p>调用start方法时，线程就会进入就绪状态。 </p>
</li>
<li><p>在线程得到cpu时间片时进入运行状态。 </p>
</li>
<li><p><strong>线程调用yield方法可以让出cpu时间回到就绪状态</strong>。 </p>
</li>
<li><p>线程运行时可能<strong>由于IO、调用sleep、wait、join方法或者无法获得同步锁等原因进入阻塞</strong>状态。 </p>
</li>
<li><p>当线程获得到等待的资源资源或者引起阻塞的条件得到满足时，会从阻塞状态进入就绪状态。 </p>
</li>
<li><p>当线程的run方法执行结束时，线程就进入死亡状态。</p>
</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>多个线程同时对一个公共资源（如全局变量）进行操作的情况，为了避免发生混乱。<code>threading.lock</code>，<code>acquire()</code>方法上锁，<code>release()</code>方法解锁</p>
<p>可重入锁：为了支持在同一线程中多次请求同一资源，python提供了threading.RLock。重入锁必须由获取它的同一个线程释放，同时要求解锁次数应与加锁次数相同，才能用于另一个线程。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>阻塞线程直到子线程全部结束。</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>不重要线程。主线程会等所有‘重要’线程结束后才结束。</p>
<h4 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h4><p>减少线程本身创建和销毁造成的开销，属于典型的空间换时间操作。</p>
<p>创建和释放线程涉及到大量的系统底层操作，开销较大，如果变成预创建和借还操作，将大大减少底层开销。</p>
<ul>
<li>在应用程序启动后，线程池创建一定数量的线程，放入空闲队列中。这些线程最开始都处于阻塞状态，不会消耗CPU，占用少量的内存。</li>
<li>当任务到来后，从队列中取出一个空闲线程，把任务派发到这个线程中运行，并将标记为已占用。</li>
<li>当线程池中所有的线程都被占用后，可以选择自动创建一定数量的新线程，用于处理更多的任务，也可以选择让任务排队等待直到有空闲的线程可用。</li>
<li>在任务执行完毕后，线程并不退出结束，而是继续保持在池中等待下一次的任务。</li>
<li>当系统比较空闲时，大部分线程长时间处于闲置状态时，线程池可以自动销毁一部分线程，回收系统资源。</li>
</ul>
<p>线程池组成部分：</p>
<ol>
<li>线程池管理器：用于创建并管理线程池。</li>
<li>工作线程和线程队列：线程池中实际执行的线程以及保存这些线程的容器。</li>
<li>任务接口：将线程执行的任务抽象出来，形成任务接口，确保线程池与具体的任务无关。</li>
<li>任务队列：线程池中保存等待被执行的任务的容器。</li>
</ol>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是一种用户态的轻量级线程，用户自己来编写调度逻辑的。</p>
<p>协程拥有自己的寄存器上下文和栈。协程的切换都在用户空间内进行，不需要进行系统调用。对CPU来说，协程其实是单线程，所以CPU不用去考虑怎么调度、切换上下文，这就省去了CPU的切换开销，所以协程在一定程度上又好于多线程</p>
<p>协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，基本没有内核切换的开销，可以不加锁的访问全局变量，上下文的切换非常快。</p>
<blockquote>
<p>不管是进程还是线程，每次阻塞、切换都需要陷入系统调用，先让CPU跑操作系统的调度程序，然后再由调度程序决定该跑哪一个进程/线程。</p>
<hr>
<p>协程又称微线程，属于用户级线程。 gevent 就是一种协程实现方式，除了 gevent 还有 asyncio。用户级线程就是在一个内核调度实体上映射出来的多个用户线程，用户线程的创建、调度和销毁完全由用户程序控制, 对内核调度透明：内核一旦将 cpu 分配给了线程，该 cpu 的使用权就归该线程所有，线程可以再次按照比如时间片轮转等常规调度算法分配给每个微线程，从而实现更大的并发自由度，但所有的微线程只能在该 cpu 上运行，无法做到并行。</p>
<p>把协程看作这些映射出来的“微线程”。用户程序控制的协程需要解决线程的挂起和唤醒、现场保护等问题，然而区别于线程的是协程不需要处理锁和同步问题，因为多个协程是在一个用户级线程内进行的，但需要处理因为单个协程阻塞导致整个线程（进程）阻塞的问题。</p>
</blockquote>
<h4 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h4><p>创建协程对象的方法其实有两个参数 <code>greenlet(run=None, parent=None)</code>。参数 run 就是其要调用的方法；参数 parent 定义了该协程对象的父协程，也就是说，greenlet 协程之间是可以有父子关系的。如果不设或设为空，则其父协程就是程序默认的”main”主协程。这个”main”协程不需要用户创建，它所对应的方法就是主程序，而所有用户创建的协程都是其子孙。</p>
<p>在子协程执行完毕后，会自动返回父协程。</p>
<h4 id="eventlet"><a href="#eventlet" class="headerlink" title="eventlet"></a>eventlet</h4><p>eventlet 在 Greenlet 的基础上实现了自己的 GreenThread，实际上就是 greenlet 类的扩展封装，而与 Greenlet 的不同是，Eventlet 实现了自己调度器称为 Hub，Hub 类似于 Tornado 的 IOLoop，是单实例的。在 Hub 中有一个 event loop，根据不同的事件来切换到对应的 GreenThread。</p>
<h4 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h4><p>gevent 是基于 libev(Linux 上 epoll）和 greenlet 实现的 <strong>Python 网络库</strong>。libev 是一个事件循环器：向 libev 注册感兴趣的事件，比如 socket 可读事件，libev 会对所注册的事件的源进行管理，并在事件发生时触发相应的程序。也就是说 libev 提供了指定文件描述符事件发生时调用回调函数的机制。</p>
<h4 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h4><p> Python 3.4 试验性引入的异步 I/O 框架，提供了基于协程做异步 I/O 编写单线程并发代码的基础设施。其核心组件有事件循环（Event Loop）、协程 (Coroutine）、任务(Task)、未来对象(Future) 以及其他一些扩充和辅助性质的模块。</p>
<blockquote>
<p>定义好的协程并不能直接使用，需要将其包装成为了一个任务（task 对象），然后放到事件循环中才能被执行。所谓 task 对象是 Future 类的一个子类，保存了协程运行后的状态，用于未来获取协程的结果。</p>
</blockquote>
<p><strong>使用步骤</strong></p>
<ul>
<li>定义协程函数</li>
<li>封装成 task（非必须，直接将协程放到事件循环中，事件循环会自动完成这一操作）</li>
<li>获取事件循环</li>
<li>将 task 放到事件循环中执行。</li>
</ul>
<p><strong>协程函数</strong></p>
<p>如果协程函数调用了阻塞操作，那么其他协程和主线程将被阻塞。这意味着协程函数逻辑要么使用用非阻塞功能，要么同步调用的功能时间很短，否则无法发挥协程的并发优势。</p>
<p>比如request请求url就是同步调用，无法真正实现并发。幸运的是aio库中有对应的异步实现：aiohttp。</p>
<p><strong>如何利用多核CPU呢？</strong></p>
<p>最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程</p>
<p><strong>常用模块</strong></p>
<p>greenlet：提供了切换任务的快捷方式，但是遇到io无法自动切换任务，需要手动切换</p>
<p>gevent：开启协程任务并切换的模块，遇到io自动切换任务。</p>
<p>asyncio：<code>@asyncio.coroutine</code>装饰器的函数称为协程函数。</p>
<p><code>yield from</code>语法用于将一个生成器部分操作委托给另一个生成器。</p>
<p><code>async</code>/<code>await</code>：<code>@asyncio.coroutine</code>和<code>yield from</code>的语法糖</p>
<p><strong>缺点</strong></p>
<ul>
<li><p>无法利用多核资源：协程的本质是个单线程</p>
</li>
<li><p>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</p>
</li>
</ul>
<p><strong>协程主要使用场景</strong></p>
<p>网络请求，比如爬虫，大量使用 aiohttp</p>
<p>文件读取， aiofile</p>
<p>web 框架， aiohttp， fastapi</p>
<p>数据库查询， asyncpg, databases</p>
<p><strong>协程优于线程</strong></p>
<ul>
<li>python 线程调度方式是，每执行 100 个字节码或者遇到阻塞就停止当前线程，然后进行一个系统调用，让 os 内核选出下一个线程。但是协程只会在阻塞的时候，切换到下一个协程。因此线程的切换存在很多是无效的切换，当线程数量越大，这种因为调度策略的先天不足带来的性能损耗就越大。</li>
<li>线程需要进行系统调用，协程不需要。系统调用需要进入内核态，无效的调度会让这部分开销显得更大</li>
<li>协程可以自主调度，而线程只能决定合适退出，但是下一个线程是谁则依赖于操作系统。</li>
</ul>
<h3 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h3><p>孤儿进程： <strong>父进程退出，子进程还在运行的这些子进程都是孤儿进程，</strong>孤儿进程将被init 进程（进程号为1）所收养，并由init 进程对他们完成状态收集工作。</p>
<p>僵尸进程： 进程使用fork 创建子进程<strong>，如果子进程退出，而父进程并没有调用wait 获取子进程的状态信息</strong>，那么子进程的进程描述符仍然保存在系统中，这些进程是僵尸进程。</p>
<p>避免僵尸进程的方法：</p>
<p>1.用<code>wait()</code>函数使父进程阻塞，这个<code>wait()</code>操作就负责回收子进程，这样也不会产生僵尸进程。但这样做有个致命的问题，wait是阻塞的，如果进行wait，主进程就什么都做不了。</p>
<p>2.使用信号量，子进程退出时向父进程发送SIGCHILD信号，在signal handler 中调用waitpid，这样父进程不用阻塞</p>
<p>3.fork 两次用孙子进程去完成子进程的任务，孙子进程刚产生，它的父亲就退出了，成了孤儿进程，由init收养</p>
<h2 id="Global-Interpreter-Lock"><a href="#Global-Interpreter-Lock" class="headerlink" title="Global Interpreter Lock"></a>Global Interpreter Lock</h2><p>Python 默认的解释器是 CPython，<strong>GIL 是存在于 CPython 解释器中的</strong>。</p>
<p> <strong>CPython 解释器的内存管理</strong>不是线程安全的。执行 Python 字节码时，引入了为了保护访问 Python 对象而阻止多个线程执行的一把互斥锁GIL。某个线程想要执行，必须先拿到GIL锁，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。</p>
<p><strong>因此，同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核CPU</strong>，<strong>也没办法让多个线程「并行」地同时执行代码，只能是交替执行</strong>，因为多线程涉及到上线文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。</p>
<p>尽管存在 GIL，但 python 多线程仍然不是线程安全的，对于共享状态的场合仍然需要借助锁同步。</p>
<p>常见的 Python 解释器：IPython（基于Cython）、Jython（Python 代码编译成 Java 字节码，依赖 Java 平台，不存在 GIL）、IronPython（ .Net 平台下的 Python 解释器，Python 代码编译成 .Net 字节码，不存在 GIL）</p>
<h3 id="GIL原理"><a href="#GIL原理" class="headerlink" title="GIL原理"></a>GIL原理</h3><p>python 的线程就是 C 语言的 pthread，它是通过操作系统调度算法调度执行的。</p>
<p>Python 2.x 的代码执行是基于 opcode 数量的调度方式，简单来说就是每执行一定数量的字节码，或遇到系统 IO 时，会强制释放 GIL，然后触发一次操作系统的线程调度。</p>
<p> Python 3.x 基于固定时间的调度方式，就是每执行固定时间的字节码，或遇到系统 IO 时，强制释放 GIL，触发系统的线程调度。</p>
<h3 id="为什么会有GIL"><a href="#为什么会有GIL" class="headerlink" title="为什么会有GIL"></a>为什么会有GIL</h3><p>90年代单核 CPU 还是主流，多线程的应用场景也不多，大部分时候还是以单线程的方式运行，单线程不要涉及线程的上下文切换，效率反而比多线程更高（在多核环境下，不适用此规则），设计一个全局锁是<strong>那个时代保护多线程资源一致性最简单经济的设计方案</strong>。</p>
<p>多核心时代来临，当大家试图去拆分和去除 GIL 的时候，发现大量库的代码和开发者已经重度依赖 GIL（默认认为 Python内部对象是线程安全的，无需在开发时额外加锁），所以这个去除 GIL 的任务变得复杂且难以实现。</p>
<blockquote>
<p>CPython 解释器在创建变量时，首先会分配内存，然后对该变量的引用进行计数，这称为 引用计数。如果变量的引用数变为 0，这个变量就会从内存中释放掉。而当多个线程内共享一个变量时，CPython 锁定引用计数的关键就在于使用了 GIL，它会谨慎地控制线程的执行情况，无论同时存在多少个线程，解释器每次只允许一个线程进行操作。</p>
</blockquote>
<h3 id="GIL的实现是线程不安全-为什么"><a href="#GIL的实现是线程不安全-为什么" class="headerlink" title="GIL的实现是线程不安全?为什么?"></a>GIL的实现是线程不安全?为什么?</h3><p>单核情况下:</p>
<p><img src="gil.png" alt></p>
<blockquote>
<ol>
<li>到第5步的时候，可能这个时候python正好切换了一次GIL(据说python2.7中，每100条指令会切换一次GIL),执行的时间到了，被要求释放GIL,这个时候thead 1的count=0并没有得到执行，而是挂起状态，count=0这个上下文关系被存到寄存器中.</li>
<li>然后到第6步，这个时候thead 2开始执行，然后就变成了count = 1,返回给count，这个时候count=1.</li>
<li>然后再回到thead 1，这个时候由于上下文关系，thead 1拿到的寄存器中的count = 0，经过计算，得到count = 1，经过第13步的操作就覆盖了原来的count = 1的值，所以这个时候count依然是count = 1，所以这个数据并没有保护起来。</li>
</ol>
</blockquote>
<p>python2.x和3.x都是在执行IO操作的时候，强制释放GIL，使其他线程有机会执行程序。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="python为什么慢"><a href="#python为什么慢" class="headerlink" title="python为什么慢"></a>python为什么慢</h3><ul>
<li><p>GIL</p>
<p>无论同时存在多少个线程，解释器每次只允许一个线程进行操作。</p>
</li>
<li><p>解释型语言而不是编译型语言</p>
<p>Python 都会解释字节码并本地执行。.NET 和 Java 都是 JIT 编译的，JIT 会允许在运行时进行优化，缺点是启动慢。</p>
</li>
<li><p>动态类型的语言</p>
<p>类型比较和类型转换消耗的资源是比较多的，每次读取、写入或引用变量时都会检查变量的类型</p>
</li>
</ul>
<h3 id="lru-cache装饰器"><a href="#lru-cache装饰器" class="headerlink" title="lru_cache装饰器"></a>lru_cache装饰器</h3><p>为函数提供缓存功能。在下次以相同参数调用时直接返回上一次的结果，要求参数可hash。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>Python 标准库提供了同一分析接口的两种不同实现：</p>
<ol>
<li>建议使用 <a href="https://docs.python.org/zh-cn/3/library/profile.html#module-cProfile" target="_blank" rel="noopener"><code>cProfile</code></a> ；这是一个 C 扩展插件，因为其合理的运行开销，所以适合于分析长时间运行的程序。</li>
<li><a href="https://docs.python.org/zh-cn/3/library/profile.html#module-profile" target="_blank" rel="noopener"><code>profile</code></a> 是一个纯 Python 模块（<a href="https://docs.python.org/zh-cn/3/library/profile.html#module-cProfile" target="_blank" rel="noopener"><code>cProfile</code></a> 就是模拟其接口的 C 语言实现），但它会显著增加配置程序的开销。如果你正在尝试以某种方式扩展分析器，则使用此模块可能会更容易完成任务</li>
</ol>
<p>支持输出：调用次数、在指定函数中消耗的总时间（不包括调用子函数的时间）、指定的函数及其所有子函数（从调用到退出）消耗的累积时间、函数运行一次的平均时间</p>
<h3 id="加速python运行"><a href="#加速python运行" class="headerlink" title="加速python运行"></a>加速python运行</h3><ol>
<li><p>优化代码和算法</p>
<ul>
<li>避免全局变量</li>
<li>避免模块和函数属性访问：对于频繁访问的变量<code>sqrt</code>，通过将其改为局部变量可以加速运行。</li>
<li>避免类内属性访问：通过将需要频繁访问的类内属性赋值给一个局部变量，可以提升代码运行速度。</li>
<li>避免数据复制：交换值时不使用中间变量、避免无意义的数据复制、字符串拼接用join而不是+</li>
<li>利用if条件的短路特性</li>
<li>使用numba.jit</li>
<li>循环优化： 用for循环代替while循环、使用隐式for循环代替显式for循环</li>
<li>选择合适的数据结构：如果有频繁的新增、删除操作，新增、删除的元素数量又很多时，list的效率不高。此时，应该考虑使用collections.deque。</li>
</ul>
</li>
<li><p>使用 PyPy</p>
<p>PyPy通过使用一种 Just-in-time（JIT，即时编译）技术来实现的。CPython 使用解释来执行代码，虽然这一做法提供了很大的灵活性，但速度也变得慢了下来。使用 JIT，你的代码是在运行程序时即时编译的。它结合了 Ahead-of-time（AOT，提前编译）技术的速度优势（由 C 和 C++ 等语言使用）和解释的灵活性。另一个优点是 JIT 编译器可以在运行时不断优化代码。代码运行的时间越长，它就会变得越优化。</p>
</li>
<li><p>使用线程</p>
</li>
<li><p>使用 Asyncio</p>
</li>
<li><p>同时使用多个处理器</p>
</li>
</ol>
<p>使用多个进程，使用分布式方案等。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a><strong>使用装饰器</strong></h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">singleton</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
  instances <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">if</span> cls <span class="token operator">not</span> <span class="token keyword">in</span> instances<span class="token punctuation">:</span>
       instances<span class="token punctuation">[</span>cls<span class="token punctuation">]</span> <span class="token operator">=</span> cls<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
     <span class="token keyword">return</span> instances<span class="token punctuation">[</span>cls<span class="token punctuation">]</span>
  <span class="token keyword">return</span> wrapper

@singleton
<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">pass</span>

foo1 <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
foo2 <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>foo1 <span class="token keyword">is</span> foo2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用new"><a href="#使用new" class="headerlink" title="使用new"></a>使用new</h3><p>New 是真正创建实例对象的方法，所以重写基类的new 方法，以此保证创建对象的时候只生成一个实例。</p>
<p>但是以上的方法在多线程中会有线程安全问题，当有多个线程同时去初始化对象时，就很可能同时判断__instance is None，从而进入初始化instance的代码中。所以需要用<strong>互斥锁</strong>来解决这个问题。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token string">'_instance'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
       cls<span class="token punctuation">.</span>_instance <span class="token operator">=</span> super<span class="token punctuation">(</span>Singleton<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
     <span class="token keyword">return</span> cls<span class="token punctuation">.</span>_instance

<span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
  __instance <span class="token operator">=</span> None
  <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
     <span class="token keyword">if</span> cls<span class="token punctuation">.</span>__instance <span class="token keyword">is</span> None<span class="token punctuation">:</span>
       cls<span class="token punctuation">.</span>__instance <span class="token operator">=</span> super<span class="token punctuation">(</span>Singleton<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
     <span class="token keyword">return</span> cls<span class="token punctuation">.</span>__instance

<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">pass</span>

foo1 <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
foo2 <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>foo1 <span class="token keyword">is</span> foo2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="用装饰器实现同步锁"><a href="#用装饰器实现同步锁" class="headerlink" title="用装饰器实现同步锁"></a>用装饰器实现同步锁</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">make_synchronized</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">import</span> threading
    func<span class="token punctuation">.</span>__lock__ <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">synced_func</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">with</span> func<span class="token punctuation">.</span>__lock__<span class="token punctuation">:</span>
            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>

    <span class="token keyword">return</span> synced_func

<span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
    __instance <span class="token operator">=</span> None
    @make_synchronized
    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> cls<span class="token punctuation">.</span>__instance<span class="token punctuation">:</span>
            cls<span class="token punctuation">.</span>__instance <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>__instance<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="双重检查线程安全单例模式"><a href="#双重检查线程安全单例模式" class="headerlink" title="双重检查线程安全单例模式"></a>双重检查线程安全单例模式</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">SingletonSample</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
    _instanceLock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>

    @classmethod
    <span class="token keyword">def</span> <span class="token function">get_instance</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># 初次检查，避免锁竞争</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token string">"_instance"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">with</span> cls<span class="token punctuation">.</span>_instanceLock<span class="token punctuation">:</span>
                <span class="token comment" spellcheck="true"># 获取到锁后再次判断，避免重复创建</span>
                <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token string">"_instance"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    cls<span class="token punctuation">.</span>_instance <span class="token operator">=</span> super<span class="token punctuation">(</span>SingletonSample<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>
                    <span class="token keyword">print</span> cls<span class="token punctuation">.</span>_instance
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>_instance<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="classmethod"><a href="#classmethod" class="headerlink" title="classmethod"></a>classmethod</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time
<span class="token keyword">import</span> threading
<span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
     _instance_lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span> 
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        
    @classmethod
    <span class="token keyword">def</span> <span class="token function">instance</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">with</span> Singleton<span class="token punctuation">.</span>_instance_lock<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 加锁</span>
            <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>Singleton<span class="token punctuation">,</span> <span class="token string">'_instance'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                Singleton<span class="token punctuation">.</span>_instance <span class="token operator">=</span> Singleton<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
            <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>_instance<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="元类-1"><a href="#元类-1" class="headerlink" title="元类"></a>元类</h3><p>元类是用于创建类对象的类，类对象创建实例对象时一定要调用call方法，因此在调用call时候保证始终只创建一个实例即可，type是python的元类</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token string">'_instance'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            cls<span class="token punctuation">.</span>_instance <span class="token operator">=</span> super<span class="token punctuation">(</span>Singleton<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">.</span>__call__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>_instance

<span class="token comment" spellcheck="true"># Python2</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
    __metaclass__ <span class="token operator">=</span> Singleton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="线程安全–元类"><a href="#线程安全–元类" class="headerlink" title="线程安全–元类"></a>线程安全–元类</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading

<span class="token keyword">class</span> <span class="token class-name">MetaSingleton</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>
    _instance_lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token string">'_instance'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">with</span> MetaSingleton<span class="token punctuation">.</span>_instance_lock<span class="token punctuation">:</span>
                <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token string">'_instance'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                    cls<span class="token punctuation">.</span>_instance <span class="token operator">=</span> super<span class="token punctuation">(</span>MetaSingleton<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">.</span>__call__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>_instance



<span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>metaclass<span class="token operator">=</span>MetaSingleton<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="select-poll和epoll"><a href="#select-poll和epoll" class="headerlink" title="select,poll和epoll"></a>select,poll和epoll</h2><p> select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 </p>
<h2 id="docker和virtualenv技术具体有什么不同？"><a href="#docker和virtualenv技术具体有什么不同？" class="headerlink" title="docker和virtualenv技术具体有什么不同？"></a>docker和virtualenv技术具体有什么不同？</h2><ul>
<li>virtualenv是python的版本和库管理器，virtualenv虚拟python运行环境</li>
<li>docker是虚拟化整个系统环境工具，docker不仅可以跑python，还可以跑其他的需要进程环境隔离的程序。</li>
</ul>
<p>环境的特点有二：</p>
<ul>
<li>Python版本固定。即使系统的Python升级了，虚拟环境中的仍然不受影响，保留开发状态。</li>
<li>所有Python软件包，都只在这个环境生效。一旦退出，则回到用户+系统的默认环境中。</li>
</ul>
<p>这两个特点，由两个小手段实现。</p>
<ul>
<li>改变当前Shell的<code>PATH</code>。</li>
<li>改变Python运行时的<code>sys.path</code>。</li>
</ul>
<pre><code></code></pre>
            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《python必知必会》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/04/13/interview-python/" property="cc:attributionName"
               rel="cc:attributionURL">
                wangyixin-tom
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'ea3985c0f8fdba464dea',
        clientSecret: '2856369f95a20dce67cacde330ad344d409acb09',
        repo: 'wangyixin-tom.github.io',
        owner: 'WangYixin-Tom',
        admin: "WangYixin-Tom",
        id: '2021/04/13/interview-python/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/04/22/flask-mian-shi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="flask">
                        
                        <span class="card-title">flask</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Flask框架WEB框架它们接收 HTTP 请求，然后分发任务，并生成 HTML，然后返回包含 HTML 的 HTTP 应答。
应用启动过程
run 方法启动了 Flask 应用

run 方法调用werkzeug 的 run_simple
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-04-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/interview/" class="post-category" target="_blank">
                                    interview
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/interview/" target="_blank">
                        <span class="chip bg-color">interview</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/04/12/interview-redis/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/27.jpg" class="responsive-img" alt="redis必知必会">
                        
                        <span class="card-title">redis必知必会</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            主要内容转载自https://thinkwon.blog.csdn.net/article/details/103522351
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-04-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/interview/" class="post-category" target="_blank">
                                    interview
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/interview/" target="_blank">
                        <span class="chip bg-color">interview</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 好好学习<br />'
            + '作者: wangyixin-tom<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2010-2021 yixin. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">175.3k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/WangYixin-Tom" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:tomwangyx@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/WangYixin-Tom" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=2276505170&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="https://weibo.com/WangYixin-Tom" class="tooltipped" target="_blank" data-tooltip="关注我的微博" data-position="top" data-delay="50">
        <i class="fa fa-weibo"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 10, 25, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>
	<!-- 
    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>-->
	

    <!-- Global site tag (gtag.js) - Google Analytics -->



    
    <script src="/libs/others/clicklove.js"></script>
    

    

    <!-- 雪花特效 -->
    

</body>

</html>