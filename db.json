{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","path":"libs/codeBlock/clipboard.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","path":"medias/avatars/ajin.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/babyq.png","path":"medias/avatars/babyq.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","path":"medias/avatars/cww97.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/feibar.jpg","path":"medias/avatars/feibar.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/fun4go.png","path":"medias/avatars/fun4go.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hael.jpg","path":"medias/avatars/hael.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","path":"medias/avatars/hzwer.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","path":"medias/avatars/ids2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","path":"medias/avatars/kewlgrl.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","path":"medias/avatars/ldy.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","path":"medias/avatars/lijiaqian.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","path":"medias/avatars/liyangzone.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","path":"medias/avatars/liyucheng.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","path":"medias/avatars/masterx.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/michael.jpg","path":"medias/avatars/michael.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","path":"medias/avatars/mouse.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mpy634.png","path":"medias/avatars/mpy634.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","path":"medias/avatars/qiqiang.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/spacesac.png","path":"medias/avatars/spacesac.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","path":"medias/avatars/sunchangzhi.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","path":"medias/avatars/taotao.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","path":"medias/avatars/taowei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","path":"medias/avatars/tawn.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/yezijie.png","path":"medias/avatars/yezijie.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","path":"medias/avatars/zhaokangzhe.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","path":"medias/avatars/antnlp.ico","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","path":"medias/avatars/duyupei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","path":"medias/avatars/gsy.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","path":"medias/avatars/huaji.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jiejie.jpg","path":"medias/avatars/jiejie.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","path":"medias/avatars/milyyy.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","path":"medias/avatars/mizunashi.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","path":"medias/avatars/myzhihu.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","path":"medias/avatars/qiandongwei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xiejiadong.jpg","path":"medias/avatars/xiejiadong.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","path":"medias/avatars/xuzhongyou.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","path":"medias/avatars/zhangting.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","path":"medias/avatars/zzw.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/0xbird.png","path":"medias/avatars/0xbird.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","path":"medias/avatars/lyn-draw.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qianqian.png","path":"medias/avatars/qianqian.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","path":"medias/music/avatars/tiantangdemogui.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","path":"medias/music/avatars/yequ.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","path":"medias/music/avatars/yiluxiangbei.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","path":"medias/avatars/jitao.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lzh.png","path":"medias/avatars/lzh.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","path":"medias/avatars/mashiro.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/feibar.png","path":"medias/avatars/feibar.png","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","path":"medias/avatars/zhangyi.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/28.jpg","path":"medias/featureimages/28.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","path":"medias/avatars/jingjing.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","path":"medias/music/avatars/daoshu.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myphoto.jpg","path":"medias/avatars/myphoto.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"d97f69ff63501de89cfd341c68e4d6ed5c8a5b3a","modified":1586000622000},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1586000622000},{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1586000622000},{"_id":"themes/matery/README.md","hash":"7ef16198a2c5ff580f006582286354caf160c7fe","modified":1586000622000},{"_id":"themes/matery/README_CN.md","hash":"a94324950e0299bcfcbc106cf2ca65c93e1fe843","modified":1586000622000},{"_id":"themes/matery/_config.yml","hash":"ae89fade84450b8ab59b50c35776152a126358dd","modified":1615104658795},{"_id":"source/_data/friends.json","hash":"c43c4d3a74db36e032cf2e7f7490c5d4d34e9210","modified":1615106764017},{"_id":"source/_data/musics.json","hash":"32bc061f34721b4ff55f880de1d0ec5787acd2f9","modified":1586000622000},{"_id":"source/_posts/count优化.md","hash":"bdf154f2cde047f6f4b09d464b597ca09a00fd2a","modified":1615639205286},{"_id":"source/_posts/join优化.md","hash":"afb0303b6e22769a1146fda2d6fd5602436f98f8","modified":1615631226514},{"_id":"source/_posts/kafka集群配置.md","hash":"8d2ff93a28ac75688dfb67de29dd71b6307858aa","modified":1607607889227},{"_id":"source/_posts/order-group-by优化.md","hash":"bca012d7f80698959ec06e9dde2590b5ea20bc8a","modified":1615626879952},{"_id":"source/_posts/rabbitmq消息发布.md","hash":"b6e67abfc1f0093923a8af65cd4aa6166ef02879","modified":1603721628938},{"_id":"source/_posts/rabbitmq消息可靠性.md","hash":"8f8f4eeea62378891d77fedc7c9ae39382a6c1d7","modified":1615471304046},{"_id":"source/_posts/rabbitmq消息消费.md","hash":"946777a117103736d6f15adecde5409683d32353","modified":1603721831348},{"_id":"source/_posts/rabbitmq消息路由.md","hash":"1d32c514247018fcec0c08fabae92afdf9ffbea9","modified":1603721738277},{"_id":"source/_posts/rabbitmq消息重复.md","hash":"b8b72adf928198d7772a06ef5c63cf3b7b37770d","modified":1603721950087},{"_id":"source/_posts/rabbitmq集群.md","hash":"8ea6fdb44a965e7f22ed539abf55c9e428aae7f6","modified":1603721896538},{"_id":"source/_posts/redis-AOF机制.md","hash":"675a4e33968172b364f1d1948577e2fbce9165eb","modified":1603721305343},{"_id":"source/_posts/redis-RDB机制.md","hash":"501c4d2b3b429216accf8804062c0374c862a6d8","modified":1603721413293},{"_id":"source/_posts/redis6-0.md","hash":"8e829eece2427f0a3874ba05c8970c8fffc27755","modified":1607493182082},{"_id":"source/_posts/redis主从同步.md","hash":"b31f733b87838b72fad20fa9c72be2c1477a39c9","modified":1604323217833},{"_id":"source/_posts/redis事务.md","hash":"a8552e592146342fe51c02e07d987789ba029f07","modified":1604235622149},{"_id":"source/_posts/redis内存碎片.md","hash":"e4ac549f2816d507345bc1a00e3d3ff15c1cd5fb","modified":1604324108711},{"_id":"source/_posts/redis分布式锁.md","hash":"8667dfdc52a2f8c8885b4634ce0cb2cd34c2ff24","modified":1604208304898},{"_id":"source/_posts/redis切片集群.md","hash":"93e67eb629d15feab238039bf312cd893d0c0eb4","modified":1615117414157},{"_id":"source/_posts/redis变慢以及优化方法.md","hash":"5724afc78d9315dda68d52d55c9d24dde5fa7891","modified":1603719797126},{"_id":"source/_posts/redis哨兵机制.md","hash":"dbdb10f82407e7f5f6913001af31045c9e27a1a9","modified":1603634779503},{"_id":"source/_posts/redis应用.md","hash":"f01885914eb418135c116e4520aefd5e31a98163","modified":1615382580022},{"_id":"source/_posts/redis思维导图.md","hash":"08526dda584566618d420a5ebdc8a0d4c5cb5fe7","modified":1615162165459},{"_id":"source/_posts/redis数据结构.md","hash":"6881be6e42c82fc47200987fc6fd314b2ae63b7f","modified":1603721141804},{"_id":"source/_posts/redis消息队列.md","hash":"df875a13f8d854ca17a274240043fc1acd358ed4","modified":1604326459108},{"_id":"source/_posts/redis缓存.md","hash":"c36d9fb79afc96a585d5e4aa1acd45dc3f84dbbc","modified":1615212279698},{"_id":"source/_posts/redis网络IO模型.md","hash":"951aded6df67e876dcd0e90ea2cb19e2af916466","modified":1603721212697},{"_id":"source/_posts/redis阻塞及解决办法.md","hash":"8ce1764e6437eb8e9bb246233fbd33dec33761ac","modified":1615119883496},{"_id":"source/_posts/sort-algorithms.md","hash":"e59c0afb4170b475a29d14455cf2af9afa2819ee","modified":1586000622000},{"_id":"source/_posts/事务.md","hash":"2c99a5206e2315e8e4052279b270664295c57dc1","modified":1615723622106},{"_id":"source/_posts/分页查询优化.md","hash":"9bbfe31c77fefe0ec30df497041295c98445c272","modified":1615627962737},{"_id":"source/_posts/基于多CPU多核架构的redis性能优化.md","hash":"f6f9df87303456ad9b85ca5f3c41f5e584aef335","modified":1603719685063},{"_id":"source/_posts/慢查询定位与分析.md","hash":"38f21bbffbfa7748ad36461844ba97389d554706","modified":1615471235122},{"_id":"source/_posts/批量数据导入优化.md","hash":"896eba462cdb72f44b79795f570a55a5abaef84e","modified":1615620774185},{"_id":"source/_posts/索引.md","hash":"2f5c8f85eb677f1b05bbbc18df57642ee9a444b3","modified":1615722993145},{"_id":"source/_posts/索引失效.md","hash":"ba428d8321720d6bb7c2ae4c5c08b590b96bfe7c","modified":1615607152199},{"_id":"source/_posts/锁.md","hash":"2e951fe9ffe2e9cb4a1cac8f3c6dfb2e7b6385e2","modified":1615722997345},{"_id":"source/about/index.md","hash":"a3d3c7ec9071176499cd18493c60491a63236664","modified":1615102438684},{"_id":"source/archives/index.md","hash":"30a0e3a59be650ae34d7bb86ac7da53e21e9cf5b","modified":1586000622000},{"_id":"source/categories/index.md","hash":"67687d3f908737f7c680f096b3e80d9412f23b0e","modified":1586000622000},{"_id":"source/contact/index.md","hash":"cd32065677703674069fc39b5ad8b66ba518a794","modified":1615104303873},{"_id":"source/friends/index.md","hash":"899e67aed2e7f7b622ea06fd8b08e50f1ac5e7cc","modified":1615103591911},{"_id":"source/tags/index.md","hash":"fe3d7ecc91b81b062a6a60c06859dc24b9d704ac","modified":1586000622000},{"_id":"themes/matery/languages/default.yml","hash":"527c795b8c41fe62bf35603ffebfa6d4a7929a2c","modified":1586000622000},{"_id":"themes/matery/languages/zh-CN.yml","hash":"d92db4b986bb6f0d228e9a8249383103bf56342d","modified":1586000622000},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1586000622000},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1586000622000},{"_id":"themes/matery/layout/archive.ejs","hash":"1b5023571894404d75caffa28128fc9c49f9095d","modified":1586000622000},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1586000622000},{"_id":"themes/matery/layout/category.ejs","hash":"2d421e10c3b8fd2c4f725e5eaa967c4a1429c707","modified":1586000622000},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1586000622000},{"_id":"themes/matery/layout/friends.ejs","hash":"895e40a864796680fbef581e4b09f252fbdd963a","modified":1586000622000},{"_id":"themes/matery/layout/index.ejs","hash":"7fc5a6c4f0229c0be43b7d1315524c468346fbb8","modified":1586000622000},{"_id":"themes/matery/layout/layout.ejs","hash":"2ba4110dc596424b1220a259c8e594da774e7f59","modified":1586000622000},{"_id":"themes/matery/layout/post.ejs","hash":"f1a35f32e5901e167ae9a750e7cb3635549cea2e","modified":1586000622000},{"_id":"themes/matery/layout/tag.ejs","hash":"5cdf3a1d72f54285ee9cb826fd0e4a0449093215","modified":1586000622000},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1586000622000},{"_id":"themes/matery/source/favicon.png","hash":"979ccca1f7334916e1407716ef8a79736997535a","modified":1603617823563},{"_id":"source/_posts/sort-algorithms/1.png","hash":"cb9865eb782b293168e69406b212a0f3097b82a4","modified":1586000622000},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1586000622000},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"ab610754bf6aea844b5ae0802ed37c73b5f1dc9f","modified":1586000622000},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1586000622000},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1586000622000},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"f9923debb0cfb3aaf7bf730bab43d35843cf0c33","modified":1603613401237},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"a3a140e6aeeb6f289e4b821a577ef548267f3de1","modified":1586000622000},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1586000622000},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1586000622000},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1586000622000},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"9007283743db3361c026a9879eb2376c41ff9c6c","modified":1603613653946},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1586000622000},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"d4042e5521ceb5f3255cd4455ac7ccd227fee6df","modified":1586000622000},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1586000622000},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"e761f0104fbf431671bbe6bebc91ca82f737f4d2","modified":1586000622000},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"3a82fcb6f31d69971cb564985842c14ac02cdca0","modified":1586000622000},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1586000622000},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"166c0b9753f3f913bd801e82ad5b268004be198d","modified":1586000622000},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1586000622000},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1586000622000},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1586000622000},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e73f10eacb5d00a0681cb44fe5c039cd8ab03cd","modified":1586000622000},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1586000622000},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1586000622000},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1586000622000},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1586000622000},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"e2865b3003ec07892e9112692e7ec786ee926ae8","modified":1586000622000},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"c3039180ddb2eb17e724b8441e5f93e79859aef7","modified":1586000622000},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1586000622000},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1586000622000},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"6ae58a57b83a5999d0b6a737ec868f084d208f89","modified":1586000622000},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1586000622000},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1586000622000},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1586000622000},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1586000622000},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1586000622000},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1586000622000},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"d439d86818de179d64965d4f7f5fa56147fd9221","modified":1586000622000},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1586000622000},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1586000622000},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1586000622000},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1586000622000},{"_id":"themes/matery/source/css/matery.css","hash":"0d345a72318fd7aadcb6fcaa6f3abac94b91001c","modified":1586000622000},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1586000622000},{"_id":"themes/matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1586000622000},{"_id":"themes/matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1586000622000},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1586000622000},{"_id":"themes/matery/source/medias/logo.png","hash":"979ccca1f7334916e1407716ef8a79736997535a","modified":1603617823563},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1586000622000},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1586000622000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1586000622000},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1586000622000},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1586000622000},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1586000622000},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1586000622000},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1586000622000},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1586000622000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1586000622000},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1586000622000},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1586000622000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1586000622000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1586000622000},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1586000622000},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1586000622000},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1586000622000},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1586000622000},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1586000622000},{"_id":"themes/matery/source/libs/others/snow.js","hash":"b393f069781eef788a0ae66b2681cece8fea2851","modified":1586000622000},{"_id":"themes/matery/source/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1586000622000},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1586000622000},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1586000622000},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/feibar.jpg","hash":"343f47cb5c83cd866a1c824cbe2a112d02516d06","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/yezijie.png","hash":"8a53537eb69f749115e512b6da061e7f23cd04e5","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"1f8bbfbd625448b4b2a748b75636e456b826dcd3","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"c4cc724f4572a9bcede7443a4f4c0393d3073868","modified":1586000622000},{"_id":"source/_posts/redis主从同步/duxiefenli.jpg","hash":"c42908d4a016e55ca0e85a69c7c4509e1b0ebfc9","modified":1603530395000},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1586000622000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1586000622000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1586000622000},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1586000622000},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1586000622000},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"f1558f12d96a352e490166d543a8e821dd3bb2bc","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/jiejie.jpg","hash":"a52476e25bec2391674e77a889a89341fbb29791","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","hash":"992e0d803160d2ae867be5eb0032d324d1cedffb","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/xiejiadong.jpg","hash":"f1a31f89426bd4dccdaba2170f4fc701336702e1","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1586000622000},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"309f484b6e69e877de6a7fb847d66497d22bbd65","modified":1586000622000},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"105c06576d1a1136bdf3a81905c7ddcc43ede294","modified":1603616771058},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1586000622000},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"f63c7c489524ccb5d95e74fcd6618116c58fb305","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1586000622000},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1586000622000},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"2c27939768606603bee3b5e6c8a722596a667e60","modified":1586000622000},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1586000622000},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1586000622000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1586000622000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1586000622000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1586000622000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1586000622000},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1586000622000},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1586000622000},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1586000622000},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"280fa1c6493d7fdccfc18bd486446bacd9afe623","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"d8cc7a730668943dcb0776cfa240a0cf76826363","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1586000622000},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1586000622000},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1586000622000},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1586000622000},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"b22124cb6498bf1b896b28f7a8edad2d4bc95d68","modified":1603616817163},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1586000622000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1586000622000},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"d4db93afdff4ce889dd8271bcf9e80eb3c0bf866","modified":1586000622000},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"4fcbc9dd8ec0316e9dd5bfd0caf86f1520b10b3f","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"1c1063c29f827cf52eeef7ca8dc2d7e4efa31a76","modified":1586000622000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"c2892770fd5617418fd33d6f834879e05b2cdafd","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"1d8863277d744e1a18a2778ac26041bda5b03a98","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/25.jpg","hash":"d0668539783fc615f14178644e486a6befb90c0c","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/28.jpg","hash":"c73036359640a67a8b17db7ba0e968c088957ab8","modified":1586000622000},{"_id":"source/_posts/redis思维导图/redis.png","hash":"316e710e31e0f9e9d6c32fc3a27f93facc6f8034","modified":1615161877002},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1586000622000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1586000622000},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"a3cfdee2120195ab36b2fdd074d5558852e69297","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"84ba9cf61045de789426eeb6333910266ce29b8c","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"ee598933707f8bb98ecbf36925f24e8a1c4bd2d6","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/27.jpg","hash":"7ea6f890cc59def8b1c9f393e4ae77cd16c79aad","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"ceb8e0c195a7fe7420334efa114e98cd0e1c6523","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"bd400da9123424afe7ba6c839be9ad7697c1245b","modified":1586000622000},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1586000622000},{"_id":"source/_posts/redis主从同步/master_slave_slave.jpg","hash":"08d5a49519bf88de6d9596593c4bc56ea7a28aa9","modified":1603631021057},{"_id":"source/_posts/redis缓存/buyizhi2.jpg","hash":"a6450b90fe504f52318ac5163bcf7ee6e8913366","modified":1603893948635},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"6ddd1bcbb62a2d28c5be3b9acb7418849d60b2e7","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"11a6de283124964370dbfaf0e74f2f1e9ac8394d","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/24.jpg","hash":"72bc68fb0673b84ab9f863d2979396cdc268a76c","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/26.jpg","hash":"c66a4e7a2e670b63759a091f9428ee7f971d7b56","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"698fc46e97428d73c9d4e3d254e88b9b66fb38cd","modified":1586000622000},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"255aaa4375da855bd80b38cfcc253de892a9d4cf","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"66de48d963e7f221931e550b2442da0cd40cbaa8","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"2b30186c6d78ed76fa5f278be57290c1bd22c96a","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"0801e96a2f4cbd14b2ad44547e5ffbb23822e751","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"c74ce6fa4eee122e147ec55532744f34a87ae2bf","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"f1d720039d654d693c32150c06c78cfc3663b0b4","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"a77810cc2224446f5d4e1a857a8d480f21e81f83","modified":1586000622000},{"_id":"themes/matery/source/medias/avatars/myphoto.jpg","hash":"669f8b38abb3ded420786054c86f95fef9ef4527","modified":1608375008575},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"f81e97edf705ab45b989b2b15d6a13c005ccaa32","modified":1586000622000},{"_id":"source/_posts/redis缓存/buyizhi.jpg","hash":"2e01f8fa0c307cdd02731705115a8f4e0751f50a","modified":1603893742738},{"_id":"source/_posts/redis6-0/acl_cmd.jpg","hash":"450f8fc436cabfa7fc6fdc4685fac3b96617c458","modified":1607492939178},{"_id":"source/_posts/redis主从同步/zhucongtongbu.jpg","hash":"09776048a670719e96d92ef2f14ee62f082167c3","modified":1603531048586},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"cd54b116609f5741cc7db0f7f49bf56ac356ddfb","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"aff885598033614639944c7559b4849f883e2b34","modified":1586000622000},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"e06afe32a867f7a6e861618e0b5ac9d93cd71d05","modified":1586000622000},{"_id":"public/baidu_urls.txt","hash":"7d50b3ac675e6362f8a682432730ba2a52513861","modified":1615723638446},{"_id":"public/baidusitemap.xml","hash":"e662a41d52b4599a06f41092a84b6bd132c77316","modified":1615723638450},{"_id":"public/atom.xml","hash":"04e1e4a1329195e052c0014c18407f30e52dcb3c","modified":1615723639661},{"_id":"public/search.xml","hash":"a4c473361bd52dbf23192dfa2be24eafe9b937bd","modified":1615723640212},{"_id":"public/sitemap.xml","hash":"c90964fff6fa7a46aad408d0cb61576ba454f762","modified":1615723640212},{"_id":"public/404.html","hash":"6ef4d2abc505b3f2d7aca49eb2cd3425bafbb1c9","modified":1615723640280},{"_id":"public/about/index.html","hash":"4a119d0dc60f97ea614270c8114990d038277908","modified":1615723640280},{"_id":"public/archives/index.html","hash":"c987d5b9230572e34c0ee6699e291013d2123b14","modified":1615723640322},{"_id":"public/categories/index.html","hash":"444c94513bed5b0d3788bc2c9f3b08d212c2d4b4","modified":1615723640328},{"_id":"public/contact/index.html","hash":"c77cff21411da7efeb4c47eaa309da4dbd200bbc","modified":1615723640328},{"_id":"public/friends/index.html","hash":"b44942d22bc1a764c98837c67d92d9d3ef42daa5","modified":1615723640329},{"_id":"public/tags/index.html","hash":"ceec19b8652a7bd1d82e28cdf855904007acb571","modified":1615723640330},{"_id":"public/2021/03/14/suo/index.html","hash":"acd7ad1c4b57734b55b74334a90831ad4c47a000","modified":1615723640330},{"_id":"public/2021/03/13/suo-yin/index.html","hash":"a92730ba8186ef61331c21674eadfdcb2f6b099b","modified":1615723640330},{"_id":"public/2021/03/13/count-you-hua/index.html","hash":"d2fdac0916db5efd784a8ef5f2eb76d52a5843d5","modified":1615723640330},{"_id":"public/2021/03/13/join-you-hua/index.html","hash":"aefac3f0e26164a0f842814376634246abdde544","modified":1615723640330},{"_id":"public/2021/03/13/fen-ye-cha-xun-you-hua/index.html","hash":"ccbf69a997f1925546664932bc86442d5c2fe603","modified":1615723640330},{"_id":"public/2021/03/13/order-group-by-you-hua/index.html","hash":"0b60affc066d0cf3f7a7096141d36714cfa0df1d","modified":1615723640331},{"_id":"public/2021/03/13/pi-liang-shu-ju-dao-ru-you-hua/index.html","hash":"582d315e9733e06b6a7a2b03ea9618a872904535","modified":1615723640331},{"_id":"public/2021/03/13/suo-yin-shi-xiao/index.html","hash":"18519c70e4fc6ad4349cc611a03ae3e1bd10e21e","modified":1615723640331},{"_id":"public/2021/03/11/man-cha-xun-ding-wei-yu-fen-xi/index.html","hash":"d4f21efe4b62ae2b6abcf404a8c7ec5a2ac8bfb7","modified":1615723640331},{"_id":"public/2021/03/10/redis-ying-yong/index.html","hash":"6865950fbe22a443b94b35e30686a7592b6e4448","modified":1615723640331},{"_id":"public/2021/03/08/redis-si-wei-dao-tu/index.html","hash":"e9306c39545bad7b636a51587e015e18f69f6bb2","modified":1615723640331},{"_id":"public/2020/12/10/kafka-ji-qun-pei-zhi/index.html","hash":"3c5d5e0ff13bc5a5cd23ef8a75ea99d1e95834f2","modified":1615723640331},{"_id":"public/2020/12/09/redis6-0/index.html","hash":"ee83726957fc66b325ddf735a2c547ae1bc8cc94","modified":1615723640332},{"_id":"public/2020/11/02/redis-xiao-xi-dui-lie/index.html","hash":"975f39c314dd950e4e6efb07911ac0ff12fddf02","modified":1615723640332},{"_id":"public/2020/11/02/redis-nei-cun-sui-pian/index.html","hash":"c8d92e05465f8a523a893c801d72ed17297d4f96","modified":1615723640333},{"_id":"public/2020/11/01/redis-shi-wu/index.html","hash":"f0475287b5169aba2814714be29896b62dd76c29","modified":1615723640334},{"_id":"public/2020/10/29/redis-fen-bu-shi-suo/index.html","hash":"bfacedcf96211133e1d49d9dfbbe5ff038a5f663","modified":1615723640335},{"_id":"public/2020/10/27/redis-huan-cun/index.html","hash":"bbe96875fda545b61c78aabb85f206d7924ab13c","modified":1615723640335},{"_id":"public/2020/10/26/rabbitmq-xiao-xi-ke-kao-xing/index.html","hash":"8d9d857989b30d48f4fdc5ba066c8b470e2bb634","modified":1615723640336},{"_id":"public/2020/10/26/rabbitmq-xiao-xi-chong-fu/index.html","hash":"733ff32f29ce61cb4f8d817c6691390ecc44607a","modified":1615723640336},{"_id":"public/2020/10/26/rabbitmq-ji-qun/index.html","hash":"de1a8edeb0b4b6e67ee78a81d63cc4bb2bcdd24d","modified":1615723640336},{"_id":"public/2020/10/26/rabbitmq-xiao-xi-xiao-fei/index.html","hash":"d5582740d01117073a2c02b692f8d9892bd58734","modified":1615723640336},{"_id":"public/2020/10/26/rabbitmq-xiao-xi-lu-you/index.html","hash":"8104e1d6b3b66fcc72a48cb75c0e74af4f044271","modified":1615723640336},{"_id":"public/2020/10/26/rabbitmq-xiao-xi-fa-bu/index.html","hash":"394b7646f2194877b20c84027e987ab9e86a07ec","modified":1615723640336},{"_id":"public/2020/10/26/redis-rdb-ji-zhi/index.html","hash":"07cc4256ed2d90c5ebfb0c2263dd5fa23e59f086","modified":1615723640336},{"_id":"public/2020/10/26/redis-aof-ji-zhi/index.html","hash":"e1d378f65916b299ad76f84b767fec240dbe6b6b","modified":1615723640337},{"_id":"public/2020/10/26/redis-wang-luo-io-mo-xing/index.html","hash":"1ade59dc7a8bf580643adddf4a90036fba15f4f3","modified":1615723640337},{"_id":"public/2020/10/26/redis-shu-ju-jie-gou/index.html","hash":"d8ae11e9338339655876efbb3db6f78d3cd30856","modified":1615723640337},{"_id":"public/2020/10/26/redis-bian-man-yi-ji-you-hua-fang-fa/index.html","hash":"1bc8ef1c3346fdf7c3bbca1f4b0aaecb94b1bbdb","modified":1615723640337},{"_id":"public/2020/10/26/ji-yu-duo-cpu-duo-he-jia-gou-de-redis-xing-neng-you-hua/index.html","hash":"e4b3974b65ab6365ef21c89e66a514a4ae4ec217","modified":1615723640337},{"_id":"public/2020/10/26/redis-zu-sai-ji-jie-jue-ban-fa/index.html","hash":"949e1feaf06c694bc8ba83a5522c6f054bd2d326","modified":1615723640337},{"_id":"public/2020/10/26/redis-qie-pian-ji-qun/index.html","hash":"76f3f5ea558341a844974e9d76326515b0ec343f","modified":1615723640337},{"_id":"public/2020/10/25/redis-shao-bing-ji-zhi/index.html","hash":"64b94832fc5c850e75469ca414196c0e0b45cd20","modified":1615723640338},{"_id":"public/2020/10/25/redis-zhu-cong-tong-bu/index.html","hash":"43fa78a167cce7f339a9ee8705a1a82b691f72df","modified":1615723640338},{"_id":"public/2020/02/16/sort-algorithms/index.html","hash":"3441c424455ff04335299add95b5243677a444a7","modified":1615723640338},{"_id":"public/archives/page/2/index.html","hash":"307d3629d886cfac9a1d3496777d4dd5ee86d083","modified":1615723640338},{"_id":"public/archives/page/3/index.html","hash":"520a6afcf9c31332a1cbaf33457ca58047a55640","modified":1615723640338},{"_id":"public/archives/2020/index.html","hash":"39fe4c3936f71b88742ecafe1f6118b89ba80aff","modified":1615723640338},{"_id":"public/archives/2020/page/2/index.html","hash":"190edcc99eab3f6e8cf2ffa96706c8cb60146b9e","modified":1615723640338},{"_id":"public/archives/2020/02/index.html","hash":"2c495f24de503f337b0ecc4c929c84390f2fc696","modified":1615723640339},{"_id":"public/archives/2020/10/index.html","hash":"b54ffa06a25403483a27c9dbbe5ad785d06e0acf","modified":1615723640339},{"_id":"public/archives/2020/10/page/2/index.html","hash":"366e0299677b5b3a372a5494105ac68517797666","modified":1615723640339},{"_id":"public/archives/2020/11/index.html","hash":"12a0a73aef4b5a23d1bcfe0c08c51c143647d569","modified":1615723640339},{"_id":"public/archives/2020/12/index.html","hash":"76d3db64cdb7b574e23a5463eba8551aca726a67","modified":1615723640339},{"_id":"public/archives/2021/index.html","hash":"18795c4155d9962e011edc6783097aab6b4c2044","modified":1615723640339},{"_id":"public/archives/2021/03/index.html","hash":"78279e59146896ebb6ffdc594ce64d399ee4ea57","modified":1615723640340},{"_id":"public/categories/mysql/index.html","hash":"e0e3efa2f76807d67e0762f7e44258db9ba1d410","modified":1615723640340},{"_id":"public/categories/kafka/index.html","hash":"db779e0a6f27836f8f42cdc4ebd60c8a5aed197e","modified":1615723640340},{"_id":"public/categories/rabbitmq/index.html","hash":"bf79ca8017c3a8da67d3ab21398f52670ba7cea0","modified":1615723640340},{"_id":"public/categories/redis/index.html","hash":"079740848b37a662f556c0ab20bb53dac8061b67","modified":1615723640340},{"_id":"public/categories/redis/page/2/index.html","hash":"f9de9a7f99234082866a0c6a1d0a6956ff46fd95","modified":1615723640340},{"_id":"public/categories/编程算法/index.html","hash":"b0ae9cf5e8a72334a0330055ed2eb3cd41a475b6","modified":1615723640340},{"_id":"public/index.html","hash":"46d333e2b5f94ea0b7a1caf69c3c082934445418","modified":1615723640341},{"_id":"public/page/2/index.html","hash":"2c6e9df80c68dc33f2f95dfc196120c39c124992","modified":1615723640341},{"_id":"public/page/3/index.html","hash":"2615a2730e8db8f9581b32257561c5225c835ec9","modified":1615723640341},{"_id":"public/tags/mysql/index.html","hash":"ebeddc86ad9f49eed0e80389e6e3d8bb79d676e6","modified":1615723640341},{"_id":"public/tags/kafka/index.html","hash":"f32bd2c192184afb4ae554ac3b454952461c8164","modified":1615723640341},{"_id":"public/tags/rabbitmq/index.html","hash":"310eb2b8f6c5bfdc4b0f2ad17d270df7dc990517","modified":1615723640342},{"_id":"public/tags/redis/index.html","hash":"f089951127ded573c87749cc1c5be5d2e47baeed","modified":1615723640342},{"_id":"public/tags/redis/page/2/index.html","hash":"c12f2d653f6030afc81d3150df613731544f6321","modified":1615723640342},{"_id":"public/tags/leetcode/index.html","hash":"a302a18c1cbfd5e70bf7bbd8f57df28892e628bd","modified":1615723640342},{"_id":"public/tags/算法/index.html","hash":"4b86e58bf0ebd696e92e24f27dc597f0b67858ba","modified":1615723640342},{"_id":"public/2021/03/14/shi-wu/index.html","hash":"eba2ec1fae3f832737ac9bcbb54623ffd52e1b85","modified":1615723640416},{"_id":"public/favicon.png","hash":"979ccca1f7334916e1407716ef8a79736997535a","modified":1615723640482},{"_id":"public/medias/logo.png","hash":"979ccca1f7334916e1407716ef8a79736997535a","modified":1615723640482},{"_id":"public/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1615723640483},{"_id":"public/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1615723640483},{"_id":"public/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1615723640483},{"_id":"public/medias/avatars/feibar.jpg","hash":"343f47cb5c83cd866a1c824cbe2a112d02516d06","modified":1615723640484},{"_id":"public/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1615723640489},{"_id":"public/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1615723640489},{"_id":"public/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1615723640490},{"_id":"public/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1615723640490},{"_id":"public/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1615723640490},{"_id":"public/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1615723640490},{"_id":"public/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1615723640490},{"_id":"public/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1615723640491},{"_id":"public/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1615723640491},{"_id":"public/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1615723640491},{"_id":"public/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1615723640491},{"_id":"public/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1615723640492},{"_id":"public/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1615723640492},{"_id":"public/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1615723640492},{"_id":"public/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1615723640492},{"_id":"public/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1615723640495},{"_id":"public/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1615723640495},{"_id":"public/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1615723640496},{"_id":"public/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1615723640496},{"_id":"public/medias/avatars/yezijie.png","hash":"8a53537eb69f749115e512b6da061e7f23cd04e5","modified":1615723640496},{"_id":"public/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1615723640497},{"_id":"public/medias/featureimages/0.jpg","hash":"1f8bbfbd625448b4b2a748b75636e456b826dcd3","modified":1615723640497},{"_id":"public/medias/featureimages/5.jpg","hash":"c4cc724f4572a9bcede7443a4f4c0393d3073868","modified":1615723640497},{"_id":"public/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1615723640497},{"_id":"public/medias/reward/alipay.jpg","hash":"105c06576d1a1136bdf3a81905c7ddcc43ede294","modified":1615723640498},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1615723640498},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1615723640498},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1615723640498},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1615723640499},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1615723640499},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1615723640499},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1615723640499},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1615723640499},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1615723640499},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1615723640499},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1615723640500},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1615723640502},{"_id":"public/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1615723640503},{"_id":"public/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1615723640503},{"_id":"public/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1615723640503},{"_id":"public/2020/02/16/sort-algorithms/1.png","hash":"cb9865eb782b293168e69406b212a0f3097b82a4","modified":1615723640505},{"_id":"public/css/prism-tomorrow.css","hash":"7efd268869bf07673639975ec764c9bdffd0fb04","modified":1615723640505},{"_id":"public/css/prism-line-numbers.css","hash":"e0db113a99e4a09d2161a539b1652d96e4a22fac","modified":1615723640506},{"_id":"public/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1615723640554},{"_id":"public/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1615723640583},{"_id":"public/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1615723640607},{"_id":"public/medias/avatars/jiejie.jpg","hash":"a52476e25bec2391674e77a889a89341fbb29791","modified":1615723640607},{"_id":"public/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1615723640608},{"_id":"public/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1615723640609},{"_id":"public/medias/avatars/myzhihu.png","hash":"992e0d803160d2ae867be5eb0032d324d1cedffb","modified":1615723640609},{"_id":"public/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1615723640609},{"_id":"public/medias/avatars/xiejiadong.jpg","hash":"f1a31f89426bd4dccdaba2170f4fc701336702e1","modified":1615723640609},{"_id":"public/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1615723640617},{"_id":"public/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1615723640619},{"_id":"public/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1615723640620},{"_id":"public/medias/banner/1.jpg","hash":"309f484b6e69e877de6a7fb847d66497d22bbd65","modified":1615723640620},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1615723640620},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1615723640620},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1615723640725},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1615723640725},{"_id":"public/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1615723640739},{"_id":"public/js/matery.js","hash":"92f07106944f5ef7cd72e84bb3534513d00eebe1","modified":1615723640740},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1615723640740},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1615723640740},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1615723640740},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1615723640740},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1615723640741},{"_id":"public/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1615723640741},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1615723640741},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1615723640741},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1615723640741},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1615723640741},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1615723640741},{"_id":"public/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1615723640741},{"_id":"public/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1615723640742},{"_id":"public/libs/others/snow.js","hash":"7f3b1ad2f64d4473210a2c3218893649c73c980e","modified":1615723640742},{"_id":"public/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1615723640742},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1615723640742},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1615723640742},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1615723640742},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1615723640742},{"_id":"public/css/matery.css","hash":"caa63c2c7908e45ebbbea0fbdc72d09b7b6d5b76","modified":1615723640742},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1615723640742},{"_id":"public/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1615723640743},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1615723640743},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1615723640743},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1615723640743},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1615723640743},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1615723640743},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1615723640743},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1615723640744},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1615723640744},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1615723640744},{"_id":"public/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1615723640744},{"_id":"public/libs/valine/Valine.min.js","hash":"4e34802ccbb59f1daa58a62241ff57f923e50600","modified":1615723640744},{"_id":"public/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1615723640745},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1615723640745},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"28bdb33c9eb609c2f30d431df1a4cf8ca70bf841","modified":1615723640745},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1615723640745},{"_id":"public/libs/materialize/materialize.min.css","hash":"4d46df5f22cbc24eefa76228c7ee308dc3585594","modified":1615723640745},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1615723640746},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1615723640746},{"_id":"public/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1615723640746},{"_id":"public/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1615723640746},{"_id":"public/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1615723640776},{"_id":"public/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1615723640776},{"_id":"public/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1615723640776},{"_id":"public/medias/banner/2.jpg","hash":"280fa1c6493d7fdccfc18bd486446bacd9afe623","modified":1615723640777},{"_id":"public/medias/featureimages/13.jpg","hash":"d8cc7a730668943dcb0776cfa240a0cf76826363","modified":1615723640777},{"_id":"public/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1615723640778},{"_id":"public/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1615723640778},{"_id":"public/medias/banner/0.jpg","hash":"d4db93afdff4ce889dd8271bcf9e80eb3c0bf866","modified":1615723640778},{"_id":"public/medias/banner/6.jpg","hash":"4fcbc9dd8ec0316e9dd5bfd0caf86f1520b10b3f","modified":1615723640780},{"_id":"public/medias/featureimages/14.jpg","hash":"1c1063c29f827cf52eeef7ca8dc2d7e4efa31a76","modified":1615723640780},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1615723640782},{"_id":"public/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1615723640786},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1615723640787},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1615723640856},{"_id":"public/medias/featureimages/22.jpg","hash":"02ec4566225102778c3837f08b24de02faf460a6","modified":1615723640857},{"_id":"public/medias/reward/wechat.png","hash":"b22124cb6498bf1b896b28f7a8edad2d4bc95d68","modified":1615723640860},{"_id":"public/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1615723640861},{"_id":"public/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1615723640863},{"_id":"public/2020/10/25/redis-zhu-cong-tong-bu/duxiefenli.jpg","hash":"c42908d4a016e55ca0e85a69c7c4509e1b0ebfc9","modified":1615723640865},{"_id":"public/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1615723640907},{"_id":"public/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1615723640907},{"_id":"public/medias/banner/5.jpg","hash":"6ddd1bcbb62a2d28c5be3b9acb7418849d60b2e7","modified":1615723640911},{"_id":"public/medias/banner/3.jpg","hash":"255aaa4375da855bd80b38cfcc253de892a9d4cf","modified":1615723640912},{"_id":"public/medias/featureimages/12.jpg","hash":"c2892770fd5617418fd33d6f834879e05b2cdafd","modified":1615723640934},{"_id":"public/medias/featureimages/25.jpg","hash":"d0668539783fc615f14178644e486a6befb90c0c","modified":1615723640934},{"_id":"public/medias/featureimages/28.jpg","hash":"c73036359640a67a8b17db7ba0e968c088957ab8","modified":1615723640934},{"_id":"public/medias/banner/4.jpg","hash":"a3cfdee2120195ab36b2fdd074d5558852e69297","modified":1615723640935},{"_id":"public/medias/featureimages/23.jpg","hash":"ee598933707f8bb98ecbf36925f24e8a1c4bd2d6","modified":1615723640935},{"_id":"public/medias/featureimages/3.jpg","hash":"ceb8e0c195a7fe7420334efa114e98cd0e1c6523","modified":1615723640936},{"_id":"public/medias/featureimages/17.jpg","hash":"11a6de283124964370dbfaf0e74f2f1e9ac8394d","modified":1615723640936},{"_id":"public/medias/featureimages/6.jpg","hash":"698fc46e97428d73c9d4e3d254e88b9b66fb38cd","modified":1615723640937},{"_id":"public/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1615723640964},{"_id":"public/medias/featureimages/27.jpg","hash":"7ea6f890cc59def8b1c9f393e4ae77cd16c79aad","modified":1615723640964},{"_id":"public/medias/featureimages/7.jpg","hash":"bd400da9123424afe7ba6c839be9ad7697c1245b","modified":1615723640968},{"_id":"public/medias/featureimages/26.jpg","hash":"c66a4e7a2e670b63759a091f9428ee7f971d7b56","modified":1615723640968},{"_id":"public/medias/featureimages/11.jpg","hash":"2b30186c6d78ed76fa5f278be57290c1bd22c96a","modified":1615723640970},{"_id":"public/medias/featureimages/16.jpg","hash":"0801e96a2f4cbd14b2ad44547e5ffbb23822e751","modified":1615723640970},{"_id":"public/medias/featureimages/18.jpg","hash":"c74ce6fa4eee122e147ec55532744f34a87ae2bf","modified":1615723640971},{"_id":"public/medias/avatars/myphoto.jpg","hash":"669f8b38abb3ded420786054c86f95fef9ef4527","modified":1615723640971},{"_id":"public/2021/03/08/redis-si-wei-dao-tu/redis.png","hash":"316e710e31e0f9e9d6c32fc3a27f93facc6f8034","modified":1615723640972},{"_id":"public/medias/featureimages/20.jpg","hash":"84ba9cf61045de789426eeb6333910266ce29b8c","modified":1615723640980},{"_id":"public/medias/featureimages/24.jpg","hash":"72bc68fb0673b84ab9f863d2979396cdc268a76c","modified":1615723640980},{"_id":"public/medias/featureimages/19.jpg","hash":"2a47d1123d9c4c6255b7b4817a582d2fa9aea808","modified":1615723640982},{"_id":"public/medias/featureimages/21.jpg","hash":"a77810cc2224446f5d4e1a857a8d480f21e81f83","modified":1615723640982},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1615723640983},{"_id":"public/2020/10/25/redis-zhu-cong-tong-bu/master_slave_slave.jpg","hash":"08d5a49519bf88de6d9596593c4bc56ea7a28aa9","modified":1615723640984},{"_id":"public/medias/featureimages/2.jpg","hash":"1d8863277d744e1a18a2778ac26041bda5b03a98","modified":1615723640999},{"_id":"public/medias/featureimages/10.jpg","hash":"66de48d963e7f221931e550b2442da0cd40cbaa8","modified":1615723640999},{"_id":"public/medias/featureimages/1.jpg","hash":"f1d720039d654d693c32150c06c78cfc3663b0b4","modified":1615723641000},{"_id":"public/2020/10/27/redis-huan-cun/buyizhi2.jpg","hash":"a6450b90fe504f52318ac5163bcf7ee6e8913366","modified":1615723641007},{"_id":"public/medias/featureimages/8.jpg","hash":"f81e97edf705ab45b989b2b15d6a13c005ccaa32","modified":1615723641020},{"_id":"public/2020/12/09/redis6-0/acl_cmd.jpg","hash":"450f8fc436cabfa7fc6fdc4685fac3b96617c458","modified":1615723641027},{"_id":"public/2020/10/25/redis-zhu-cong-tong-bu/zhucongtongbu.jpg","hash":"09776048a670719e96d92ef2f14ee62f082167c3","modified":1615723641028},{"_id":"public/medias/featureimages/15.jpg","hash":"aff885598033614639944c7559b4849f883e2b34","modified":1615723641037},{"_id":"public/medias/featureimages/9.jpg","hash":"cd54b116609f5741cc7db0f7f49bf56ac356ddfb","modified":1615723641039},{"_id":"public/2020/10/27/redis-huan-cun/buyizhi.jpg","hash":"2e01f8fa0c307cdd02731705115a8f4e0751f50a","modified":1615723641046},{"_id":"public/medias/featureimages/4.jpg","hash":"e06afe32a867f7a6e861618e0b5ac9d93cd71d05","modified":1615723641054}],"Category":[{"name":"mysql","_id":"ckm944w7z0005i4ufzswoal5c"},{"name":"kafka","_id":"ckm944w8p000ki4ufqcgnui3w"},{"name":"rabbitmq","_id":"ckm944w8v000ri4ufoxfl1wfi"},{"name":"redis","_id":"ckm944w9s001mi4uf3343k8nx"},{"name":"编程算法","_id":"ckm944wbw003di4ufjp397irz"}],"Data":[{"_id":"musics","data":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]},{"_id":"friends","data":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}],"Page":[{"title":"404","date":"2019-07-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2019-07-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2020-04-04T11:43:42.000Z","path":"404.html","comments":1,"_id":"ckm944w4j0000i4ufsl9vsbc1","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":""},{"title":"about","date":"2021-03-07T08:41:10.000Z","type":"about","layout":"about","_content":"\n\n## 教育经历\n* <b>硕士 信号与信息处理</b>\n西安电子科技大学\n2015/06 - 2018-06\n* <b>本科 电子信息工程</b>\n苏州大学\n2011/09 - 2015/06\n\n## 联系方式\n* <b>电子邮箱</b>\n2276505170@qq.com\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-03-07 16:41:10\ntype: \"about\"\nlayout: \"about\"\n---\n\n\n## 教育经历\n* <b>硕士 信号与信息处理</b>\n西安电子科技大学\n2015/06 - 2018-06\n* <b>本科 电子信息工程</b>\n苏州大学\n2011/09 - 2015/06\n\n## 联系方式\n* <b>电子邮箱</b>\n2276505170@qq.com\n\n","updated":"2021-03-07T07:33:58.684Z","path":"about/index.html","comments":1,"_id":"ckm944w7t0002i4uf8pg4hbdk","content":"<h2 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h2><ul>\n<li><b>硕士 信号与信息处理</b><br>西安电子科技大学<br>2015/06 - 2018-06</li>\n<li><b>本科 电子信息工程</b><br>苏州大学<br>2011/09 - 2015/06</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:2276505170@qq.com\" target=\"_blank\" rel=\"noopener\">2276505170@qq.com</a></li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h2><ul>\n<li><b>硕士 信号与信息处理</b><br>西安电子科技大学<br>2015/06 - 2018-06</li>\n<li><b>本科 电子信息工程</b><br>苏州大学<br>2011/09 - 2015/06</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:2276505170@qq.com\" target=\"_blank\" rel=\"noopener\">2276505170@qq.com</a></li>\n</ul>\n"},{"title":"archives","date":"2019-07-19T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2019-07-19 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2020-04-04T11:43:42.000Z","path":"archives/index.html","comments":1,"_id":"ckm944w7x0004i4uf677trkrf","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":""},{"title":"categories","date":"2019-07-19T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-07-19 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2020-04-04T11:43:42.000Z","path":"categories/index.html","comments":1,"_id":"ckm944w840008i4uf5qarzaem","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":""},{"title":"contact","date":"2021-03-07T08:04:02.000Z","type":"contact","layout":"contact","_content":"\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言。\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n* \n","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2021-03-07 16:04:02\ntype: \"contact\"\nlayout: \"contact\"\n---\n\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言。\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在评论区留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n\n* \n","updated":"2021-03-07T08:05:03.873Z","path":"contact/index.html","comments":1,"_id":"ckm944w87000ai4ufuxjbqky5","content":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言。</p>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><p><strong>名称：</strong>你的博客名称</p>\n</li>\n<li><p><strong>地址：</strong>你的博客地址</p>\n</li>\n<li><p><strong>简介：</strong>一句话简介</p>\n</li>\n<li><p><strong>头像：</strong>你的头像地址</p>\n</li>\n<li></li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言。</p>\n<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在评论区留言，留言格式：</p>\n<ul>\n<li><p><strong>名称：</strong>你的博客名称</p>\n</li>\n<li><p><strong>地址：</strong>你的博客地址</p>\n</li>\n<li><p><strong>简介：</strong>一句话简介</p>\n</li>\n<li><p><strong>头像：</strong>你的头像地址</p>\n</li>\n<li></li>\n</ul>\n"},{"title":"friends","date":"2021-03-07T07:53:10.000Z","type":"friends","layout":"friends","_content":"\n# 友链交换\n想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2021-03-07 15:53:10\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n","updated":"2021-03-07T07:53:11.911Z","path":"friends/index.html","comments":1,"_id":"ckm944w8g000ei4uff0yf4xvu","content":"<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-07-19 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2020-04-04T11:43:42.000Z","path":"tags/index.html","comments":1,"_id":"ckm944wdc0044i4uf1b1zou2x","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":""}],"Post":[{"title":"join优化","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-13T09:35:27.000Z","password":null,"summary":null,"_content":"\n## 关联查询\n\n### Nested-Loop Join\n\n思想：一次一行循环：从驱动表中读取行并取到关联字段，根据关联字段在被驱动表取出满足条件的行，然后取两张表的结果合集。[manual][https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html]\n\n在关联字段有索引时，才会使用 NLJ，如果没索引，就会使用 Block Nested-Loop Join。\n\n一般 join 语句中，没有出现Using join buffer就表示使用的join 算法是 NLJ\n\n### Block Nested-Loop Join \n\n思想：把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比，如果满足 join 条件，则返回结果给客户端。[manual][https://dev.mysql.com/doc/refman/5.7/en/bnl-bkaoptimization. html]\n\njoin_buffer减少了磁盘扫描次数。\n\n### Batched Key Access\n\n思想：结合NLJ和BNL，将驱动表中相关列放入 join_buffer 中，批量将关联字段的值发送到 Multi-Range Read(MRR) 接口，MRR 通过接收到的值，根据其对应的主键 ID 进行排序，然后再进行数据的读取和操作，返回结果给客户端。\n\n```mysql\nset optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';/*开启BKA*/\n```\n\nExtra显示Using join buffer (Batched Key Access)\n\n## 优化关联查询\n\n### 关联字段添加索引\n\n被驱动表的关联字段上添加索引，让 BNL变成 NLJ 或者 BKA ，可明显优化关联查询。\n\n### 小表做驱动表\n\n小表必定需要扫描，那么做举动表是小表更加合适。\n\n### 临时表\n\n因为某条关联查询只是临时查一次，如果再去添加索引可能会浪费资源。\n\n如果不方便在关联字段上添加索引，不妨尝试创建临时表，然后在临时表中的关联字段上添加索引，然后通过临时表来做关联查询。\n\n\n\n","source":"_posts/join优化.md","raw":"---\ntitle: join优化\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-13 17:35:27\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n## 关联查询\n\n### Nested-Loop Join\n\n思想：一次一行循环：从驱动表中读取行并取到关联字段，根据关联字段在被驱动表取出满足条件的行，然后取两张表的结果合集。[manual][https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html]\n\n在关联字段有索引时，才会使用 NLJ，如果没索引，就会使用 Block Nested-Loop Join。\n\n一般 join 语句中，没有出现Using join buffer就表示使用的join 算法是 NLJ\n\n### Block Nested-Loop Join \n\n思想：把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比，如果满足 join 条件，则返回结果给客户端。[manual][https://dev.mysql.com/doc/refman/5.7/en/bnl-bkaoptimization. html]\n\njoin_buffer减少了磁盘扫描次数。\n\n### Batched Key Access\n\n思想：结合NLJ和BNL，将驱动表中相关列放入 join_buffer 中，批量将关联字段的值发送到 Multi-Range Read(MRR) 接口，MRR 通过接收到的值，根据其对应的主键 ID 进行排序，然后再进行数据的读取和操作，返回结果给客户端。\n\n```mysql\nset optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';/*开启BKA*/\n```\n\nExtra显示Using join buffer (Batched Key Access)\n\n## 优化关联查询\n\n### 关联字段添加索引\n\n被驱动表的关联字段上添加索引，让 BNL变成 NLJ 或者 BKA ，可明显优化关联查询。\n\n### 小表做驱动表\n\n小表必定需要扫描，那么做举动表是小表更加合适。\n\n### 临时表\n\n因为某条关联查询只是临时查一次，如果再去添加索引可能会浪费资源。\n\n如果不方便在关联字段上添加索引，不妨尝试创建临时表，然后在临时表中的关联字段上添加索引，然后通过临时表来做关联查询。\n\n\n\n","slug":"join优化","published":1,"updated":"2021-03-13T10:27:06.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w7m0001i4uf9k2m31a1","content":"<h2 id=\"关联查询\"><a href=\"#关联查询\" class=\"headerlink\" title=\"关联查询\"></a>关联查询</h2><h3 id=\"Nested-Loop-Join\"><a href=\"#Nested-Loop-Join\" class=\"headerlink\" title=\"Nested-Loop Join\"></a>Nested-Loop Join</h3><p>思想：一次一行循环：从驱动表中读取行并取到关联字段，根据关联字段在被驱动表取出满足条件的行，然后取两张表的结果合集。[manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html]\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html]</a></p>\n<p>在关联字段有索引时，才会使用 NLJ，如果没索引，就会使用 Block Nested-Loop Join。</p>\n<p>一般 join 语句中，没有出现Using join buffer就表示使用的join 算法是 NLJ</p>\n<h3 id=\"Block-Nested-Loop-Join\"><a href=\"#Block-Nested-Loop-Join\" class=\"headerlink\" title=\"Block Nested-Loop Join\"></a>Block Nested-Loop Join</h3><p>思想：把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比，如果满足 join 条件，则返回结果给客户端。[manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/bnl-bkaoptimization\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/bnl-bkaoptimization</a>. html]</p>\n<p>join_buffer减少了磁盘扫描次数。</p>\n<h3 id=\"Batched-Key-Access\"><a href=\"#Batched-Key-Access\" class=\"headerlink\" title=\"Batched Key Access\"></a>Batched Key Access</h3><p>思想：结合NLJ和BNL，将驱动表中相关列放入 join_buffer 中，批量将关联字段的值发送到 Multi-Range Read(MRR) 接口，MRR 通过接收到的值，根据其对应的主键 ID 进行排序，然后再进行数据的读取和操作，返回结果给客户端。</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';/*开启BKA*/<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>Extra显示Using join buffer (Batched Key Access)</p>\n<h2 id=\"优化关联查询\"><a href=\"#优化关联查询\" class=\"headerlink\" title=\"优化关联查询\"></a>优化关联查询</h2><h3 id=\"关联字段添加索引\"><a href=\"#关联字段添加索引\" class=\"headerlink\" title=\"关联字段添加索引\"></a>关联字段添加索引</h3><p>被驱动表的关联字段上添加索引，让 BNL变成 NLJ 或者 BKA ，可明显优化关联查询。</p>\n<h3 id=\"小表做驱动表\"><a href=\"#小表做驱动表\" class=\"headerlink\" title=\"小表做驱动表\"></a>小表做驱动表</h3><p>小表必定需要扫描，那么做举动表是小表更加合适。</p>\n<h3 id=\"临时表\"><a href=\"#临时表\" class=\"headerlink\" title=\"临时表\"></a>临时表</h3><p>因为某条关联查询只是临时查一次，如果再去添加索引可能会浪费资源。</p>\n<p>如果不方便在关联字段上添加索引，不妨尝试创建临时表，然后在临时表中的关联字段上添加索引，然后通过临时表来做关联查询。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"关联查询\"><a href=\"#关联查询\" class=\"headerlink\" title=\"关联查询\"></a>关联查询</h2><h3 id=\"Nested-Loop-Join\"><a href=\"#Nested-Loop-Join\" class=\"headerlink\" title=\"Nested-Loop Join\"></a>Nested-Loop Join</h3><p>思想：一次一行循环：从驱动表中读取行并取到关联字段，根据关联字段在被驱动表取出满足条件的行，然后取两张表的结果合集。[manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html]\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html]</a></p>\n<p>在关联字段有索引时，才会使用 NLJ，如果没索引，就会使用 Block Nested-Loop Join。</p>\n<p>一般 join 语句中，没有出现Using join buffer就表示使用的join 算法是 NLJ</p>\n<h3 id=\"Block-Nested-Loop-Join\"><a href=\"#Block-Nested-Loop-Join\" class=\"headerlink\" title=\"Block Nested-Loop Join\"></a>Block Nested-Loop Join</h3><p>思想：把驱动表的数据读入到 join_buffer 中，然后扫描被驱动表，把被驱动表每一行取出来跟 join_buffer 中的数据做对比，如果满足 join 条件，则返回结果给客户端。[manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/bnl-bkaoptimization\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/bnl-bkaoptimization</a>. html]</p>\n<p>join_buffer减少了磁盘扫描次数。</p>\n<h3 id=\"Batched-Key-Access\"><a href=\"#Batched-Key-Access\" class=\"headerlink\" title=\"Batched Key Access\"></a>Batched Key Access</h3><p>思想：结合NLJ和BNL，将驱动表中相关列放入 join_buffer 中，批量将关联字段的值发送到 Multi-Range Read(MRR) 接口，MRR 通过接收到的值，根据其对应的主键 ID 进行排序，然后再进行数据的读取和操作，返回结果给客户端。</p>\n<pre><code class=\"mysql\">set optimizer_switch=&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;;/*开启BKA*/</code></pre>\n<p>Extra显示Using join buffer (Batched Key Access)</p>\n<h2 id=\"优化关联查询\"><a href=\"#优化关联查询\" class=\"headerlink\" title=\"优化关联查询\"></a>优化关联查询</h2><h3 id=\"关联字段添加索引\"><a href=\"#关联字段添加索引\" class=\"headerlink\" title=\"关联字段添加索引\"></a>关联字段添加索引</h3><p>被驱动表的关联字段上添加索引，让 BNL变成 NLJ 或者 BKA ，可明显优化关联查询。</p>\n<h3 id=\"小表做驱动表\"><a href=\"#小表做驱动表\" class=\"headerlink\" title=\"小表做驱动表\"></a>小表做驱动表</h3><p>小表必定需要扫描，那么做举动表是小表更加合适。</p>\n<h3 id=\"临时表\"><a href=\"#临时表\" class=\"headerlink\" title=\"临时表\"></a>临时表</h3><p>因为某条关联查询只是临时查一次，如果再去添加索引可能会浪费资源。</p>\n<p>如果不方便在关联字段上添加索引，不妨尝试创建临时表，然后在临时表中的关联字段上添加索引，然后通过临时表来做关联查询。</p>\n"},{"title":"count优化","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-13T10:30:14.000Z","password":null,"summary":null,"_content":"\n## count说明\n\n### count(a) 和 count(*)\n\n当 count() 统计某一列时，比如 count(a)，a 表示列名，是不统计 null 的。\n\n而 count(*) 无论是否包含空值，都会统计。\n\n### MyISAM 引擎和 InnoDB 引擎 count(*) 的区别\n\n对于 MyISAM 引擎，如果没有 where 子句，也没检索其它列，那么 count(*) 将会非常快。因为 MyISAM 引擎会把\n表的总行数存在磁盘上。\n\nInnoDB 并不会保留表中的行数，因为并发事务可能同时读取到不同的行数。所以执行 count(*) 时都是临时去\n计算的，会比 MyISAM 引擎慢很多。\n\n### MySQL 5.7.18 前后 count(*) 的区别\n\nMySQL 5.7.18 之前，InnoDB 通过扫描聚簇索引来处理 count(*) 语句。\n\nMySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 count(*) 语句。\n\n优化器基于成本的考虑，优先选择的是二级索引。所以 count(主键) 其实没 count (*)快。\n\n### count(1)   count(*)\n\n执行计划相同，速度没有明显差别\n\n## count 优化\n\n1、show table status,Rows 这列就表示这张表的行数。\n\n```mysql\nshow table status like 't1';\n```\n\n估算值，可能与实际值相差 40% 到 50%。\n\n2、用 Redis 做计数器\n\nredis 和数据库访问存在时间先后，可能会读到错误的值。\n\n3、增加计数表\n\n维持了计数的准确性\n\n","source":"_posts/count优化.md","raw":"---\ntitle: count优化\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-13 18:30:14\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n## count说明\n\n### count(a) 和 count(*)\n\n当 count() 统计某一列时，比如 count(a)，a 表示列名，是不统计 null 的。\n\n而 count(*) 无论是否包含空值，都会统计。\n\n### MyISAM 引擎和 InnoDB 引擎 count(*) 的区别\n\n对于 MyISAM 引擎，如果没有 where 子句，也没检索其它列，那么 count(*) 将会非常快。因为 MyISAM 引擎会把\n表的总行数存在磁盘上。\n\nInnoDB 并不会保留表中的行数，因为并发事务可能同时读取到不同的行数。所以执行 count(*) 时都是临时去\n计算的，会比 MyISAM 引擎慢很多。\n\n### MySQL 5.7.18 前后 count(*) 的区别\n\nMySQL 5.7.18 之前，InnoDB 通过扫描聚簇索引来处理 count(*) 语句。\n\nMySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 count(*) 语句。\n\n优化器基于成本的考虑，优先选择的是二级索引。所以 count(主键) 其实没 count (*)快。\n\n### count(1)   count(*)\n\n执行计划相同，速度没有明显差别\n\n## count 优化\n\n1、show table status,Rows 这列就表示这张表的行数。\n\n```mysql\nshow table status like 't1';\n```\n\n估算值，可能与实际值相差 40% 到 50%。\n\n2、用 Redis 做计数器\n\nredis 和数据库访问存在时间先后，可能会读到错误的值。\n\n3、增加计数表\n\n维持了计数的准确性\n\n","slug":"count优化","published":1,"updated":"2021-03-13T12:40:05.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w7v0003i4ufzgrzlyz6","content":"<h2 id=\"count说明\"><a href=\"#count说明\" class=\"headerlink\" title=\"count说明\"></a>count说明</h2><h3 id=\"count-a-和-count\"><a href=\"#count-a-和-count\" class=\"headerlink\" title=\"count(a) 和 count(*)\"></a>count(a) 和 count(*)</h3><p>当 count() 统计某一列时，比如 count(a)，a 表示列名，是不统计 null 的。</p>\n<p>而 count(*) 无论是否包含空值，都会统计。</p>\n<h3 id=\"MyISAM-引擎和-InnoDB-引擎-count-的区别\"><a href=\"#MyISAM-引擎和-InnoDB-引擎-count-的区别\" class=\"headerlink\" title=\"MyISAM 引擎和 InnoDB 引擎 count(*) 的区别\"></a>MyISAM 引擎和 InnoDB 引擎 count(*) 的区别</h3><p>对于 MyISAM 引擎，如果没有 where 子句，也没检索其它列，那么 count(*) 将会非常快。因为 MyISAM 引擎会把<br>表的总行数存在磁盘上。</p>\n<p>InnoDB 并不会保留表中的行数，因为并发事务可能同时读取到不同的行数。所以执行 count(*) 时都是临时去<br>计算的，会比 MyISAM 引擎慢很多。</p>\n<h3 id=\"MySQL-5-7-18-前后-count-的区别\"><a href=\"#MySQL-5-7-18-前后-count-的区别\" class=\"headerlink\" title=\"MySQL 5.7.18 前后 count(*) 的区别\"></a>MySQL 5.7.18 前后 count(*) 的区别</h3><p>MySQL 5.7.18 之前，InnoDB 通过扫描聚簇索引来处理 count(*) 语句。</p>\n<p>MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 count(*) 语句。</p>\n<p>优化器基于成本的考虑，优先选择的是二级索引。所以 count(主键) 其实没 count (*)快。</p>\n<h3 id=\"count-1-count\"><a href=\"#count-1-count\" class=\"headerlink\" title=\"count(1)   count(*)\"></a>count(1)   count(*)</h3><p>执行计划相同，速度没有明显差别</p>\n<h2 id=\"count-优化\"><a href=\"#count-优化\" class=\"headerlink\" title=\"count 优化\"></a>count 优化</h2><p>1、show table status,Rows 这列就表示这张表的行数。</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">show table status like 't1';<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>估算值，可能与实际值相差 40% 到 50%。</p>\n<p>2、用 Redis 做计数器</p>\n<p>redis 和数据库访问存在时间先后，可能会读到错误的值。</p>\n<p>3、增加计数表</p>\n<p>维持了计数的准确性</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"count说明\"><a href=\"#count说明\" class=\"headerlink\" title=\"count说明\"></a>count说明</h2><h3 id=\"count-a-和-count\"><a href=\"#count-a-和-count\" class=\"headerlink\" title=\"count(a) 和 count(*)\"></a>count(a) 和 count(*)</h3><p>当 count() 统计某一列时，比如 count(a)，a 表示列名，是不统计 null 的。</p>\n<p>而 count(*) 无论是否包含空值，都会统计。</p>\n<h3 id=\"MyISAM-引擎和-InnoDB-引擎-count-的区别\"><a href=\"#MyISAM-引擎和-InnoDB-引擎-count-的区别\" class=\"headerlink\" title=\"MyISAM 引擎和 InnoDB 引擎 count(*) 的区别\"></a>MyISAM 引擎和 InnoDB 引擎 count(*) 的区别</h3><p>对于 MyISAM 引擎，如果没有 where 子句，也没检索其它列，那么 count(*) 将会非常快。因为 MyISAM 引擎会把<br>表的总行数存在磁盘上。</p>\n<p>InnoDB 并不会保留表中的行数，因为并发事务可能同时读取到不同的行数。所以执行 count(*) 时都是临时去<br>计算的，会比 MyISAM 引擎慢很多。</p>\n<h3 id=\"MySQL-5-7-18-前后-count-的区别\"><a href=\"#MySQL-5-7-18-前后-count-的区别\" class=\"headerlink\" title=\"MySQL 5.7.18 前后 count(*) 的区别\"></a>MySQL 5.7.18 前后 count(*) 的区别</h3><p>MySQL 5.7.18 之前，InnoDB 通过扫描聚簇索引来处理 count(*) 语句。</p>\n<p>MySQL 5.7.18 开始，通过遍历最小的可用二级索引来处理 count(*) 语句。</p>\n<p>优化器基于成本的考虑，优先选择的是二级索引。所以 count(主键) 其实没 count (*)快。</p>\n<h3 id=\"count-1-count\"><a href=\"#count-1-count\" class=\"headerlink\" title=\"count(1)   count(*)\"></a>count(1)   count(*)</h3><p>执行计划相同，速度没有明显差别</p>\n<h2 id=\"count-优化\"><a href=\"#count-优化\" class=\"headerlink\" title=\"count 优化\"></a>count 优化</h2><p>1、show table status,Rows 这列就表示这张表的行数。</p>\n<pre><code class=\"mysql\">show table status like &#39;t1&#39;;</code></pre>\n<p>估算值，可能与实际值相差 40% 到 50%。</p>\n<p>2、用 Redis 做计数器</p>\n<p>redis 和数据库访问存在时间先后，可能会读到错误的值。</p>\n<p>3、增加计数表</p>\n<p>维持了计数的准确性</p>\n"},{"title":"kafka集群配置","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-12-10T13:12:03.000Z","password":null,"summary":null,"_content":"\n## Broker 端参数\n\n- log.dirs：Broker 需要使用的若干个文件目录路径，必须指定；最好不同路径挂载到不同的物理磁盘，提升读写性能且能能够实现故障转移\n- log.dir：单个路径\n\n- zookeeper.connect：zookeeper端口\n- listeners：访问kafka的监听器\n- advertised.listeners：Broker 用于对外发布的监听器\n- auto.create.topics.enable：是否允许自动创建 Topic，建议最好设置成 false\n- unclean.leader.election.enable：是否允许 Unclean Leader 选举，是否能让那些落后太多的副本竞选 Leader,建议false\n- auto.leader.rebalance.enable：是否允许定期进行 Leader 选举，成本太高，建议false\n- log.retention.{hours|minutes|ms}：控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低\n- log.retention.bytes：这是指定 Broker 为消息保存的总磁盘容量大小。默认-1\n- message.max.bytes：控制 Broker 能够接收的最大消息大小。\n\n## Topic 级别参数\n\n- retention.ms： Topic 消息被保存的时长。默认是 7 天。会覆盖掉 Broker 端的全局参数值。\n\n- retention.bytes： Topic 预留多大的磁盘空间。通常在多租户的 Kafka 集群中会有用武之地。默认值是 -1，表示可以无限使用磁盘空间。\n- max.message.bytes：Broker 能够正常接收该 Topic 的最大消息大小\n\n创建topic时设置:\n\n```\n\nbin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic transaction --partitions 1 --replication-factor 1 --config retention.ms=15552000000 --config max.message.bytes=5242880\n```\n\n修改topic(推荐)：\n\n```\n\nbin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name transaction --alter --add-config max.message.bytes=10485760\n```\n\n## JVM参数\n\n JVM 堆大小设置成 6GB ，用默认的 G1 收集器\n\n- KAFKA_HEAP_OPTS：指定堆大小。\n- KAFKA_JVM_PERFORMANCE_OPTS：指定 GC 参数。\n\n启动broker前设置：\n\n```\n$> export KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g\n$> export KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=true\n$> bin/kafka-server-start.sh config/server.properties\n```\n\n## 操作系统参数\n\n文件描述符限制：`ulimit -n 1000000`，通常将它设置成一个超大的值\n\n文件系统类型：最好选择xfs\n\nSwap：设置成一个比较小的值，当开始使用 swap 空间时，能够观测到 Broker 性能开始出现急剧下降，避免直接OOM，从而给你进一步调优和诊断问题的时间。\n\n提交时间（Flush 落盘时间）：适当地增加提交间隔来降低物理磁盘的写操作","source":"_posts/kafka集群配置.md","raw":"---\ntitle: kafka集群配置\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-12-10 21:12:03\npassword:\nsummary:\ntags:\n- kafka\ncategories:\n- kafka\n---\n\n## Broker 端参数\n\n- log.dirs：Broker 需要使用的若干个文件目录路径，必须指定；最好不同路径挂载到不同的物理磁盘，提升读写性能且能能够实现故障转移\n- log.dir：单个路径\n\n- zookeeper.connect：zookeeper端口\n- listeners：访问kafka的监听器\n- advertised.listeners：Broker 用于对外发布的监听器\n- auto.create.topics.enable：是否允许自动创建 Topic，建议最好设置成 false\n- unclean.leader.election.enable：是否允许 Unclean Leader 选举，是否能让那些落后太多的副本竞选 Leader,建议false\n- auto.leader.rebalance.enable：是否允许定期进行 Leader 选举，成本太高，建议false\n- log.retention.{hours|minutes|ms}：控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低\n- log.retention.bytes：这是指定 Broker 为消息保存的总磁盘容量大小。默认-1\n- message.max.bytes：控制 Broker 能够接收的最大消息大小。\n\n## Topic 级别参数\n\n- retention.ms： Topic 消息被保存的时长。默认是 7 天。会覆盖掉 Broker 端的全局参数值。\n\n- retention.bytes： Topic 预留多大的磁盘空间。通常在多租户的 Kafka 集群中会有用武之地。默认值是 -1，表示可以无限使用磁盘空间。\n- max.message.bytes：Broker 能够正常接收该 Topic 的最大消息大小\n\n创建topic时设置:\n\n```\n\nbin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic transaction --partitions 1 --replication-factor 1 --config retention.ms=15552000000 --config max.message.bytes=5242880\n```\n\n修改topic(推荐)：\n\n```\n\nbin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name transaction --alter --add-config max.message.bytes=10485760\n```\n\n## JVM参数\n\n JVM 堆大小设置成 6GB ，用默认的 G1 收集器\n\n- KAFKA_HEAP_OPTS：指定堆大小。\n- KAFKA_JVM_PERFORMANCE_OPTS：指定 GC 参数。\n\n启动broker前设置：\n\n```\n$> export KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g\n$> export KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=true\n$> bin/kafka-server-start.sh config/server.properties\n```\n\n## 操作系统参数\n\n文件描述符限制：`ulimit -n 1000000`，通常将它设置成一个超大的值\n\n文件系统类型：最好选择xfs\n\nSwap：设置成一个比较小的值，当开始使用 swap 空间时，能够观测到 Broker 性能开始出现急剧下降，避免直接OOM，从而给你进一步调优和诊断问题的时间。\n\n提交时间（Flush 落盘时间）：适当地增加提交间隔来降低物理磁盘的写操作","slug":"kafka集群配置","published":1,"updated":"2020-12-10T13:44:49.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w820007i4ufv40vrvbi","content":"<h2 id=\"Broker-端参数\"><a href=\"#Broker-端参数\" class=\"headerlink\" title=\"Broker 端参数\"></a>Broker 端参数</h2><ul>\n<li><p>log.dirs：Broker 需要使用的若干个文件目录路径，必须指定；最好不同路径挂载到不同的物理磁盘，提升读写性能且能能够实现故障转移</p>\n</li>\n<li><p>log.dir：单个路径</p>\n</li>\n<li><p>zookeeper.connect：zookeeper端口</p>\n</li>\n<li><p>listeners：访问kafka的监听器</p>\n</li>\n<li><p>advertised.listeners：Broker 用于对外发布的监听器</p>\n</li>\n<li><p>auto.create.topics.enable：是否允许自动创建 Topic，建议最好设置成 false</p>\n</li>\n<li><p>unclean.leader.election.enable：是否允许 Unclean Leader 选举，是否能让那些落后太多的副本竞选 Leader,建议false</p>\n</li>\n<li><p>auto.leader.rebalance.enable：是否允许定期进行 Leader 选举，成本太高，建议false</p>\n</li>\n<li><p>log.retention.{hours|minutes|ms}：控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低</p>\n</li>\n<li><p>log.retention.bytes：这是指定 Broker 为消息保存的总磁盘容量大小。默认-1</p>\n</li>\n<li><p>message.max.bytes：控制 Broker 能够接收的最大消息大小。</p>\n</li>\n</ul>\n<h2 id=\"Topic-级别参数\"><a href=\"#Topic-级别参数\" class=\"headerlink\" title=\"Topic 级别参数\"></a>Topic 级别参数</h2><ul>\n<li><p>retention.ms： Topic 消息被保存的时长。默认是 7 天。会覆盖掉 Broker 端的全局参数值。</p>\n</li>\n<li><p>retention.bytes： Topic 预留多大的磁盘空间。通常在多租户的 Kafka 集群中会有用武之地。默认值是 -1，表示可以无限使用磁盘空间。</p>\n</li>\n<li><p>max.message.bytes：Broker 能够正常接收该 Topic 的最大消息大小</p>\n</li>\n</ul>\n<p>创建topic时设置:</p>\n<pre><code>\nbin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic transaction --partitions 1 --replication-factor 1 --config retention.ms=15552000000 --config max.message.bytes=5242880</code></pre><p>修改topic(推荐)：</p>\n<pre><code>\nbin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name transaction --alter --add-config max.message.bytes=10485760</code></pre><h2 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h2><p> JVM 堆大小设置成 6GB ，用默认的 G1 收集器</p>\n<ul>\n<li>KAFKA_HEAP_OPTS：指定堆大小。</li>\n<li>KAFKA_JVM_PERFORMANCE_OPTS：指定 GC 参数。</li>\n</ul>\n<p>启动broker前设置：</p>\n<pre><code>$&gt; export KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g\n$&gt; export KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=true\n$&gt; bin/kafka-server-start.sh config/server.properties</code></pre><h2 id=\"操作系统参数\"><a href=\"#操作系统参数\" class=\"headerlink\" title=\"操作系统参数\"></a>操作系统参数</h2><p>文件描述符限制：<code>ulimit -n 1000000</code>，通常将它设置成一个超大的值</p>\n<p>文件系统类型：最好选择xfs</p>\n<p>Swap：设置成一个比较小的值，当开始使用 swap 空间时，能够观测到 Broker 性能开始出现急剧下降，避免直接OOM，从而给你进一步调优和诊断问题的时间。</p>\n<p>提交时间（Flush 落盘时间）：适当地增加提交间隔来降低物理磁盘的写操作</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"Broker-端参数\"><a href=\"#Broker-端参数\" class=\"headerlink\" title=\"Broker 端参数\"></a>Broker 端参数</h2><ul>\n<li><p>log.dirs：Broker 需要使用的若干个文件目录路径，必须指定；最好不同路径挂载到不同的物理磁盘，提升读写性能且能能够实现故障转移</p>\n</li>\n<li><p>log.dir：单个路径</p>\n</li>\n<li><p>zookeeper.connect：zookeeper端口</p>\n</li>\n<li><p>listeners：访问kafka的监听器</p>\n</li>\n<li><p>advertised.listeners：Broker 用于对外发布的监听器</p>\n</li>\n<li><p>auto.create.topics.enable：是否允许自动创建 Topic，建议最好设置成 false</p>\n</li>\n<li><p>unclean.leader.election.enable：是否允许 Unclean Leader 选举，是否能让那些落后太多的副本竞选 Leader,建议false</p>\n</li>\n<li><p>auto.leader.rebalance.enable：是否允许定期进行 Leader 选举，成本太高，建议false</p>\n</li>\n<li><p>log.retention.{hours|minutes|ms}：控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hours 最低</p>\n</li>\n<li><p>log.retention.bytes：这是指定 Broker 为消息保存的总磁盘容量大小。默认-1</p>\n</li>\n<li><p>message.max.bytes：控制 Broker 能够接收的最大消息大小。</p>\n</li>\n</ul>\n<h2 id=\"Topic-级别参数\"><a href=\"#Topic-级别参数\" class=\"headerlink\" title=\"Topic 级别参数\"></a>Topic 级别参数</h2><ul>\n<li><p>retention.ms： Topic 消息被保存的时长。默认是 7 天。会覆盖掉 Broker 端的全局参数值。</p>\n</li>\n<li><p>retention.bytes： Topic 预留多大的磁盘空间。通常在多租户的 Kafka 集群中会有用武之地。默认值是 -1，表示可以无限使用磁盘空间。</p>\n</li>\n<li><p>max.message.bytes：Broker 能够正常接收该 Topic 的最大消息大小</p>\n</li>\n</ul>\n<p>创建topic时设置:</p>\n<pre><code>\nbin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic transaction --partitions 1 --replication-factor 1 --config retention.ms=15552000000 --config max.message.bytes=5242880</code></pre><p>修改topic(推荐)：</p>\n<pre><code>\nbin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name transaction --alter --add-config max.message.bytes=10485760</code></pre><h2 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h2><p> JVM 堆大小设置成 6GB ，用默认的 G1 收集器</p>\n<ul>\n<li>KAFKA_HEAP_OPTS：指定堆大小。</li>\n<li>KAFKA_JVM_PERFORMANCE_OPTS：指定 GC 参数。</li>\n</ul>\n<p>启动broker前设置：</p>\n<pre><code>$&gt; export KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g\n$&gt; export KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=true\n$&gt; bin/kafka-server-start.sh config/server.properties</code></pre><h2 id=\"操作系统参数\"><a href=\"#操作系统参数\" class=\"headerlink\" title=\"操作系统参数\"></a>操作系统参数</h2><p>文件描述符限制：<code>ulimit -n 1000000</code>，通常将它设置成一个超大的值</p>\n<p>文件系统类型：最好选择xfs</p>\n<p>Swap：设置成一个比较小的值，当开始使用 swap 空间时，能够观测到 Broker 性能开始出现急剧下降，避免直接OOM，从而给你进一步调优和诊断问题的时间。</p>\n<p>提交时间（Flush 落盘时间）：适当地增加提交间隔来降低物理磁盘的写操作</p>\n"},{"title":"order/group by优化","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-13T07:45:38.000Z","password":null,"summary":null,"_content":"\n## order by 原理\n\n按照排序原理分[manual][https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html]，MySQL 排序方式分两种：\n\n- 通过有序索引直接返回有序数据：Using index\n- 通过 Filesort 进行的排序：Using filesort\n\nFilesort是内存排序还是磁盘排序取决于排序的数据大小和 sort_buffer_size 配置的大小：\n\n- 如果 “排序的数据大小” < sort_buffer_size: 内存排序\n- 如果 “排序的数据大小” > sort_buffer_size: 磁盘排序\n\n通过trace中的number_of_tmp_files，等于 0，则表示排序过程没使用临时文件，在内存中就能完成排序。\n\n**Filesort 下的排序模式**\n\n- < sort_key, rowid >双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定\n  位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；\n- < sort_key, additional_fields >单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；\n- < sort_key, packed_additional_fields >打包数据排序模式：与单路排序相似，区别是将 char 和 varchar 字段存到\n  sort buffer 中时，更加紧缩。\n\n单路和双路的选择：\n\n- 如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 < sort_key, additional_fields >排序模式；\n- 如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 <sort_key, rowid> 排序模式。\n\n如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器优先选择\n全字段排序，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。\n\n## order by 优化\n\n###  添加合适索引\n\n1、 排序字段添加索引\n\n2、多个字段排序添加联合索引\n\n3、先等值查询再排序，在条件字段和排序字段添加联合索引\n\n### 去掉不必要的返回字段\n\n过多返回字段可能需要扫描索引再回表，成本全表扫描更高。\n\n```mysql\nselect id,a,b from t1 order by a,b; /* 根据a和b字段排序查出id,a,b字段的值 */\n```\n\n### 修改参数\n\nmax_length_for_sort_data：如果觉得排序效率比较低，可以适当加大 max_length_for_sort_data 的值\n\nsort_buffer_size：适当加大 sort_buffer_size 的值，尽可能让排序在内存中完成。\n\n### 无法使用索引\n\n1、 使用范围查询再排序：\n\n```mysql\nselect id,a,b from t1 where a>9000 order by b;\n```\n\n2、ASC 和 DESC 混合使用\n\n```mysql\nselect id,a,b from t1 order by a asc,b desc;\n```\n\n## group by优化\n\n默认情况，会对 group by 字段排序，因此优化方式与 order by 基本一致，如果目的只是分组而不用排序，可以指定 order by null 禁止排序。\n\n","source":"_posts/order-group-by优化.md","raw":"---\ntitle: order/group by优化\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-13 15:45:38\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n## order by 原理\n\n按照排序原理分[manual][https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html]，MySQL 排序方式分两种：\n\n- 通过有序索引直接返回有序数据：Using index\n- 通过 Filesort 进行的排序：Using filesort\n\nFilesort是内存排序还是磁盘排序取决于排序的数据大小和 sort_buffer_size 配置的大小：\n\n- 如果 “排序的数据大小” < sort_buffer_size: 内存排序\n- 如果 “排序的数据大小” > sort_buffer_size: 磁盘排序\n\n通过trace中的number_of_tmp_files，等于 0，则表示排序过程没使用临时文件，在内存中就能完成排序。\n\n**Filesort 下的排序模式**\n\n- < sort_key, rowid >双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定\n  位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；\n- < sort_key, additional_fields >单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；\n- < sort_key, packed_additional_fields >打包数据排序模式：与单路排序相似，区别是将 char 和 varchar 字段存到\n  sort buffer 中时，更加紧缩。\n\n单路和双路的选择：\n\n- 如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 < sort_key, additional_fields >排序模式；\n- 如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 <sort_key, rowid> 排序模式。\n\n如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器优先选择\n全字段排序，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。\n\n## order by 优化\n\n###  添加合适索引\n\n1、 排序字段添加索引\n\n2、多个字段排序添加联合索引\n\n3、先等值查询再排序，在条件字段和排序字段添加联合索引\n\n### 去掉不必要的返回字段\n\n过多返回字段可能需要扫描索引再回表，成本全表扫描更高。\n\n```mysql\nselect id,a,b from t1 order by a,b; /* 根据a和b字段排序查出id,a,b字段的值 */\n```\n\n### 修改参数\n\nmax_length_for_sort_data：如果觉得排序效率比较低，可以适当加大 max_length_for_sort_data 的值\n\nsort_buffer_size：适当加大 sort_buffer_size 的值，尽可能让排序在内存中完成。\n\n### 无法使用索引\n\n1、 使用范围查询再排序：\n\n```mysql\nselect id,a,b from t1 where a>9000 order by b;\n```\n\n2、ASC 和 DESC 混合使用\n\n```mysql\nselect id,a,b from t1 order by a asc,b desc;\n```\n\n## group by优化\n\n默认情况，会对 group by 字段排序，因此优化方式与 order by 基本一致，如果目的只是分组而不用排序，可以指定 order by null 禁止排序。\n\n","slug":"order-group-by优化","published":1,"updated":"2021-03-13T09:14:39.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w850009i4ufjhk4291t","content":"<h2 id=\"order-by-原理\"><a href=\"#order-by-原理\" class=\"headerlink\" title=\"order by 原理\"></a>order by 原理</h2><p>按照排序原理分[manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html]，MySQL\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html]，MySQL</a> 排序方式分两种：</p>\n<ul>\n<li>通过有序索引直接返回有序数据：Using index</li>\n<li>通过 Filesort 进行的排序：Using filesort</li>\n</ul>\n<p>Filesort是内存排序还是磁盘排序取决于排序的数据大小和 sort_buffer_size 配置的大小：</p>\n<ul>\n<li>如果 “排序的数据大小” &lt; sort_buffer_size: 内存排序</li>\n<li>如果 “排序的数据大小” &gt; sort_buffer_size: 磁盘排序</li>\n</ul>\n<p>通过trace中的number_of_tmp_files，等于 0，则表示排序过程没使用临时文件，在内存中就能完成排序。</p>\n<p><strong>Filesort 下的排序模式</strong></p>\n<ul>\n<li>&lt; sort_key, rowid &gt;双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定<br>位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li>\n<li>&lt; sort_key, additional_fields &gt;单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li>\n<li>&lt; sort_key, packed_additional_fields &gt;打包数据排序模式：与单路排序相似，区别是将 char 和 varchar 字段存到<br>sort buffer 中时，更加紧缩。</li>\n</ul>\n<p>单路和双路的选择：</p>\n<ul>\n<li>如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 &lt; sort_key, additional_fields &gt;排序模式；</li>\n<li>如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 &lt;sort_key, rowid&gt; 排序模式。</li>\n</ul>\n<p>如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器优先选择<br>全字段排序，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。</p>\n<h2 id=\"order-by-优化\"><a href=\"#order-by-优化\" class=\"headerlink\" title=\"order by 优化\"></a>order by 优化</h2><h3 id=\"添加合适索引\"><a href=\"#添加合适索引\" class=\"headerlink\" title=\"添加合适索引\"></a>添加合适索引</h3><p>1、 排序字段添加索引</p>\n<p>2、多个字段排序添加联合索引</p>\n<p>3、先等值查询再排序，在条件字段和排序字段添加联合索引</p>\n<h3 id=\"去掉不必要的返回字段\"><a href=\"#去掉不必要的返回字段\" class=\"headerlink\" title=\"去掉不必要的返回字段\"></a>去掉不必要的返回字段</h3><p>过多返回字段可能需要扫描索引再回表，成本全表扫描更高。</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select id,a,b from t1 order by a,b; /* 根据a和b字段排序查出id,a,b字段的值 */<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"修改参数\"><a href=\"#修改参数\" class=\"headerlink\" title=\"修改参数\"></a>修改参数</h3><p>max_length_for_sort_data：如果觉得排序效率比较低，可以适当加大 max_length_for_sort_data 的值</p>\n<p>sort_buffer_size：适当加大 sort_buffer_size 的值，尽可能让排序在内存中完成。</p>\n<h3 id=\"无法使用索引\"><a href=\"#无法使用索引\" class=\"headerlink\" title=\"无法使用索引\"></a>无法使用索引</h3><p>1、 使用范围查询再排序：</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select id,a,b from t1 where a>9000 order by b;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>2、ASC 和 DESC 混合使用</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select id,a,b from t1 order by a asc,b desc;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"group-by优化\"><a href=\"#group-by优化\" class=\"headerlink\" title=\"group by优化\"></a>group by优化</h2><p>默认情况，会对 group by 字段排序，因此优化方式与 order by 基本一致，如果目的只是分组而不用排序，可以指定 order by null 禁止排序。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"order-by-原理\"><a href=\"#order-by-原理\" class=\"headerlink\" title=\"order by 原理\"></a>order by 原理</h2><p>按照排序原理分[manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html]，MySQL\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html]，MySQL</a> 排序方式分两种：</p>\n<ul>\n<li>通过有序索引直接返回有序数据：Using index</li>\n<li>通过 Filesort 进行的排序：Using filesort</li>\n</ul>\n<p>Filesort是内存排序还是磁盘排序取决于排序的数据大小和 sort_buffer_size 配置的大小：</p>\n<ul>\n<li>如果 “排序的数据大小” &lt; sort_buffer_size: 内存排序</li>\n<li>如果 “排序的数据大小” &gt; sort_buffer_size: 磁盘排序</li>\n</ul>\n<p>通过trace中的number_of_tmp_files，等于 0，则表示排序过程没使用临时文件，在内存中就能完成排序。</p>\n<p><strong>Filesort 下的排序模式</strong></p>\n<ul>\n<li>&lt; sort_key, rowid &gt;双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定<br>位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；</li>\n<li>&lt; sort_key, additional_fields &gt;单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；</li>\n<li>&lt; sort_key, packed_additional_fields &gt;打包数据排序模式：与单路排序相似，区别是将 char 和 varchar 字段存到<br>sort buffer 中时，更加紧缩。</li>\n</ul>\n<p>单路和双路的选择：</p>\n<ul>\n<li>如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 &lt; sort_key, additional_fields &gt;排序模式；</li>\n<li>如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 &lt;sort_key, rowid&gt; 排序模式。</li>\n</ul>\n<p>如果 MySQL 排序内存有条件可以配置比较大，可以适当增大 max_length_for_sort_data 的值，让优化器优先选择<br>全字段排序，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。</p>\n<h2 id=\"order-by-优化\"><a href=\"#order-by-优化\" class=\"headerlink\" title=\"order by 优化\"></a>order by 优化</h2><h3 id=\"添加合适索引\"><a href=\"#添加合适索引\" class=\"headerlink\" title=\"添加合适索引\"></a>添加合适索引</h3><p>1、 排序字段添加索引</p>\n<p>2、多个字段排序添加联合索引</p>\n<p>3、先等值查询再排序，在条件字段和排序字段添加联合索引</p>\n<h3 id=\"去掉不必要的返回字段\"><a href=\"#去掉不必要的返回字段\" class=\"headerlink\" title=\"去掉不必要的返回字段\"></a>去掉不必要的返回字段</h3><p>过多返回字段可能需要扫描索引再回表，成本全表扫描更高。</p>\n<pre><code class=\"mysql\">select id,a,b from t1 order by a,b; /* 根据a和b字段排序查出id,a,b字段的值 */</code></pre>\n<h3 id=\"修改参数\"><a href=\"#修改参数\" class=\"headerlink\" title=\"修改参数\"></a>修改参数</h3><p>max_length_for_sort_data：如果觉得排序效率比较低，可以适当加大 max_length_for_sort_data 的值</p>\n<p>sort_buffer_size：适当加大 sort_buffer_size 的值，尽可能让排序在内存中完成。</p>\n<h3 id=\"无法使用索引\"><a href=\"#无法使用索引\" class=\"headerlink\" title=\"无法使用索引\"></a>无法使用索引</h3><p>1、 使用范围查询再排序：</p>\n<pre><code class=\"mysql\">select id,a,b from t1 where a&gt;9000 order by b;</code></pre>\n<p>2、ASC 和 DESC 混合使用</p>\n<pre><code class=\"mysql\">select id,a,b from t1 order by a asc,b desc;</code></pre>\n<h2 id=\"group-by优化\"><a href=\"#group-by优化\" class=\"headerlink\" title=\"group by优化\"></a>group by优化</h2><p>默认情况，会对 group by 字段排序，因此优化方式与 order by 基本一致，如果目的只是分组而不用排序，可以指定 order by null 禁止排序。</p>\n"},{"title":"rabbitmq消息发布","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T14:13:06.000Z","password":null,"summary":null,"_content":"\n## 可靠投递\n\n------------\n\n### mandatory\n\n当交换器无法路由消息，RabbitMQ将回发Basic.Return消息到发布者，同时回发完整消息。\nBasic.Return是异步的，在消息发布后的任何时候都可能发生。\n在rabbitpy库中，客户端自动接收Basic.Return，并触发异常\n\n示例程序：发布失败\n```python\nimport datetime\nimport rabbitpy\n\n# Connect to the default URL of amqp://guest:guest@localhost:15672/%2F\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        # Create the message to send\n        body = 'server.cpu.utilization 25.5 1350884514'\n        message = rabbitpy.Message(channel,\n                                   body,\n                                   {'content_type': 'text/plain',\n                                    'timestamp': datetime.datetime.now(),\n                                    'message_type': 'graphite metric'})\n\n        # Publish the message to the exchange with the routing key\n        # \"server-metrics\" and make sure it is routed to the exchange\n        message.publish('chapter2-example', 'server-metrics', mandatory=True)\n```\n\n示例程序：异常捕获\n```python\nimport datetime\nimport rabbitpy\n\n# Connect to the default URL of amqp://guest:guest@localhost:15672/%2F\nconnection = rabbitpy.Connection()\ntry:\n    with connection.channel() as channel:\n        properties = {'content_type': 'text/plain',\n                      'timestamp': datetime.datetime.now(),\n                      'message_type': 'graphite metric'}\n        body = 'server.cpu.utilization 25.5 1350884514'\n        message = rabbitpy.Message(channel, body, properties)\n        message.publish('chapter2-example',\n                        'server-metrics',\n                        mandatory=True)\nexcept rabbitpy.exceptions.MessageReturnedException as error:\n    print('Publish failure: %s' % error)\n```\n\n### 发布者确认\n\n发布者发送给RabbitMQ的每条消息，服务器发送一个确认(Basic.Ack)或者否认相应（Basic.Nack）。\n\n示例程序：发布者确认\n```python\nimport rabbitpy\n\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, 'chapter4-example')\n        exchange.declare()\n        channel.enable_publisher_confirms()\n        message = rabbitpy.Message(channel,\n                                   'This is an important message',\n                                   {'content_type': 'text/plain',\n                                    'message_type': 'very important'})\n        if message.publish('chapter4-example', 'important.message'):\n            print('The message was confirmed')\n```\n\nrabbitpy中没有使用回调的方法，而是在确认收到之前会一直阻塞。\n\n### 备用交换器\n\n处理无法路由的消息。当不可路由的消息发布到已经定义了备用交换器的交换器中时，它将被路由到备用交换器。\n\n\n示例程序：备用交换器\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        my_ae = rabbitpy.Exchange(channel, 'my-ae',\n                                  exchange_type='fanout')\n        my_ae.declare()\n        args = {'alternate-exchange': my_ae.name}\n        exchange = rabbitpy.Exchange(channel,\n                                     'graphite',\n                                     exchange_type='topic',\n                                     arguments=args)\n        exchange.declare()\n        queue = rabbitpy.Queue(channel, 'unroutable-messages')\n        queue.declare()\n        if queue.bind(my_ae, '#'):\n            print('Queue bound to alternate-exchange')\n```\n\n### 基于事务的批量处理\n\n确保消息投递成功。\n\n\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        tx = rabbitpy.Tx(channel)\n        tx.select()\n        message = rabbitpy.Message(channel,\n                                   'This is an important message',\n                                   {'content_type': 'text/plain',\n                                    'delivery_mode': 2,\n                                    'message_type': 'important'})\n        message.publish('chapter4-example', 'important.message')\n        try:\n            if tx.commit():\n                print('Transaction committed')\n        except rabbitpy.exceptions.NoActiveTransactionError:\n            print('Tried to commit without active transaction')\n```\n\n由于错误无法路由消息时，将及时返回Basic.Return。发布者应发送TX.RollbackRPC请求并等待来自代理服务器的TX.Rollback相应，然后继续后续的工作。\n\n### HA队列\n\n允许队列在多个服务器拥有冗余副本。\n发布者发送消息到集群中的任何节点。RabbitMQ节点同步队列中消息的状态。发布的消息被放入队列，并存储在每台服务器上。\n\n示例代码：HA队列声明\n```python\nimport rabbitpy\n\nconnection = rabbitpy.Connection()\ntry:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel,\n                               'my-ha-queue',\n                               arguments={'x-ha-policy': 'all'})\n        if queue.declare():\n            print('Queue declared')\nexcept rabbitpy.exceptions.RemoteClosedChannelException as error:\n    print('Queue declare failed: %s' % error)\n```\n\n\n示例代码：HA队列指定节点\n```python\nimport rabbitpy\n\nconnection = rabbitpy.Connection()\ntry:\n    with connection.channel() as channel:\n        arguments = {'x-ha-policy': 'nodes',\n                     'x-ha-nodes': ['rabbit@node1',\n                                    'rabbit@node2',\n                                    'rabbit@node3']}\n        queue = rabbitpy.Queue(channel,\n                               'my-2nd-ha-queue',\n                               arguments=arguments)\n        if queue.declare():\n            print('Queue declared')\nexcept rabbitpy.exceptions.RemoteClosedChannelException as error:\n    print('Queue declare failed: %s' % error)\n```\n\n### 消息持久化\n\ndelivery-mode=1，保存到内存；delivery-mode=2，保存到磁盘。服务器重启后，消息仍在队列中（队列必须声明为durable）。\n\n如果rabbitmq经常等待操作系统响应读写请求，消息吞吐量将大大降低。\n\n\n## rabbitmq回推\n\n发布者发布消息太快，RabbitMQ发送Channel.Flow RPC方法，阻塞发布者。发布者不能发送消息直到收到另一条Channel.Flow命令。\n\n示例代码：检测连接状态\n```python\nimport rabbitpy\n\nconnection = rabbitpy.Connection()\nprint('Channel is Blocked? %s' % connection.blocked)\n\n```","source":"_posts/rabbitmq消息发布.md","raw":"---\ntitle: rabbitmq消息发布\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 22:13:06\npassword:\nsummary:\ntags:\n- rabbitmq\ncategories:\n- rabbitmq\n---\n\n## 可靠投递\n\n------------\n\n### mandatory\n\n当交换器无法路由消息，RabbitMQ将回发Basic.Return消息到发布者，同时回发完整消息。\nBasic.Return是异步的，在消息发布后的任何时候都可能发生。\n在rabbitpy库中，客户端自动接收Basic.Return，并触发异常\n\n示例程序：发布失败\n```python\nimport datetime\nimport rabbitpy\n\n# Connect to the default URL of amqp://guest:guest@localhost:15672/%2F\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        # Create the message to send\n        body = 'server.cpu.utilization 25.5 1350884514'\n        message = rabbitpy.Message(channel,\n                                   body,\n                                   {'content_type': 'text/plain',\n                                    'timestamp': datetime.datetime.now(),\n                                    'message_type': 'graphite metric'})\n\n        # Publish the message to the exchange with the routing key\n        # \"server-metrics\" and make sure it is routed to the exchange\n        message.publish('chapter2-example', 'server-metrics', mandatory=True)\n```\n\n示例程序：异常捕获\n```python\nimport datetime\nimport rabbitpy\n\n# Connect to the default URL of amqp://guest:guest@localhost:15672/%2F\nconnection = rabbitpy.Connection()\ntry:\n    with connection.channel() as channel:\n        properties = {'content_type': 'text/plain',\n                      'timestamp': datetime.datetime.now(),\n                      'message_type': 'graphite metric'}\n        body = 'server.cpu.utilization 25.5 1350884514'\n        message = rabbitpy.Message(channel, body, properties)\n        message.publish('chapter2-example',\n                        'server-metrics',\n                        mandatory=True)\nexcept rabbitpy.exceptions.MessageReturnedException as error:\n    print('Publish failure: %s' % error)\n```\n\n### 发布者确认\n\n发布者发送给RabbitMQ的每条消息，服务器发送一个确认(Basic.Ack)或者否认相应（Basic.Nack）。\n\n示例程序：发布者确认\n```python\nimport rabbitpy\n\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, 'chapter4-example')\n        exchange.declare()\n        channel.enable_publisher_confirms()\n        message = rabbitpy.Message(channel,\n                                   'This is an important message',\n                                   {'content_type': 'text/plain',\n                                    'message_type': 'very important'})\n        if message.publish('chapter4-example', 'important.message'):\n            print('The message was confirmed')\n```\n\nrabbitpy中没有使用回调的方法，而是在确认收到之前会一直阻塞。\n\n### 备用交换器\n\n处理无法路由的消息。当不可路由的消息发布到已经定义了备用交换器的交换器中时，它将被路由到备用交换器。\n\n\n示例程序：备用交换器\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        my_ae = rabbitpy.Exchange(channel, 'my-ae',\n                                  exchange_type='fanout')\n        my_ae.declare()\n        args = {'alternate-exchange': my_ae.name}\n        exchange = rabbitpy.Exchange(channel,\n                                     'graphite',\n                                     exchange_type='topic',\n                                     arguments=args)\n        exchange.declare()\n        queue = rabbitpy.Queue(channel, 'unroutable-messages')\n        queue.declare()\n        if queue.bind(my_ae, '#'):\n            print('Queue bound to alternate-exchange')\n```\n\n### 基于事务的批量处理\n\n确保消息投递成功。\n\n\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        tx = rabbitpy.Tx(channel)\n        tx.select()\n        message = rabbitpy.Message(channel,\n                                   'This is an important message',\n                                   {'content_type': 'text/plain',\n                                    'delivery_mode': 2,\n                                    'message_type': 'important'})\n        message.publish('chapter4-example', 'important.message')\n        try:\n            if tx.commit():\n                print('Transaction committed')\n        except rabbitpy.exceptions.NoActiveTransactionError:\n            print('Tried to commit without active transaction')\n```\n\n由于错误无法路由消息时，将及时返回Basic.Return。发布者应发送TX.RollbackRPC请求并等待来自代理服务器的TX.Rollback相应，然后继续后续的工作。\n\n### HA队列\n\n允许队列在多个服务器拥有冗余副本。\n发布者发送消息到集群中的任何节点。RabbitMQ节点同步队列中消息的状态。发布的消息被放入队列，并存储在每台服务器上。\n\n示例代码：HA队列声明\n```python\nimport rabbitpy\n\nconnection = rabbitpy.Connection()\ntry:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel,\n                               'my-ha-queue',\n                               arguments={'x-ha-policy': 'all'})\n        if queue.declare():\n            print('Queue declared')\nexcept rabbitpy.exceptions.RemoteClosedChannelException as error:\n    print('Queue declare failed: %s' % error)\n```\n\n\n示例代码：HA队列指定节点\n```python\nimport rabbitpy\n\nconnection = rabbitpy.Connection()\ntry:\n    with connection.channel() as channel:\n        arguments = {'x-ha-policy': 'nodes',\n                     'x-ha-nodes': ['rabbit@node1',\n                                    'rabbit@node2',\n                                    'rabbit@node3']}\n        queue = rabbitpy.Queue(channel,\n                               'my-2nd-ha-queue',\n                               arguments=arguments)\n        if queue.declare():\n            print('Queue declared')\nexcept rabbitpy.exceptions.RemoteClosedChannelException as error:\n    print('Queue declare failed: %s' % error)\n```\n\n### 消息持久化\n\ndelivery-mode=1，保存到内存；delivery-mode=2，保存到磁盘。服务器重启后，消息仍在队列中（队列必须声明为durable）。\n\n如果rabbitmq经常等待操作系统响应读写请求，消息吞吐量将大大降低。\n\n\n## rabbitmq回推\n\n发布者发布消息太快，RabbitMQ发送Channel.Flow RPC方法，阻塞发布者。发布者不能发送消息直到收到另一条Channel.Flow命令。\n\n示例代码：检测连接状态\n```python\nimport rabbitpy\n\nconnection = rabbitpy.Connection()\nprint('Channel is Blocked? %s' % connection.blocked)\n\n```","slug":"rabbitmq消息发布","published":1,"updated":"2020-10-26T14:13:48.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w8a000bi4ufah2ucimq","content":"<h2 id=\"可靠投递\"><a href=\"#可靠投递\" class=\"headerlink\" title=\"可靠投递\"></a>可靠投递</h2><hr>\n<h3 id=\"mandatory\"><a href=\"#mandatory\" class=\"headerlink\" title=\"mandatory\"></a>mandatory</h3><p>当交换器无法路由消息，RabbitMQ将回发Basic.Return消息到发布者，同时回发完整消息。<br>Basic.Return是异步的，在消息发布后的任何时候都可能发生。<br>在rabbitpy库中，客户端自动接收Basic.Return，并触发异常</p>\n<p>示例程序：发布失败</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> datetime\n<span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token comment\" spellcheck=\"true\"># Connect to the default URL of amqp://guest:guest@localhost:15672/%2F</span>\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># Create the message to send</span>\n        body <span class=\"token operator\">=</span> <span class=\"token string\">'server.cpu.utilization 25.5 1350884514'</span>\n        message <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                                   body<span class=\"token punctuation\">,</span>\n                                   <span class=\"token punctuation\">{</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token string\">'timestamp'</span><span class=\"token punctuation\">:</span> datetime<span class=\"token punctuation\">.</span>datetime<span class=\"token punctuation\">.</span>now<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token string\">'message_type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'graphite metric'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\"># Publish the message to the exchange with the routing key</span>\n        <span class=\"token comment\" spellcheck=\"true\"># \"server-metrics\" and make sure it is routed to the exchange</span>\n        message<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'chapter2-example'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'server-metrics'</span><span class=\"token punctuation\">,</span> mandatory<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例程序：异常捕获</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> datetime\n<span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token comment\" spellcheck=\"true\"># Connect to the default URL of amqp://guest:guest@localhost:15672/%2F</span>\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        properties <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">,</span>\n                      <span class=\"token string\">'timestamp'</span><span class=\"token punctuation\">:</span> datetime<span class=\"token punctuation\">.</span>datetime<span class=\"token punctuation\">.</span>now<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                      <span class=\"token string\">'message_type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'graphite metric'</span><span class=\"token punctuation\">}</span>\n        body <span class=\"token operator\">=</span> <span class=\"token string\">'server.cpu.utilization 25.5 1350884514'</span>\n        message <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> body<span class=\"token punctuation\">,</span> properties<span class=\"token punctuation\">)</span>\n        message<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'chapter2-example'</span><span class=\"token punctuation\">,</span>\n                        <span class=\"token string\">'server-metrics'</span><span class=\"token punctuation\">,</span>\n                        mandatory<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">except</span> rabbitpy<span class=\"token punctuation\">.</span>exceptions<span class=\"token punctuation\">.</span>MessageReturnedException <span class=\"token keyword\">as</span> error<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Publish failure: %s'</span> <span class=\"token operator\">%</span> error<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"发布者确认\"><a href=\"#发布者确认\" class=\"headerlink\" title=\"发布者确认\"></a>发布者确认</h3><p>发布者发送给RabbitMQ的每条消息，服务器发送一个确认(Basic.Ack)或者否认相应（Basic.Nack）。</p>\n<p>示例程序：发布者确认</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        exchange <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'chapter4-example'</span><span class=\"token punctuation\">)</span>\n        exchange<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        channel<span class=\"token punctuation\">.</span>enable_publisher_confirms<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        message <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                                   <span class=\"token string\">'This is an important message'</span><span class=\"token punctuation\">,</span>\n                                   <span class=\"token punctuation\">{</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token string\">'message_type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'very important'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> message<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'chapter4-example'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'important.message'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'The message was confirmed'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>rabbitpy中没有使用回调的方法，而是在确认收到之前会一直阻塞。</p>\n<h3 id=\"备用交换器\"><a href=\"#备用交换器\" class=\"headerlink\" title=\"备用交换器\"></a>备用交换器</h3><p>处理无法路由的消息。当不可路由的消息发布到已经定义了备用交换器的交换器中时，它将被路由到备用交换器。</p>\n<p>示例程序：备用交换器</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        my_ae <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'my-ae'</span><span class=\"token punctuation\">,</span>\n                                  exchange_type<span class=\"token operator\">=</span><span class=\"token string\">'fanout'</span><span class=\"token punctuation\">)</span>\n        my_ae<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        args <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'alternate-exchange'</span><span class=\"token punctuation\">:</span> my_ae<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span>\n        exchange <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                                     <span class=\"token string\">'graphite'</span><span class=\"token punctuation\">,</span>\n                                     exchange_type<span class=\"token operator\">=</span><span class=\"token string\">'topic'</span><span class=\"token punctuation\">,</span>\n                                     arguments<span class=\"token operator\">=</span>args<span class=\"token punctuation\">)</span>\n        exchange<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        queue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'unroutable-messages'</span><span class=\"token punctuation\">)</span>\n        queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span>my_ae<span class=\"token punctuation\">,</span> <span class=\"token string\">'#'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Queue bound to alternate-exchange'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"基于事务的批量处理\"><a href=\"#基于事务的批量处理\" class=\"headerlink\" title=\"基于事务的批量处理\"></a>基于事务的批量处理</h3><p>确保消息投递成功。</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        tx <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Tx<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span>\n        tx<span class=\"token punctuation\">.</span>select<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        message <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                                   <span class=\"token string\">'This is an important message'</span><span class=\"token punctuation\">,</span>\n                                   <span class=\"token punctuation\">{</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token string\">'delivery_mode'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token string\">'message_type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'important'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        message<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'chapter4-example'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'important.message'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> tx<span class=\"token punctuation\">.</span>commit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Transaction committed'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">except</span> rabbitpy<span class=\"token punctuation\">.</span>exceptions<span class=\"token punctuation\">.</span>NoActiveTransactionError<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Tried to commit without active transaction'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>由于错误无法路由消息时，将及时返回Basic.Return。发布者应发送TX.RollbackRPC请求并等待来自代理服务器的TX.Rollback相应，然后继续后续的工作。</p>\n<h3 id=\"HA队列\"><a href=\"#HA队列\" class=\"headerlink\" title=\"HA队列\"></a>HA队列</h3><p>允许队列在多个服务器拥有冗余副本。<br>发布者发送消息到集群中的任何节点。RabbitMQ节点同步队列中消息的状态。发布的消息被放入队列，并存储在每台服务器上。</p>\n<p>示例代码：HA队列声明</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        queue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                               <span class=\"token string\">'my-ha-queue'</span><span class=\"token punctuation\">,</span>\n                               arguments<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token string\">'x-ha-policy'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'all'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Queue declared'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">except</span> rabbitpy<span class=\"token punctuation\">.</span>exceptions<span class=\"token punctuation\">.</span>RemoteClosedChannelException <span class=\"token keyword\">as</span> error<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Queue declare failed: %s'</span> <span class=\"token operator\">%</span> error<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例代码：HA队列指定节点</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        arguments <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'x-ha-policy'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'nodes'</span><span class=\"token punctuation\">,</span>\n                     <span class=\"token string\">'x-ha-nodes'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'rabbit@node1'</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token string\">'rabbit@node2'</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token string\">'rabbit@node3'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span>\n        queue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                               <span class=\"token string\">'my-2nd-ha-queue'</span><span class=\"token punctuation\">,</span>\n                               arguments<span class=\"token operator\">=</span>arguments<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Queue declared'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">except</span> rabbitpy<span class=\"token punctuation\">.</span>exceptions<span class=\"token punctuation\">.</span>RemoteClosedChannelException <span class=\"token keyword\">as</span> error<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Queue declare failed: %s'</span> <span class=\"token operator\">%</span> error<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h3><p>delivery-mode=1，保存到内存；delivery-mode=2，保存到磁盘。服务器重启后，消息仍在队列中（队列必须声明为durable）。</p>\n<p>如果rabbitmq经常等待操作系统响应读写请求，消息吞吐量将大大降低。</p>\n<h2 id=\"rabbitmq回推\"><a href=\"#rabbitmq回推\" class=\"headerlink\" title=\"rabbitmq回推\"></a>rabbitmq回推</h2><p>发布者发布消息太快，RabbitMQ发送Channel.Flow RPC方法，阻塞发布者。发布者不能发送消息直到收到另一条Channel.Flow命令。</p>\n<p>示例代码：检测连接状态</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Channel is Blocked? %s'</span> <span class=\"token operator\">%</span> connection<span class=\"token punctuation\">.</span>blocked<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"可靠投递\"><a href=\"#可靠投递\" class=\"headerlink\" title=\"可靠投递\"></a>可靠投递</h2><hr>\n<h3 id=\"mandatory\"><a href=\"#mandatory\" class=\"headerlink\" title=\"mandatory\"></a>mandatory</h3><p>当交换器无法路由消息，RabbitMQ将回发Basic.Return消息到发布者，同时回发完整消息。<br>Basic.Return是异步的，在消息发布后的任何时候都可能发生。<br>在rabbitpy库中，客户端自动接收Basic.Return，并触发异常</p>\n<p>示例程序：发布失败</p>\n<pre><code class=\"python\">import datetime\nimport rabbitpy\n\n# Connect to the default URL of amqp://guest:guest@localhost:15672/%2F\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        # Create the message to send\n        body = &#39;server.cpu.utilization 25.5 1350884514&#39;\n        message = rabbitpy.Message(channel,\n                                   body,\n                                   {&#39;content_type&#39;: &#39;text/plain&#39;,\n                                    &#39;timestamp&#39;: datetime.datetime.now(),\n                                    &#39;message_type&#39;: &#39;graphite metric&#39;})\n\n        # Publish the message to the exchange with the routing key\n        # &quot;server-metrics&quot; and make sure it is routed to the exchange\n        message.publish(&#39;chapter2-example&#39;, &#39;server-metrics&#39;, mandatory=True)</code></pre>\n<p>示例程序：异常捕获</p>\n<pre><code class=\"python\">import datetime\nimport rabbitpy\n\n# Connect to the default URL of amqp://guest:guest@localhost:15672/%2F\nconnection = rabbitpy.Connection()\ntry:\n    with connection.channel() as channel:\n        properties = {&#39;content_type&#39;: &#39;text/plain&#39;,\n                      &#39;timestamp&#39;: datetime.datetime.now(),\n                      &#39;message_type&#39;: &#39;graphite metric&#39;}\n        body = &#39;server.cpu.utilization 25.5 1350884514&#39;\n        message = rabbitpy.Message(channel, body, properties)\n        message.publish(&#39;chapter2-example&#39;,\n                        &#39;server-metrics&#39;,\n                        mandatory=True)\nexcept rabbitpy.exceptions.MessageReturnedException as error:\n    print(&#39;Publish failure: %s&#39; % error)</code></pre>\n<h3 id=\"发布者确认\"><a href=\"#发布者确认\" class=\"headerlink\" title=\"发布者确认\"></a>发布者确认</h3><p>发布者发送给RabbitMQ的每条消息，服务器发送一个确认(Basic.Ack)或者否认相应（Basic.Nack）。</p>\n<p>示例程序：发布者确认</p>\n<pre><code class=\"python\">import rabbitpy\n\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, &#39;chapter4-example&#39;)\n        exchange.declare()\n        channel.enable_publisher_confirms()\n        message = rabbitpy.Message(channel,\n                                   &#39;This is an important message&#39;,\n                                   {&#39;content_type&#39;: &#39;text/plain&#39;,\n                                    &#39;message_type&#39;: &#39;very important&#39;})\n        if message.publish(&#39;chapter4-example&#39;, &#39;important.message&#39;):\n            print(&#39;The message was confirmed&#39;)</code></pre>\n<p>rabbitpy中没有使用回调的方法，而是在确认收到之前会一直阻塞。</p>\n<h3 id=\"备用交换器\"><a href=\"#备用交换器\" class=\"headerlink\" title=\"备用交换器\"></a>备用交换器</h3><p>处理无法路由的消息。当不可路由的消息发布到已经定义了备用交换器的交换器中时，它将被路由到备用交换器。</p>\n<p>示例程序：备用交换器</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        my_ae = rabbitpy.Exchange(channel, &#39;my-ae&#39;,\n                                  exchange_type=&#39;fanout&#39;)\n        my_ae.declare()\n        args = {&#39;alternate-exchange&#39;: my_ae.name}\n        exchange = rabbitpy.Exchange(channel,\n                                     &#39;graphite&#39;,\n                                     exchange_type=&#39;topic&#39;,\n                                     arguments=args)\n        exchange.declare()\n        queue = rabbitpy.Queue(channel, &#39;unroutable-messages&#39;)\n        queue.declare()\n        if queue.bind(my_ae, &#39;#&#39;):\n            print(&#39;Queue bound to alternate-exchange&#39;)</code></pre>\n<h3 id=\"基于事务的批量处理\"><a href=\"#基于事务的批量处理\" class=\"headerlink\" title=\"基于事务的批量处理\"></a>基于事务的批量处理</h3><p>确保消息投递成功。</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        tx = rabbitpy.Tx(channel)\n        tx.select()\n        message = rabbitpy.Message(channel,\n                                   &#39;This is an important message&#39;,\n                                   {&#39;content_type&#39;: &#39;text/plain&#39;,\n                                    &#39;delivery_mode&#39;: 2,\n                                    &#39;message_type&#39;: &#39;important&#39;})\n        message.publish(&#39;chapter4-example&#39;, &#39;important.message&#39;)\n        try:\n            if tx.commit():\n                print(&#39;Transaction committed&#39;)\n        except rabbitpy.exceptions.NoActiveTransactionError:\n            print(&#39;Tried to commit without active transaction&#39;)</code></pre>\n<p>由于错误无法路由消息时，将及时返回Basic.Return。发布者应发送TX.RollbackRPC请求并等待来自代理服务器的TX.Rollback相应，然后继续后续的工作。</p>\n<h3 id=\"HA队列\"><a href=\"#HA队列\" class=\"headerlink\" title=\"HA队列\"></a>HA队列</h3><p>允许队列在多个服务器拥有冗余副本。<br>发布者发送消息到集群中的任何节点。RabbitMQ节点同步队列中消息的状态。发布的消息被放入队列，并存储在每台服务器上。</p>\n<p>示例代码：HA队列声明</p>\n<pre><code class=\"python\">import rabbitpy\n\nconnection = rabbitpy.Connection()\ntry:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel,\n                               &#39;my-ha-queue&#39;,\n                               arguments={&#39;x-ha-policy&#39;: &#39;all&#39;})\n        if queue.declare():\n            print(&#39;Queue declared&#39;)\nexcept rabbitpy.exceptions.RemoteClosedChannelException as error:\n    print(&#39;Queue declare failed: %s&#39; % error)</code></pre>\n<p>示例代码：HA队列指定节点</p>\n<pre><code class=\"python\">import rabbitpy\n\nconnection = rabbitpy.Connection()\ntry:\n    with connection.channel() as channel:\n        arguments = {&#39;x-ha-policy&#39;: &#39;nodes&#39;,\n                     &#39;x-ha-nodes&#39;: [&#39;rabbit@node1&#39;,\n                                    &#39;rabbit@node2&#39;,\n                                    &#39;rabbit@node3&#39;]}\n        queue = rabbitpy.Queue(channel,\n                               &#39;my-2nd-ha-queue&#39;,\n                               arguments=arguments)\n        if queue.declare():\n            print(&#39;Queue declared&#39;)\nexcept rabbitpy.exceptions.RemoteClosedChannelException as error:\n    print(&#39;Queue declare failed: %s&#39; % error)</code></pre>\n<h3 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h3><p>delivery-mode=1，保存到内存；delivery-mode=2，保存到磁盘。服务器重启后，消息仍在队列中（队列必须声明为durable）。</p>\n<p>如果rabbitmq经常等待操作系统响应读写请求，消息吞吐量将大大降低。</p>\n<h2 id=\"rabbitmq回推\"><a href=\"#rabbitmq回推\" class=\"headerlink\" title=\"rabbitmq回推\"></a>rabbitmq回推</h2><p>发布者发布消息太快，RabbitMQ发送Channel.Flow RPC方法，阻塞发布者。发布者不能发送消息直到收到另一条Channel.Flow命令。</p>\n<p>示例代码：检测连接状态</p>\n<pre><code class=\"python\">import rabbitpy\n\nconnection = rabbitpy.Connection()\nprint(&#39;Channel is Blocked? %s&#39; % connection.blocked)\n</code></pre>\n"},{"title":"rabbitmq消息可靠性","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T14:19:29.000Z","password":null,"summary":null,"_content":"\n## 消息丢失场景\n\n\n### 消息从生产者写入到消息队列的过程\n\n**问题原因**：\n网络抖动\n\n**解决办法**：\n\n- 事务\n在生产者发送消息之前，通过channel.txSelect开启一个事务，接着发送消息， 如果消息投递失败，进行事务回滚channel.txRollback，然后重新发送， 如果消息投递成功，就提交事务channel.txCommit。\n缺点：同步操作。生产者吞吐量大大降低。\n\n- 发布者确认\n一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一deliveryTag和multiple参数），这就使得生产者知晓消息已经正确到达了目的地。\n\n\n- 其他\n1. 使用mandatory 设置true：不可路由消息回发到生产者（正常都是可路由的，路由的队列所在节点宕机？）\n2. 利用备份交换机（alternate-exchange）：处理无法路由到队列的消息（正常都是可路由的，路由的队列所在节点宕机？）\n\n### 消息在消息队列中的存储场景\n\n**问题原因**：\n\n- 持久化了Message，没有持久化队列\n- 唯一的磁盘节点宕机\n\n\n**解决办法**：\n1、消息持久化+队列持久化\n消息设置delivery-mode为2，队列设置为durable\n\n2、使用HA队列\n发布者发送消息到集群中的任何节点。RabbitMQ节点同步队列中消息的状态。发布的消息被放入队列，并存储在每台服务器上。\n\n\n3、集群设置>=1的磁盘节点。\n磁盘节点保存集群的运行时状态。确保有多个磁盘节点，保证故障场景下的可靠性。集群恢复时，需要注意磁盘节点的启动顺序。\n\n\n\n\n### 消息被消费者消费的过程\n\n**问题原因**：错误代码\n**解决办法**：\n1、使用消费者手动确认消费\n2、消费者程序使用事务提交和回滚批量操作。","source":"_posts/rabbitmq消息可靠性.md","raw":"---\ntitle: rabbitmq消息可靠性\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 22:19:29\npassword:\nsummary:\ntags:\n- rabbitmq\ncategories:\n- rabbitmq\n---\n\n## 消息丢失场景\n\n\n### 消息从生产者写入到消息队列的过程\n\n**问题原因**：\n网络抖动\n\n**解决办法**：\n\n- 事务\n在生产者发送消息之前，通过channel.txSelect开启一个事务，接着发送消息， 如果消息投递失败，进行事务回滚channel.txRollback，然后重新发送， 如果消息投递成功，就提交事务channel.txCommit。\n缺点：同步操作。生产者吞吐量大大降低。\n\n- 发布者确认\n一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一deliveryTag和multiple参数），这就使得生产者知晓消息已经正确到达了目的地。\n\n\n- 其他\n1. 使用mandatory 设置true：不可路由消息回发到生产者（正常都是可路由的，路由的队列所在节点宕机？）\n2. 利用备份交换机（alternate-exchange）：处理无法路由到队列的消息（正常都是可路由的，路由的队列所在节点宕机？）\n\n### 消息在消息队列中的存储场景\n\n**问题原因**：\n\n- 持久化了Message，没有持久化队列\n- 唯一的磁盘节点宕机\n\n\n**解决办法**：\n1、消息持久化+队列持久化\n消息设置delivery-mode为2，队列设置为durable\n\n2、使用HA队列\n发布者发送消息到集群中的任何节点。RabbitMQ节点同步队列中消息的状态。发布的消息被放入队列，并存储在每台服务器上。\n\n\n3、集群设置>=1的磁盘节点。\n磁盘节点保存集群的运行时状态。确保有多个磁盘节点，保证故障场景下的可靠性。集群恢复时，需要注意磁盘节点的启动顺序。\n\n\n\n\n### 消息被消费者消费的过程\n\n**问题原因**：错误代码\n**解决办法**：\n1、使用消费者手动确认消费\n2、消费者程序使用事务提交和回滚批量操作。","slug":"rabbitmq消息可靠性","published":1,"updated":"2021-03-11T14:01:44.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w8k000gi4uf32zajvym","content":"<h2 id=\"消息丢失场景\"><a href=\"#消息丢失场景\" class=\"headerlink\" title=\"消息丢失场景\"></a>消息丢失场景</h2><h3 id=\"消息从生产者写入到消息队列的过程\"><a href=\"#消息从生产者写入到消息队列的过程\" class=\"headerlink\" title=\"消息从生产者写入到消息队列的过程\"></a>消息从生产者写入到消息队列的过程</h3><p><strong>问题原因</strong>：<br>网络抖动</p>\n<p><strong>解决办法</strong>：</p>\n<ul>\n<li><p>事务<br>在生产者发送消息之前，通过channel.txSelect开启一个事务，接着发送消息， 如果消息投递失败，进行事务回滚channel.txRollback，然后重新发送， 如果消息投递成功，就提交事务channel.txCommit。<br>缺点：同步操作。生产者吞吐量大大降低。</p>\n</li>\n<li><p>发布者确认<br>一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一deliveryTag和multiple参数），这就使得生产者知晓消息已经正确到达了目的地。</p>\n</li>\n</ul>\n<ul>\n<li>其他</li>\n</ul>\n<ol>\n<li>使用mandatory 设置true：不可路由消息回发到生产者（正常都是可路由的，路由的队列所在节点宕机？）</li>\n<li>利用备份交换机（alternate-exchange）：处理无法路由到队列的消息（正常都是可路由的，路由的队列所在节点宕机？）</li>\n</ol>\n<h3 id=\"消息在消息队列中的存储场景\"><a href=\"#消息在消息队列中的存储场景\" class=\"headerlink\" title=\"消息在消息队列中的存储场景\"></a>消息在消息队列中的存储场景</h3><p><strong>问题原因</strong>：</p>\n<ul>\n<li>持久化了Message，没有持久化队列</li>\n<li>唯一的磁盘节点宕机</li>\n</ul>\n<p><strong>解决办法</strong>：<br>1、消息持久化+队列持久化<br>消息设置delivery-mode为2，队列设置为durable</p>\n<p>2、使用HA队列<br>发布者发送消息到集群中的任何节点。RabbitMQ节点同步队列中消息的状态。发布的消息被放入队列，并存储在每台服务器上。</p>\n<p>3、集群设置&gt;=1的磁盘节点。<br>磁盘节点保存集群的运行时状态。确保有多个磁盘节点，保证故障场景下的可靠性。集群恢复时，需要注意磁盘节点的启动顺序。</p>\n<h3 id=\"消息被消费者消费的过程\"><a href=\"#消息被消费者消费的过程\" class=\"headerlink\" title=\"消息被消费者消费的过程\"></a>消息被消费者消费的过程</h3><p><strong>问题原因</strong>：错误代码<br><strong>解决办法</strong>：<br>1、使用消费者手动确认消费<br>2、消费者程序使用事务提交和回滚批量操作。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"消息丢失场景\"><a href=\"#消息丢失场景\" class=\"headerlink\" title=\"消息丢失场景\"></a>消息丢失场景</h2><h3 id=\"消息从生产者写入到消息队列的过程\"><a href=\"#消息从生产者写入到消息队列的过程\" class=\"headerlink\" title=\"消息从生产者写入到消息队列的过程\"></a>消息从生产者写入到消息队列的过程</h3><p><strong>问题原因</strong>：<br>网络抖动</p>\n<p><strong>解决办法</strong>：</p>\n<ul>\n<li><p>事务<br>在生产者发送消息之前，通过channel.txSelect开启一个事务，接着发送消息， 如果消息投递失败，进行事务回滚channel.txRollback，然后重新发送， 如果消息投递成功，就提交事务channel.txCommit。<br>缺点：同步操作。生产者吞吐量大大降低。</p>\n</li>\n<li><p>发布者确认<br>一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一deliveryTag和multiple参数），这就使得生产者知晓消息已经正确到达了目的地。</p>\n</li>\n</ul>\n<ul>\n<li>其他</li>\n</ul>\n<ol>\n<li>使用mandatory 设置true：不可路由消息回发到生产者（正常都是可路由的，路由的队列所在节点宕机？）</li>\n<li>利用备份交换机（alternate-exchange）：处理无法路由到队列的消息（正常都是可路由的，路由的队列所在节点宕机？）</li>\n</ol>\n<h3 id=\"消息在消息队列中的存储场景\"><a href=\"#消息在消息队列中的存储场景\" class=\"headerlink\" title=\"消息在消息队列中的存储场景\"></a>消息在消息队列中的存储场景</h3><p><strong>问题原因</strong>：</p>\n<ul>\n<li>持久化了Message，没有持久化队列</li>\n<li>唯一的磁盘节点宕机</li>\n</ul>\n<p><strong>解决办法</strong>：<br>1、消息持久化+队列持久化<br>消息设置delivery-mode为2，队列设置为durable</p>\n<p>2、使用HA队列<br>发布者发送消息到集群中的任何节点。RabbitMQ节点同步队列中消息的状态。发布的消息被放入队列，并存储在每台服务器上。</p>\n<p>3、集群设置&gt;=1的磁盘节点。<br>磁盘节点保存集群的运行时状态。确保有多个磁盘节点，保证故障场景下的可靠性。集群恢复时，需要注意磁盘节点的启动顺序。</p>\n<h3 id=\"消息被消费者消费的过程\"><a href=\"#消息被消费者消费的过程\" class=\"headerlink\" title=\"消息被消费者消费的过程\"></a>消息被消费者消费的过程</h3><p><strong>问题原因</strong>：错误代码<br><strong>解决办法</strong>：<br>1、使用消费者手动确认消费<br>2、消费者程序使用事务提交和回滚批量操作。</p>\n"},{"title":"rabbitmq消息消费","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T14:16:01.000Z","password":null,"summary":null,"_content":"\n\n\n## 消费方法\n\n------------\n\n### **Basic.Get**\n\n - 每次接收消息必须发送一次请求 \n - 有消息可用，RabbitMQ返回Basic.GetOk以及消息\n - 无消息可用，RabbitMQ返回Basic.GetEmpty 应用程序需要评估RPC响应以及是否接收到消息。\n\n示例程序\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'test-messages')\n        queue.declare()\n        while True:\n            message = queue.get()\n            if message:\n                message.pprint()\n                # 确认消息\n                message.ack()\n                if message.body == 'stop':\n                    break\n```\n\n###**Basic.Consume**\n\n- 消费者可用时，异步方式发送消息\n- 应用程序自动接收消息，直到Basic.Cancel\n- 仍然需要确认消息\n\n示例程序\n```python\nimport rabbitpy\n\nfor message in rabbitpy.consume('amqp://guest:guest@localhost:5672/%2f',\n                                'test-messages'):\n    message.pprint(）\n    # 消息确认\n    message.ack()\n```\n\n**消费者标签**\n应用程序发出Basic.Comsume时，创建唯一字符串（消费者标签），标识应用程序。RabbitMQ每次都会把该字符串和消息一同发送给应用程序。\n客户端库对消费者标签封装，以确定如何处理消息。开发者不用处理消费者标签。\n\n示例代码：监听消息直到，收到停止消息\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        for message in rabbitpy.Queue(channel, 'test-messages'):\n            message.pprint()\n            message.ack()\n            if message.body == 'stop':\n                break\n```\n\n\n### **对比**\nConsume吞吐量更大。Get包含了每条消息的同步通信开销。\n\n\n---------------\n\n## 消费性能优化\n\n----------------\n\n### 1、no-ack\n\n应用程序发送Basic.Comsume请求时，设置no-ack。表明消费者不进行消费确认。\n\n示例代码：消费不确认\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'test-messages')\n        for message in queue.consume_messages(no_ack=True):\n            message.pprint()\n```\n\n### 2、预取\n\nQoS（Quality of service）中，可设置消费者预先接收一定数量的消息。Basic.Qos一般在Basic.Consume之前设置。\n\n示例程序：指定QoS\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        #预取数为10\n        channel.prefetch_count(10)\n        for message in rabbitpy.Queue(channel, 'test-messages'):\n            message.pprint()\n            message.ack()\n```\n\n应用程序不需要确认每条消息，可确认所有以前未读消息。\n\n示例程序：多消息确认\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        channel.prefetch_count(10)\n        for message in rabbitpy.Queue(channel, 'test-messages'):\n            message.pprint()\n            unacknowledged += 1\n            if unacknowledged == 10:\n                # 确认所有未确认消息\n                message.ack(all_previous=True)\n                unacknowledged = 0\n\n```\n\n### 3、事务\n\n事务允许消费者应用程序提交和回滚批量操作。不适用QoS时，可以获得轻微的性能提升。\n\n---------\n\n## 拒绝消息\n\n--------\n\n### Basic.Reject\n\n通知rabbitmq无法处理投递的消息（拒绝一个消息），可指示rabbitMQ丢弃消息或使用requeue重发消息。\n\n示例程序：消息拒绝\n```\nimport rabbitpy\n\nfor message in rabbitpy.consume('amqp://guest:guest@localhost:5672/%2f',\n                                'test-messages'):\n    message.pprint()\n    print('Redelivered: %s' % message.redelivered)\n    message.reject(True)\n```\n\n### Basic.Nack\n\n同时拒绝多个消息\n\n### 死信交换器（DLX）\n\n创建队列时声明该交换器用于保存被拒绝的消息。队列x-dead-letter-exchange参数(RPC请求)指定死信交换器。\n\n示例程序：指定死信交换器\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        #死信交换器\n        rabbitpy.Exchange(channel, 'rejected-messages').declare()\n        queue = rabbitpy.Queue(channel, 'dlx-example',\n                               dead_letter_exchange='rejected-messages')\n        queue.declare()\n\n```\n\n---------\n\n## 控制队列\n\n----------\n\n### 临时队列\n\n**自动删除队列**\n消费者完成连接和检索消息，所有消费者断开连接时，队列将被删除。\n\n示例程序：自动删除队列auto_delete=True\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'ad-example', auto_delete=True)\n        queue.declare()\n```\n\n**只允许单个消费者**\n只有单个消费者能够消费队列中的消息。消费者断开连接后，会自动删除队列。\n\n示例程序：独占队列exclusive\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'exclusive-example',\n                               exclusive=True)\n        queue.declare()\n```\n\n**自动过期队列**\n如果一段时间没有使用该队列就删除它，一般用于RPC回复队列。\n\n示例程序：自动过期队列\n```\nimport rabbitpy\nimport time\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'expiring-queue',\n                               arguments={'x-expires': 1000})\n        queue.declare()\n        messages, consumers = queue.declare(passive=True)\n        time.sleep(2)\n        try:\n            messages, consumers = queue.declare(passive=True)\n        except rabbitpy.exceptions.AMQPNotFound:\n            print('The queue no longer exists')\n```\n\n### 永久队列\n\n**队列持久性**\n服务器重启后队列仍然存在。\n示例程序：持久队列\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'durable-queue',\n                               durable=True)\n        if queue.declare():\n            print('Queue declared')\n```\n\n**队列消息自动过期**\n同时指定死信交换器和消息TTL，过期消息将成为死信消息。\n\n示例程序：消息TTL\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'expiring-msg-queue',\n                               arguments={'x-message-ttl': 1000})\n         queue.declare()\n\n```\n\n**最大队列长度**\n一旦达到最大值，添加新消息时，删除队列前端的消息。声明队列时，如果指定死信交换器，前端移除的消息将成为死信。\n\n示例程序：最大长度队列\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'max-length-queue',\n                               arguments={'x-max-length': 1000})\n        queue.declare()\n\n```\n\n\n### 队列设置参数\n\n| 参数                      | 说明                                 |\n| ------------------------- | ------------------------------------ |\n| x-dead-letter-exchange    | 死信交换器，路由不重发且被拒绝的消息 |\n| x-dead-letter-routing-key | 死信消息的可选路由键                 |\n| x-expires                 | 队列在指定的毫秒数后删除             |\n| x-ha-proxy                | 创建HA队列                           |\n| x-ha-nodes                | HA队列分布的节点                     |\n| x-max-length              | 队列的最大消息数                     |\n| x-message-ttl             | 毫秒为单位的队列过期时间             |\n| x-max-priority            | 队列优先级排序                       |","source":"_posts/rabbitmq消息消费.md","raw":"---\ntitle: rabbitmq消息消费\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 22:16:01\npassword:\nsummary:\ntags:\n- rabbitmq\ncategories:\n- rabbitmq\n---\n\n\n\n## 消费方法\n\n------------\n\n### **Basic.Get**\n\n - 每次接收消息必须发送一次请求 \n - 有消息可用，RabbitMQ返回Basic.GetOk以及消息\n - 无消息可用，RabbitMQ返回Basic.GetEmpty 应用程序需要评估RPC响应以及是否接收到消息。\n\n示例程序\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'test-messages')\n        queue.declare()\n        while True:\n            message = queue.get()\n            if message:\n                message.pprint()\n                # 确认消息\n                message.ack()\n                if message.body == 'stop':\n                    break\n```\n\n###**Basic.Consume**\n\n- 消费者可用时，异步方式发送消息\n- 应用程序自动接收消息，直到Basic.Cancel\n- 仍然需要确认消息\n\n示例程序\n```python\nimport rabbitpy\n\nfor message in rabbitpy.consume('amqp://guest:guest@localhost:5672/%2f',\n                                'test-messages'):\n    message.pprint(）\n    # 消息确认\n    message.ack()\n```\n\n**消费者标签**\n应用程序发出Basic.Comsume时，创建唯一字符串（消费者标签），标识应用程序。RabbitMQ每次都会把该字符串和消息一同发送给应用程序。\n客户端库对消费者标签封装，以确定如何处理消息。开发者不用处理消费者标签。\n\n示例代码：监听消息直到，收到停止消息\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        for message in rabbitpy.Queue(channel, 'test-messages'):\n            message.pprint()\n            message.ack()\n            if message.body == 'stop':\n                break\n```\n\n\n### **对比**\nConsume吞吐量更大。Get包含了每条消息的同步通信开销。\n\n\n---------------\n\n## 消费性能优化\n\n----------------\n\n### 1、no-ack\n\n应用程序发送Basic.Comsume请求时，设置no-ack。表明消费者不进行消费确认。\n\n示例代码：消费不确认\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'test-messages')\n        for message in queue.consume_messages(no_ack=True):\n            message.pprint()\n```\n\n### 2、预取\n\nQoS（Quality of service）中，可设置消费者预先接收一定数量的消息。Basic.Qos一般在Basic.Consume之前设置。\n\n示例程序：指定QoS\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        #预取数为10\n        channel.prefetch_count(10)\n        for message in rabbitpy.Queue(channel, 'test-messages'):\n            message.pprint()\n            message.ack()\n```\n\n应用程序不需要确认每条消息，可确认所有以前未读消息。\n\n示例程序：多消息确认\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        channel.prefetch_count(10)\n        for message in rabbitpy.Queue(channel, 'test-messages'):\n            message.pprint()\n            unacknowledged += 1\n            if unacknowledged == 10:\n                # 确认所有未确认消息\n                message.ack(all_previous=True)\n                unacknowledged = 0\n\n```\n\n### 3、事务\n\n事务允许消费者应用程序提交和回滚批量操作。不适用QoS时，可以获得轻微的性能提升。\n\n---------\n\n## 拒绝消息\n\n--------\n\n### Basic.Reject\n\n通知rabbitmq无法处理投递的消息（拒绝一个消息），可指示rabbitMQ丢弃消息或使用requeue重发消息。\n\n示例程序：消息拒绝\n```\nimport rabbitpy\n\nfor message in rabbitpy.consume('amqp://guest:guest@localhost:5672/%2f',\n                                'test-messages'):\n    message.pprint()\n    print('Redelivered: %s' % message.redelivered)\n    message.reject(True)\n```\n\n### Basic.Nack\n\n同时拒绝多个消息\n\n### 死信交换器（DLX）\n\n创建队列时声明该交换器用于保存被拒绝的消息。队列x-dead-letter-exchange参数(RPC请求)指定死信交换器。\n\n示例程序：指定死信交换器\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        #死信交换器\n        rabbitpy.Exchange(channel, 'rejected-messages').declare()\n        queue = rabbitpy.Queue(channel, 'dlx-example',\n                               dead_letter_exchange='rejected-messages')\n        queue.declare()\n\n```\n\n---------\n\n## 控制队列\n\n----------\n\n### 临时队列\n\n**自动删除队列**\n消费者完成连接和检索消息，所有消费者断开连接时，队列将被删除。\n\n示例程序：自动删除队列auto_delete=True\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'ad-example', auto_delete=True)\n        queue.declare()\n```\n\n**只允许单个消费者**\n只有单个消费者能够消费队列中的消息。消费者断开连接后，会自动删除队列。\n\n示例程序：独占队列exclusive\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'exclusive-example',\n                               exclusive=True)\n        queue.declare()\n```\n\n**自动过期队列**\n如果一段时间没有使用该队列就删除它，一般用于RPC回复队列。\n\n示例程序：自动过期队列\n```\nimport rabbitpy\nimport time\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'expiring-queue',\n                               arguments={'x-expires': 1000})\n        queue.declare()\n        messages, consumers = queue.declare(passive=True)\n        time.sleep(2)\n        try:\n            messages, consumers = queue.declare(passive=True)\n        except rabbitpy.exceptions.AMQPNotFound:\n            print('The queue no longer exists')\n```\n\n### 永久队列\n\n**队列持久性**\n服务器重启后队列仍然存在。\n示例程序：持久队列\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'durable-queue',\n                               durable=True)\n        if queue.declare():\n            print('Queue declared')\n```\n\n**队列消息自动过期**\n同时指定死信交换器和消息TTL，过期消息将成为死信消息。\n\n示例程序：消息TTL\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'expiring-msg-queue',\n                               arguments={'x-message-ttl': 1000})\n         queue.declare()\n\n```\n\n**最大队列长度**\n一旦达到最大值，添加新消息时，删除队列前端的消息。声明队列时，如果指定死信交换器，前端移除的消息将成为死信。\n\n示例程序：最大长度队列\n```\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, 'max-length-queue',\n                               arguments={'x-max-length': 1000})\n        queue.declare()\n\n```\n\n\n### 队列设置参数\n\n| 参数                      | 说明                                 |\n| ------------------------- | ------------------------------------ |\n| x-dead-letter-exchange    | 死信交换器，路由不重发且被拒绝的消息 |\n| x-dead-letter-routing-key | 死信消息的可选路由键                 |\n| x-expires                 | 队列在指定的毫秒数后删除             |\n| x-ha-proxy                | 创建HA队列                           |\n| x-ha-nodes                | HA队列分布的节点                     |\n| x-max-length              | 队列的最大消息数                     |\n| x-message-ttl             | 毫秒为单位的队列过期时间             |\n| x-max-priority            | 队列优先级排序                       |","slug":"rabbitmq消息消费","published":1,"updated":"2020-10-26T14:17:11.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w8n000ii4ufcpnm4ehn","content":"<h2 id=\"消费方法\"><a href=\"#消费方法\" class=\"headerlink\" title=\"消费方法\"></a>消费方法</h2><hr>\n<h3 id=\"Basic-Get\"><a href=\"#Basic-Get\" class=\"headerlink\" title=\"Basic.Get\"></a><strong>Basic.Get</strong></h3><ul>\n<li>每次接收消息必须发送一次请求 </li>\n<li>有消息可用，RabbitMQ返回Basic.GetOk以及消息</li>\n<li>无消息可用，RabbitMQ返回Basic.GetEmpty 应用程序需要评估RPC响应以及是否接收到消息。</li>\n</ul>\n<p>示例程序</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;test-messages&#39;)\n        queue.declare()\n        while True:\n            message = queue.get()\n            if message:\n                message.pprint()\n                # 确认消息\n                message.ack()\n                if message.body == &#39;stop&#39;:\n                    break</code></pre><p>###<strong>Basic.Consume</strong></p>\n<ul>\n<li>消费者可用时，异步方式发送消息</li>\n<li>应用程序自动接收消息，直到Basic.Cancel</li>\n<li>仍然需要确认消息</li>\n</ul>\n<p>示例程序</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> rabbitpy<span class=\"token punctuation\">.</span>consume<span class=\"token punctuation\">(</span><span class=\"token string\">'amqp://guest:guest@localhost:5672/%2f'</span><span class=\"token punctuation\">,</span>\n                                <span class=\"token string\">'test-messages'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    message<span class=\"token punctuation\">.</span>pprint<span class=\"token punctuation\">(</span>）\n    <span class=\"token comment\" spellcheck=\"true\"># 消息确认</span>\n    message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>消费者标签</strong><br>应用程序发出Basic.Comsume时，创建唯一字符串（消费者标签），标识应用程序。RabbitMQ每次都会把该字符串和消息一同发送给应用程序。<br>客户端库对消费者标签封装，以确定如何处理消息。开发者不用处理消费者标签。</p>\n<p>示例代码：监听消息直到，收到停止消息</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'test-messages'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            message<span class=\"token punctuation\">.</span>pprint<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> message<span class=\"token punctuation\">.</span>body <span class=\"token operator\">==</span> <span class=\"token string\">'stop'</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">break</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a><strong>对比</strong></h3><p>Consume吞吐量更大。Get包含了每条消息的同步通信开销。</p>\n<hr>\n<h2 id=\"消费性能优化\"><a href=\"#消费性能优化\" class=\"headerlink\" title=\"消费性能优化\"></a>消费性能优化</h2><hr>\n<h3 id=\"1、no-ack\"><a href=\"#1、no-ack\" class=\"headerlink\" title=\"1、no-ack\"></a>1、no-ack</h3><p>应用程序发送Basic.Comsume请求时，设置no-ack。表明消费者不进行消费确认。</p>\n<p>示例代码：消费不确认</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;test-messages&#39;)\n        for message in queue.consume_messages(no_ack=True):\n            message.pprint()</code></pre><h3 id=\"2、预取\"><a href=\"#2、预取\" class=\"headerlink\" title=\"2、预取\"></a>2、预取</h3><p>QoS（Quality of service）中，可设置消费者预先接收一定数量的消息。Basic.Qos一般在Basic.Consume之前设置。</p>\n<p>示例程序：指定QoS</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#预取数为10</span>\n        channel<span class=\"token punctuation\">.</span>prefetch_count<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'test-messages'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            message<span class=\"token punctuation\">.</span>pprint<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>应用程序不需要确认每条消息，可确认所有以前未读消息。</p>\n<p>示例程序：多消息确认</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        channel<span class=\"token punctuation\">.</span>prefetch_count<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'test-messages'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            message<span class=\"token punctuation\">.</span>pprint<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            unacknowledged <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">if</span> unacknowledged <span class=\"token operator\">==</span> <span class=\"token number\">10</span><span class=\"token punctuation\">:</span>\n                <span class=\"token comment\" spellcheck=\"true\"># 确认所有未确认消息</span>\n                message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span>all_previous<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n                unacknowledged <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"3、事务\"><a href=\"#3、事务\" class=\"headerlink\" title=\"3、事务\"></a>3、事务</h3><p>事务允许消费者应用程序提交和回滚批量操作。不适用QoS时，可以获得轻微的性能提升。</p>\n<hr>\n<h2 id=\"拒绝消息\"><a href=\"#拒绝消息\" class=\"headerlink\" title=\"拒绝消息\"></a>拒绝消息</h2><hr>\n<h3 id=\"Basic-Reject\"><a href=\"#Basic-Reject\" class=\"headerlink\" title=\"Basic.Reject\"></a>Basic.Reject</h3><p>通知rabbitmq无法处理投递的消息（拒绝一个消息），可指示rabbitMQ丢弃消息或使用requeue重发消息。</p>\n<p>示例程序：消息拒绝</p>\n<pre><code>import rabbitpy\n\nfor message in rabbitpy.consume(&#39;amqp://guest:guest@localhost:5672/%2f&#39;,\n                                &#39;test-messages&#39;):\n    message.pprint()\n    print(&#39;Redelivered: %s&#39; % message.redelivered)\n    message.reject(True)</code></pre><h3 id=\"Basic-Nack\"><a href=\"#Basic-Nack\" class=\"headerlink\" title=\"Basic.Nack\"></a>Basic.Nack</h3><p>同时拒绝多个消息</p>\n<h3 id=\"死信交换器（DLX）\"><a href=\"#死信交换器（DLX）\" class=\"headerlink\" title=\"死信交换器（DLX）\"></a>死信交换器（DLX）</h3><p>创建队列时声明该交换器用于保存被拒绝的消息。队列x-dead-letter-exchange参数(RPC请求)指定死信交换器。</p>\n<p>示例程序：指定死信交换器</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#死信交换器</span>\n        rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'rejected-messages'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        queue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'dlx-example'</span><span class=\"token punctuation\">,</span>\n                               dead_letter_exchange<span class=\"token operator\">=</span><span class=\"token string\">'rejected-messages'</span><span class=\"token punctuation\">)</span>\n        queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"控制队列\"><a href=\"#控制队列\" class=\"headerlink\" title=\"控制队列\"></a>控制队列</h2><hr>\n<h3 id=\"临时队列\"><a href=\"#临时队列\" class=\"headerlink\" title=\"临时队列\"></a>临时队列</h3><p><strong>自动删除队列</strong><br>消费者完成连接和检索消息，所有消费者断开连接时，队列将被删除。</p>\n<p>示例程序：自动删除队列auto_delete=True</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;ad-example&#39;, auto_delete=True)\n        queue.declare()</code></pre><p><strong>只允许单个消费者</strong><br>只有单个消费者能够消费队列中的消息。消费者断开连接后，会自动删除队列。</p>\n<p>示例程序：独占队列exclusive</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;exclusive-example&#39;,\n                               exclusive=True)\n        queue.declare()</code></pre><p><strong>自动过期队列</strong><br>如果一段时间没有使用该队列就删除它，一般用于RPC回复队列。</p>\n<p>示例程序：自动过期队列</p>\n<pre><code>import rabbitpy\nimport time\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;expiring-queue&#39;,\n                               arguments={&#39;x-expires&#39;: 1000})\n        queue.declare()\n        messages, consumers = queue.declare(passive=True)\n        time.sleep(2)\n        try:\n            messages, consumers = queue.declare(passive=True)\n        except rabbitpy.exceptions.AMQPNotFound:\n            print(&#39;The queue no longer exists&#39;)</code></pre><h3 id=\"永久队列\"><a href=\"#永久队列\" class=\"headerlink\" title=\"永久队列\"></a>永久队列</h3><p><strong>队列持久性</strong><br>服务器重启后队列仍然存在。<br>示例程序：持久队列</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;durable-queue&#39;,\n                               durable=True)\n        if queue.declare():\n            print(&#39;Queue declared&#39;)</code></pre><p><strong>队列消息自动过期</strong><br>同时指定死信交换器和消息TTL，过期消息将成为死信消息。</p>\n<p>示例程序：消息TTL</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;expiring-msg-queue&#39;,\n                               arguments={&#39;x-message-ttl&#39;: 1000})\n         queue.declare()\n</code></pre><p><strong>最大队列长度</strong><br>一旦达到最大值，添加新消息时，删除队列前端的消息。声明队列时，如果指定死信交换器，前端移除的消息将成为死信。</p>\n<p>示例程序：最大长度队列</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;max-length-queue&#39;,\n                               arguments={&#39;x-max-length&#39;: 1000})\n        queue.declare()\n</code></pre><h3 id=\"队列设置参数\"><a href=\"#队列设置参数\" class=\"headerlink\" title=\"队列设置参数\"></a>队列设置参数</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>x-dead-letter-exchange</td>\n<td>死信交换器，路由不重发且被拒绝的消息</td>\n</tr>\n<tr>\n<td>x-dead-letter-routing-key</td>\n<td>死信消息的可选路由键</td>\n</tr>\n<tr>\n<td>x-expires</td>\n<td>队列在指定的毫秒数后删除</td>\n</tr>\n<tr>\n<td>x-ha-proxy</td>\n<td>创建HA队列</td>\n</tr>\n<tr>\n<td>x-ha-nodes</td>\n<td>HA队列分布的节点</td>\n</tr>\n<tr>\n<td>x-max-length</td>\n<td>队列的最大消息数</td>\n</tr>\n<tr>\n<td>x-message-ttl</td>\n<td>毫秒为单位的队列过期时间</td>\n</tr>\n<tr>\n<td>x-max-priority</td>\n<td>队列优先级排序</td>\n</tr>\n</tbody></table>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"消费方法\"><a href=\"#消费方法\" class=\"headerlink\" title=\"消费方法\"></a>消费方法</h2><hr>\n<h3 id=\"Basic-Get\"><a href=\"#Basic-Get\" class=\"headerlink\" title=\"Basic.Get\"></a><strong>Basic.Get</strong></h3><ul>\n<li>每次接收消息必须发送一次请求 </li>\n<li>有消息可用，RabbitMQ返回Basic.GetOk以及消息</li>\n<li>无消息可用，RabbitMQ返回Basic.GetEmpty 应用程序需要评估RPC响应以及是否接收到消息。</li>\n</ul>\n<p>示例程序</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;test-messages&#39;)\n        queue.declare()\n        while True:\n            message = queue.get()\n            if message:\n                message.pprint()\n                # 确认消息\n                message.ack()\n                if message.body == &#39;stop&#39;:\n                    break</code></pre><p>###<strong>Basic.Consume</strong></p>\n<ul>\n<li>消费者可用时，异步方式发送消息</li>\n<li>应用程序自动接收消息，直到Basic.Cancel</li>\n<li>仍然需要确认消息</li>\n</ul>\n<p>示例程序</p>\n<pre><code class=\"python\">import rabbitpy\n\nfor message in rabbitpy.consume(&#39;amqp://guest:guest@localhost:5672/%2f&#39;,\n                                &#39;test-messages&#39;):\n    message.pprint(）\n    # 消息确认\n    message.ack()</code></pre>\n<p><strong>消费者标签</strong><br>应用程序发出Basic.Comsume时，创建唯一字符串（消费者标签），标识应用程序。RabbitMQ每次都会把该字符串和消息一同发送给应用程序。<br>客户端库对消费者标签封装，以确定如何处理消息。开发者不用处理消费者标签。</p>\n<p>示例代码：监听消息直到，收到停止消息</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        for message in rabbitpy.Queue(channel, &#39;test-messages&#39;):\n            message.pprint()\n            message.ack()\n            if message.body == &#39;stop&#39;:\n                break</code></pre>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a><strong>对比</strong></h3><p>Consume吞吐量更大。Get包含了每条消息的同步通信开销。</p>\n<hr>\n<h2 id=\"消费性能优化\"><a href=\"#消费性能优化\" class=\"headerlink\" title=\"消费性能优化\"></a>消费性能优化</h2><hr>\n<h3 id=\"1、no-ack\"><a href=\"#1、no-ack\" class=\"headerlink\" title=\"1、no-ack\"></a>1、no-ack</h3><p>应用程序发送Basic.Comsume请求时，设置no-ack。表明消费者不进行消费确认。</p>\n<p>示例代码：消费不确认</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;test-messages&#39;)\n        for message in queue.consume_messages(no_ack=True):\n            message.pprint()</code></pre><h3 id=\"2、预取\"><a href=\"#2、预取\" class=\"headerlink\" title=\"2、预取\"></a>2、预取</h3><p>QoS（Quality of service）中，可设置消费者预先接收一定数量的消息。Basic.Qos一般在Basic.Consume之前设置。</p>\n<p>示例程序：指定QoS</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        #预取数为10\n        channel.prefetch_count(10)\n        for message in rabbitpy.Queue(channel, &#39;test-messages&#39;):\n            message.pprint()\n            message.ack()</code></pre>\n<p>应用程序不需要确认每条消息，可确认所有以前未读消息。</p>\n<p>示例程序：多消息确认</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        channel.prefetch_count(10)\n        for message in rabbitpy.Queue(channel, &#39;test-messages&#39;):\n            message.pprint()\n            unacknowledged += 1\n            if unacknowledged == 10:\n                # 确认所有未确认消息\n                message.ack(all_previous=True)\n                unacknowledged = 0\n</code></pre>\n<h3 id=\"3、事务\"><a href=\"#3、事务\" class=\"headerlink\" title=\"3、事务\"></a>3、事务</h3><p>事务允许消费者应用程序提交和回滚批量操作。不适用QoS时，可以获得轻微的性能提升。</p>\n<hr>\n<h2 id=\"拒绝消息\"><a href=\"#拒绝消息\" class=\"headerlink\" title=\"拒绝消息\"></a>拒绝消息</h2><hr>\n<h3 id=\"Basic-Reject\"><a href=\"#Basic-Reject\" class=\"headerlink\" title=\"Basic.Reject\"></a>Basic.Reject</h3><p>通知rabbitmq无法处理投递的消息（拒绝一个消息），可指示rabbitMQ丢弃消息或使用requeue重发消息。</p>\n<p>示例程序：消息拒绝</p>\n<pre><code>import rabbitpy\n\nfor message in rabbitpy.consume(&#39;amqp://guest:guest@localhost:5672/%2f&#39;,\n                                &#39;test-messages&#39;):\n    message.pprint()\n    print(&#39;Redelivered: %s&#39; % message.redelivered)\n    message.reject(True)</code></pre><h3 id=\"Basic-Nack\"><a href=\"#Basic-Nack\" class=\"headerlink\" title=\"Basic.Nack\"></a>Basic.Nack</h3><p>同时拒绝多个消息</p>\n<h3 id=\"死信交换器（DLX）\"><a href=\"#死信交换器（DLX）\" class=\"headerlink\" title=\"死信交换器（DLX）\"></a>死信交换器（DLX）</h3><p>创建队列时声明该交换器用于保存被拒绝的消息。队列x-dead-letter-exchange参数(RPC请求)指定死信交换器。</p>\n<p>示例程序：指定死信交换器</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        #死信交换器\n        rabbitpy.Exchange(channel, &#39;rejected-messages&#39;).declare()\n        queue = rabbitpy.Queue(channel, &#39;dlx-example&#39;,\n                               dead_letter_exchange=&#39;rejected-messages&#39;)\n        queue.declare()\n</code></pre>\n<hr>\n<h2 id=\"控制队列\"><a href=\"#控制队列\" class=\"headerlink\" title=\"控制队列\"></a>控制队列</h2><hr>\n<h3 id=\"临时队列\"><a href=\"#临时队列\" class=\"headerlink\" title=\"临时队列\"></a>临时队列</h3><p><strong>自动删除队列</strong><br>消费者完成连接和检索消息，所有消费者断开连接时，队列将被删除。</p>\n<p>示例程序：自动删除队列auto_delete=True</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;ad-example&#39;, auto_delete=True)\n        queue.declare()</code></pre><p><strong>只允许单个消费者</strong><br>只有单个消费者能够消费队列中的消息。消费者断开连接后，会自动删除队列。</p>\n<p>示例程序：独占队列exclusive</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;exclusive-example&#39;,\n                               exclusive=True)\n        queue.declare()</code></pre><p><strong>自动过期队列</strong><br>如果一段时间没有使用该队列就删除它，一般用于RPC回复队列。</p>\n<p>示例程序：自动过期队列</p>\n<pre><code>import rabbitpy\nimport time\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;expiring-queue&#39;,\n                               arguments={&#39;x-expires&#39;: 1000})\n        queue.declare()\n        messages, consumers = queue.declare(passive=True)\n        time.sleep(2)\n        try:\n            messages, consumers = queue.declare(passive=True)\n        except rabbitpy.exceptions.AMQPNotFound:\n            print(&#39;The queue no longer exists&#39;)</code></pre><h3 id=\"永久队列\"><a href=\"#永久队列\" class=\"headerlink\" title=\"永久队列\"></a>永久队列</h3><p><strong>队列持久性</strong><br>服务器重启后队列仍然存在。<br>示例程序：持久队列</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;durable-queue&#39;,\n                               durable=True)\n        if queue.declare():\n            print(&#39;Queue declared&#39;)</code></pre><p><strong>队列消息自动过期</strong><br>同时指定死信交换器和消息TTL，过期消息将成为死信消息。</p>\n<p>示例程序：消息TTL</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;expiring-msg-queue&#39;,\n                               arguments={&#39;x-message-ttl&#39;: 1000})\n         queue.declare()\n</code></pre><p><strong>最大队列长度</strong><br>一旦达到最大值，添加新消息时，删除队列前端的消息。声明队列时，如果指定死信交换器，前端移除的消息将成为死信。</p>\n<p>示例程序：最大长度队列</p>\n<pre><code>import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        queue = rabbitpy.Queue(channel, &#39;max-length-queue&#39;,\n                               arguments={&#39;x-max-length&#39;: 1000})\n        queue.declare()\n</code></pre><h3 id=\"队列设置参数\"><a href=\"#队列设置参数\" class=\"headerlink\" title=\"队列设置参数\"></a>队列设置参数</h3><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>x-dead-letter-exchange</td>\n<td>死信交换器，路由不重发且被拒绝的消息</td>\n</tr>\n<tr>\n<td>x-dead-letter-routing-key</td>\n<td>死信消息的可选路由键</td>\n</tr>\n<tr>\n<td>x-expires</td>\n<td>队列在指定的毫秒数后删除</td>\n</tr>\n<tr>\n<td>x-ha-proxy</td>\n<td>创建HA队列</td>\n</tr>\n<tr>\n<td>x-ha-nodes</td>\n<td>HA队列分布的节点</td>\n</tr>\n<tr>\n<td>x-max-length</td>\n<td>队列的最大消息数</td>\n</tr>\n<tr>\n<td>x-message-ttl</td>\n<td>毫秒为单位的队列过期时间</td>\n</tr>\n<tr>\n<td>x-max-priority</td>\n<td>队列优先级排序</td>\n</tr>\n</tbody></table>\n"},{"title":"rabbitmq消息路由","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T14:15:04.000Z","password":null,"summary":null,"_content":"\n---\n[toc]\n\n------------\n\n## direct交换器\n\n------------\n\n### 特点\n- 投递的消息有一个或者多个确定的目标。\n- 检查字符串是否相等，不允许使用模式匹配。\n- 绑定相同路由键的队列都能收到该路由键对应的消息。\n- 适用于RPC消息通信模式下的路由应答消息\n\n示例代码：Direct交换器\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, 'direct-example',\n                                     exchange_type='direct')\n        exchange.declare()\n```\n\n### 示例场景\nRPC worker消费图片实现面部识别，将结果发回给消息发布方。\n\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211436091-1891495455.jpg)\n\n\n\n- 客户端应用程序上传图像\n- 应用程序处理请求，用唯一ID标识远程请求并创建一条消息\n- 图像发布到交换器，消息属性的reply-to对应相应队列的名称, correlation-id对应请求ID\n- 消息路由到队列，\n- 消费者消费队列中的消息\n- 结果以RPC请求形式返回前端。\n\n注意：RabbitMQ最大帧大小为131072字节，，消息体超过这个大小，就需要在AMQP协议级别分块。预先分配占用7字节，因此，每个消息体帧只能承载131065字节图片数据。\n\n示例代码：RPC Publisher\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import utils\n\n# Open the channel and connection\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\nexchange = rabbitpy.DirectExchange(channel, 'rpc-replies')\nexchange.declare()\n\n# Create the response queue that will automatically delete, is not durable and\n# is exclusive to this publisher\nqueue_name = 'response-queue-%s' % os.getpid()\nresponse_queue = rabbitpy.Queue(channel,\n                                queue_name,\n                                auto_delete=True,\n                                durable=False,\n                                exclusive=True)\n# Declare the response queue\nif response_queue.declare():\n    print('Response queue declared')\n\n# Bind the response queue\nif response_queue.bind('rpc-replies', queue_name):\n    print('Response queue bound')\n\n# Iterate through the images to send RPC requests for\nfor img_id, filename in enumerate(utils.get_images()):\n\n    print('Sending request for image #%s: %s' % (img_id, filename))\n\n    # Create the message\n    message = rabbitpy.Message(channel,\n                               utils.read_image(filename),\n                               {'content_type': utils.mime_type(filename),\n                                'correlation_id': str(img_id),\n                                'reply_to': queue_name},\n                               opinionated=True)\n\n    # Pubish the message\n    message.publish('direct-rpc-requests', 'detect-faces')\n\n    # Loop until there is a response message\n    message = None\n    while not message:\n        time.sleep(0.5)\n        message = response_queue.get()\n\n    # Ack the response message\n    message.ack()\n\n    # Caculate how long it took from publish to response\n    duration = (time.time() -\n                time.mktime(message.properties['headers']['first_publish']))\n\n    print('Facial detection RPC call for image %s total duration: %s' %\n          (message.properties['correlation_id'], duration))\n\n    # Display the image in the IPython notebook interface\n    utils.display_image(message.body, message.properties['content_type'])\n\nprint('RPC requests processed')\n\n# Close the channel and connection\nchannel.close()\nconnection.close()\n\n```\n\n示例代码：RPC worker\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import detect\nfrom ch6 import utils\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = 'rpc-worker-%s' % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print('Worker queue declared')\n\n# Bind the worker queue\nif queue.bind('direct-rpc-requests', 'detect-faces'):\n    print('Worker queue bound')\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Display how long it took for the message to get here\n    duration = time.time() - int(message.properties['timestamp'].strftime('%s'))\n    print('Received RPC request published %.2f seconds ago' % duration)\n\n    # Write out the message body to a temp file for facial detection process\n    temp_file = utils.write_temp_file(message.body,\n                                      message.properties['content_type'])\n\n    # Detect faces\n    result_file = detect.faces(temp_file)\n\n    # Build response properties including the timestamp from the first publish\n    properties = {'app_id': 'Chapter 6 Listing 2 Consumer',\n                  'content_type': message.properties['content_type'],\n                  'correlation_id': message.properties['correlation_id'],\n                  'headers': {\n                      'first_publish': message.properties['timestamp']}}\n\n    # The result file could just be the original image if nothing detected\n    body = utils.read_image(result_file)\n\n    # Remove the temp file\n    os.unlink(temp_file)\n\n    # Remove the result file\n    os.unlink(result_file)\n\n    # Publish the response response\n    response = rabbitpy.Message(channel, body, properties, opinionated=True)\n    response.publish('rpc-replies', message.properties['reply_to'])\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n\n```\n\n## fanout交换器\n\n### 特点\n\n- 所有发往fanout交换器中的消息会被投递到所有该交换器绑定的队列中。\n- 消息投递不需要检测路由键，性能更好\n\n示例代码\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel,\n                                    'fanout-rpc-requests',\n                                     exchange_type='fanout')\n        exchange.declare()\n```\n### 示例场景\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211416324-1179890043.jpg)\n\n\n\n\n示例程序：Publisher\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import utils\n\n# Open the channel and connection\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the response queue that will automatically delete, is not durable and\n# is exclusive to this publisher\nqueue_name = 'response-queue-%s' % os.getpid()\nresponse_queue = rabbitpy.Queue(channel,\n                                queue_name,\n                                auto_delete=True,\n                                durable=False,\n                                exclusive=True)\n# Declare the response queue\nif response_queue.declare():\n    print('Response queue declared')\n\n# Bind the response queue\nif response_queue.bind('rpc-replies', queue_name):\n    print('Response queue bound')\n\n# Iterate through the images to send RPC requests for\nfor img_id, filename in enumerate(utils.get_images()):\n\n    print 'Sending request for image #%s: %s' % (img_id, filename)\n\n    # Create the message\n    message = rabbitpy.Message(channel,\n                               utils.read_image(filename),\n                               {'content_type': utils.mime_type(filename),\n                                'correlation_id': str(img_id),\n                                'reply_to': queue_name},\n                               opinionated=True)\n\n    # Pubish the message\n    message.publish('fanout-rpc-requests')\n\n    # Loop until there is a response message\n    message = None\n    while not message:\n        time.sleep(0.5)\n        message = response_queue.get()\n\n    # Ack the response message\n    message.ack()\n\n    # Caculate how long it took from publish to response\n    duration = (time.time() -\n                time.mktime(message.properties['headers']['first_publish']))\n\n    print('Facial detection RPC call for image %s total duration: %s' %\n          (message.properties['correlation_id'], duration))\n\n    # Display the image in the IPython notebook interface\n    utils.display_image(message.body, message.properties['content_type'])\n\nprint 'RPC requests processed'\n\n# Close the channel and connection\nchannel.close()\nconnection.close()\n\n```\n\n示例程序：detect worker\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import detect\nfrom ch6 import utils\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = 'rpc-worker-%s' % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print('Worker queue declared')\n\n# Bind the worker queue\nif queue.bind('fanout-rpc-requests'):\n    print('Worker queue bound')\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Display how long it took for the message to get here\n    duration = time.time() - int(message.properties['timestamp'].strftime('%s'))\n    print('Received RPC request published %.2f seconds ago' % duration)\n\n    # Write out the message body to a temp file for facial detection process\n    temp_file = utils.write_temp_file(message.body,\n                                      message.properties['content_type'])\n\n    # Detect faces\n    result_file = detect.faces(temp_file)\n\n    # Build response properties including the timestamp from the first publish\n    properties = {'app_id': 'Chapter 6 Listing 2 Consumer',\n                  'content_type': message.properties['content_type'],\n                  'correlation_id': message.properties['correlation_id'],\n                  'headers': {\n                      'first_publish': message.properties['timestamp']}}\n\n    # The result file could just be the original image if nothing detected\n    body = utils.read_image(result_file)\n\n    # Remove the temp file\n    os.unlink(temp_file)\n\n    # Remove the result file\n    os.unlink(result_file)\n\n    # Publish the response response\n    response = rabbitpy.Message(channel, body, properties)\n    response.publish('rpc-replies', message.properties['reply_to'])\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n\n```\n\n示例程序：Hash Consumer\n```python\nimport os\nimport hashlib\nimport rabbitpy\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = 'hashing-worker-%s' % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print('Worker queue declared')\n\n# Bind the worker queue\nif queue.bind('fanout-rpc-requests'):\n    print('Worker queue bound')\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Create the hashing object\n    hash_obj = hashlib.md5(message.body)\n\n    # Print out the info, this might go into a database or log file\n    print('Image with correlation-id of %s has a hash of %s' %\n          (message.properties['correlation_id'],\n           hash_obj.hexdigest()))\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n\n```\n\n\n## topic交换器\n\n### 特点\n\n- 消息会被投递到匹配路由键的队列中（*匹配下一.之前的所有字符,#匹配所有字符）。\n\n### 示例场景\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211241462-186905715.jpg)\n\n\n\n## headers交换器\n\n### 特点\n\n- 使用消息属性中的headers属性匹配。\n- queue.bind，x-match指定匹配策略，其他参数表示绑定值\n- 绑定策略可能会使得性能降低\n\n示例代码\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel,\n                                     'headers-rpc-requests',\n                                     exchange_type='headers')\n        exchange.declare()\n\n```\n\n示例程序：publisher\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import utils\n\n# Open the channel and connection\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the response queue that will automatically delete, is not durable and\n# is exclusive to this publisher\nqueue_name = 'response-queue-%s' % os.getpid()\nresponse_queue = rabbitpy.Queue(channel,\n                                queue_name,\n                                auto_delete=True,\n                                durable=False,\n                                exclusive=True)\n# Declare the response queue\nif response_queue.declare():\n    print('Response queue declared')\n\n# Bind the response queue\nif response_queue.bind('rpc-replies', queue_name):\n    print('Response queue bound')\n\n# Iterate through the images to send RPC requests for\nfor img_id, filename in enumerate(utils.get_images()):\n\n    print('Sending request for image #%s: %s' % (img_id, filename))\n\n    # Create the message\n    message = rabbitpy.Message(channel,\n                               utils.read_image(filename),\n                               {'content_type': utils.mime_type(filename),\n                                'correlation_id': str(img_id),\n                                'headers': {'source': 'profile',\n                                            'object': 'image',\n                                            'action': 'new'},\n                                'reply_to': queue_name},\n                               opinionated=True)\n\n    # Pubish the message\n    message.publish('headers-rpc-requests')\n\n    # Loop until there is a response message\n    message = None\n    while not message:\n        time.sleep(0.5)\n        message = response_queue.get()\n\n    # Ack the response message\n    message.ack()\n\n    # Caculate how long it took from publish to response\n    duration = (time.time() -\n                time.mktime(message.properties['headers']['first_publish']))\n\n    print('Facial detection RPC call for image %s total duration: %s' %\n          (message.properties['correlation_id'], duration))\n\n    # Display the image in the IPython notebook interface\n    utils.display_image(message.body, message.properties['content_type'])\n\nprint('RPC requests processed')\n\n# Close the channel and connection\nchannel.close()\nconnection.close()\n\n```\n\n\n示例程序：worker\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import detect\nfrom ch6 import utils\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = 'rpc-worker-%s' % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print('Worker queue declared')\n\n# Bind the worker queue\nif queue.bind('headers-rpc-requests',\n              arguments={'x-match': 'all',\n                         'source': 'profile',\n                         'object': 'image',\n                         'action': 'new'}):\n    print('Worker queue bound')\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Display how long it took for the message to get here\n    duration = time.time() - int(message.properties['timestamp'].strftime('%s'))\n    print('Received RPC request published %.2f seconds ago' % duration)\n\n    # Write out the message body to a temp file for facial detection process\n    temp_file = utils.write_temp_file(message.body,\n                                      message.properties['content_type'])\n\n    # Detect faces\n    result_file = detect.faces(temp_file)\n\n    # Build response properties including the timestamp from the first publish\n    properties = {'app_id': 'Chapter 6 Listing 2 Consumer',\n                  'content_type': message.properties['content_type'],\n                  'correlation_id': message.properties['correlation_id'],\n                  'headers': {\n                      'first_publish': message.properties['timestamp']}}\n\n    # The result file could just be the original image if nothing detected\n    body = utils.read_image(result_file)\n\n    # Remove the temp file\n    os.unlink(temp_file)\n\n    # Remove the result file\n    os.unlink(result_file)\n\n    # Publish the response response\n    response = rabbitpy.Message(channel, body, properties, opinionated=True)\n    response.publish('rpc-replies', message.properties['reply_to'])\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n\n```\n\n## 交换器路由\n\n交换器间绑定，使用RPC方法Exchange.Bind。\n\n### 示例场景\n\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211108563-1049881640.jpg)\n\n\n示例代码：\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        tpc = rabbitpy.Exchange(channel, 'events',\n                                exchange_type='topic')\n        tpc.declare()\n        xch = rabbitpy.Exchange(channel, 'distributed-events',\n                                exchange_type='x-consistent-hash')\n        xch.declare()\n        xch.bind(foo, '#')\n```\n\n\n## 一致性哈希交换器\n\n用于消息队列的负载均衡，可以提升吞吐量\n\n### 示例场景\n\n\n示例代码：采用路由键的哈希值来分发消息\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, 'image-storage',\n                                     exchange_type='x-consistent-hash')\n        exchange.declare()\n```\n\n示例代码：header中的属性值作为哈希值\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, 'image-storage',\n                                     exchange_type='x-consistent-hash',\n                                     arguments={'hash-header': 'image-hash'})\n        exchange.declare()\n\n```\n\n示例代码：队列的创建与绑定\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        for queue_num in range(4):\n            queue = rabbitpy.Queue (channel, 'server%s' % queue_num)\n            queue.declare()\n            queue.bind('image-storage', '10')\n```","source":"_posts/rabbitmq消息路由.md","raw":"---\ntitle: rabbitmq消息路由\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 22:15:04\npassword:\nsummary:\ntags:\n- rabbitmq\ncategories:\n- rabbitmq\n---\n\n---\n[toc]\n\n------------\n\n## direct交换器\n\n------------\n\n### 特点\n- 投递的消息有一个或者多个确定的目标。\n- 检查字符串是否相等，不允许使用模式匹配。\n- 绑定相同路由键的队列都能收到该路由键对应的消息。\n- 适用于RPC消息通信模式下的路由应答消息\n\n示例代码：Direct交换器\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, 'direct-example',\n                                     exchange_type='direct')\n        exchange.declare()\n```\n\n### 示例场景\nRPC worker消费图片实现面部识别，将结果发回给消息发布方。\n\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211436091-1891495455.jpg)\n\n\n\n- 客户端应用程序上传图像\n- 应用程序处理请求，用唯一ID标识远程请求并创建一条消息\n- 图像发布到交换器，消息属性的reply-to对应相应队列的名称, correlation-id对应请求ID\n- 消息路由到队列，\n- 消费者消费队列中的消息\n- 结果以RPC请求形式返回前端。\n\n注意：RabbitMQ最大帧大小为131072字节，，消息体超过这个大小，就需要在AMQP协议级别分块。预先分配占用7字节，因此，每个消息体帧只能承载131065字节图片数据。\n\n示例代码：RPC Publisher\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import utils\n\n# Open the channel and connection\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\nexchange = rabbitpy.DirectExchange(channel, 'rpc-replies')\nexchange.declare()\n\n# Create the response queue that will automatically delete, is not durable and\n# is exclusive to this publisher\nqueue_name = 'response-queue-%s' % os.getpid()\nresponse_queue = rabbitpy.Queue(channel,\n                                queue_name,\n                                auto_delete=True,\n                                durable=False,\n                                exclusive=True)\n# Declare the response queue\nif response_queue.declare():\n    print('Response queue declared')\n\n# Bind the response queue\nif response_queue.bind('rpc-replies', queue_name):\n    print('Response queue bound')\n\n# Iterate through the images to send RPC requests for\nfor img_id, filename in enumerate(utils.get_images()):\n\n    print('Sending request for image #%s: %s' % (img_id, filename))\n\n    # Create the message\n    message = rabbitpy.Message(channel,\n                               utils.read_image(filename),\n                               {'content_type': utils.mime_type(filename),\n                                'correlation_id': str(img_id),\n                                'reply_to': queue_name},\n                               opinionated=True)\n\n    # Pubish the message\n    message.publish('direct-rpc-requests', 'detect-faces')\n\n    # Loop until there is a response message\n    message = None\n    while not message:\n        time.sleep(0.5)\n        message = response_queue.get()\n\n    # Ack the response message\n    message.ack()\n\n    # Caculate how long it took from publish to response\n    duration = (time.time() -\n                time.mktime(message.properties['headers']['first_publish']))\n\n    print('Facial detection RPC call for image %s total duration: %s' %\n          (message.properties['correlation_id'], duration))\n\n    # Display the image in the IPython notebook interface\n    utils.display_image(message.body, message.properties['content_type'])\n\nprint('RPC requests processed')\n\n# Close the channel and connection\nchannel.close()\nconnection.close()\n\n```\n\n示例代码：RPC worker\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import detect\nfrom ch6 import utils\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = 'rpc-worker-%s' % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print('Worker queue declared')\n\n# Bind the worker queue\nif queue.bind('direct-rpc-requests', 'detect-faces'):\n    print('Worker queue bound')\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Display how long it took for the message to get here\n    duration = time.time() - int(message.properties['timestamp'].strftime('%s'))\n    print('Received RPC request published %.2f seconds ago' % duration)\n\n    # Write out the message body to a temp file for facial detection process\n    temp_file = utils.write_temp_file(message.body,\n                                      message.properties['content_type'])\n\n    # Detect faces\n    result_file = detect.faces(temp_file)\n\n    # Build response properties including the timestamp from the first publish\n    properties = {'app_id': 'Chapter 6 Listing 2 Consumer',\n                  'content_type': message.properties['content_type'],\n                  'correlation_id': message.properties['correlation_id'],\n                  'headers': {\n                      'first_publish': message.properties['timestamp']}}\n\n    # The result file could just be the original image if nothing detected\n    body = utils.read_image(result_file)\n\n    # Remove the temp file\n    os.unlink(temp_file)\n\n    # Remove the result file\n    os.unlink(result_file)\n\n    # Publish the response response\n    response = rabbitpy.Message(channel, body, properties, opinionated=True)\n    response.publish('rpc-replies', message.properties['reply_to'])\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n\n```\n\n## fanout交换器\n\n### 特点\n\n- 所有发往fanout交换器中的消息会被投递到所有该交换器绑定的队列中。\n- 消息投递不需要检测路由键，性能更好\n\n示例代码\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel,\n                                    'fanout-rpc-requests',\n                                     exchange_type='fanout')\n        exchange.declare()\n```\n### 示例场景\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211416324-1179890043.jpg)\n\n\n\n\n示例程序：Publisher\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import utils\n\n# Open the channel and connection\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the response queue that will automatically delete, is not durable and\n# is exclusive to this publisher\nqueue_name = 'response-queue-%s' % os.getpid()\nresponse_queue = rabbitpy.Queue(channel,\n                                queue_name,\n                                auto_delete=True,\n                                durable=False,\n                                exclusive=True)\n# Declare the response queue\nif response_queue.declare():\n    print('Response queue declared')\n\n# Bind the response queue\nif response_queue.bind('rpc-replies', queue_name):\n    print('Response queue bound')\n\n# Iterate through the images to send RPC requests for\nfor img_id, filename in enumerate(utils.get_images()):\n\n    print 'Sending request for image #%s: %s' % (img_id, filename)\n\n    # Create the message\n    message = rabbitpy.Message(channel,\n                               utils.read_image(filename),\n                               {'content_type': utils.mime_type(filename),\n                                'correlation_id': str(img_id),\n                                'reply_to': queue_name},\n                               opinionated=True)\n\n    # Pubish the message\n    message.publish('fanout-rpc-requests')\n\n    # Loop until there is a response message\n    message = None\n    while not message:\n        time.sleep(0.5)\n        message = response_queue.get()\n\n    # Ack the response message\n    message.ack()\n\n    # Caculate how long it took from publish to response\n    duration = (time.time() -\n                time.mktime(message.properties['headers']['first_publish']))\n\n    print('Facial detection RPC call for image %s total duration: %s' %\n          (message.properties['correlation_id'], duration))\n\n    # Display the image in the IPython notebook interface\n    utils.display_image(message.body, message.properties['content_type'])\n\nprint 'RPC requests processed'\n\n# Close the channel and connection\nchannel.close()\nconnection.close()\n\n```\n\n示例程序：detect worker\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import detect\nfrom ch6 import utils\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = 'rpc-worker-%s' % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print('Worker queue declared')\n\n# Bind the worker queue\nif queue.bind('fanout-rpc-requests'):\n    print('Worker queue bound')\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Display how long it took for the message to get here\n    duration = time.time() - int(message.properties['timestamp'].strftime('%s'))\n    print('Received RPC request published %.2f seconds ago' % duration)\n\n    # Write out the message body to a temp file for facial detection process\n    temp_file = utils.write_temp_file(message.body,\n                                      message.properties['content_type'])\n\n    # Detect faces\n    result_file = detect.faces(temp_file)\n\n    # Build response properties including the timestamp from the first publish\n    properties = {'app_id': 'Chapter 6 Listing 2 Consumer',\n                  'content_type': message.properties['content_type'],\n                  'correlation_id': message.properties['correlation_id'],\n                  'headers': {\n                      'first_publish': message.properties['timestamp']}}\n\n    # The result file could just be the original image if nothing detected\n    body = utils.read_image(result_file)\n\n    # Remove the temp file\n    os.unlink(temp_file)\n\n    # Remove the result file\n    os.unlink(result_file)\n\n    # Publish the response response\n    response = rabbitpy.Message(channel, body, properties)\n    response.publish('rpc-replies', message.properties['reply_to'])\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n\n```\n\n示例程序：Hash Consumer\n```python\nimport os\nimport hashlib\nimport rabbitpy\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = 'hashing-worker-%s' % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print('Worker queue declared')\n\n# Bind the worker queue\nif queue.bind('fanout-rpc-requests'):\n    print('Worker queue bound')\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Create the hashing object\n    hash_obj = hashlib.md5(message.body)\n\n    # Print out the info, this might go into a database or log file\n    print('Image with correlation-id of %s has a hash of %s' %\n          (message.properties['correlation_id'],\n           hash_obj.hexdigest()))\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n\n```\n\n\n## topic交换器\n\n### 特点\n\n- 消息会被投递到匹配路由键的队列中（*匹配下一.之前的所有字符,#匹配所有字符）。\n\n### 示例场景\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211241462-186905715.jpg)\n\n\n\n## headers交换器\n\n### 特点\n\n- 使用消息属性中的headers属性匹配。\n- queue.bind，x-match指定匹配策略，其他参数表示绑定值\n- 绑定策略可能会使得性能降低\n\n示例代码\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel,\n                                     'headers-rpc-requests',\n                                     exchange_type='headers')\n        exchange.declare()\n\n```\n\n示例程序：publisher\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import utils\n\n# Open the channel and connection\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the response queue that will automatically delete, is not durable and\n# is exclusive to this publisher\nqueue_name = 'response-queue-%s' % os.getpid()\nresponse_queue = rabbitpy.Queue(channel,\n                                queue_name,\n                                auto_delete=True,\n                                durable=False,\n                                exclusive=True)\n# Declare the response queue\nif response_queue.declare():\n    print('Response queue declared')\n\n# Bind the response queue\nif response_queue.bind('rpc-replies', queue_name):\n    print('Response queue bound')\n\n# Iterate through the images to send RPC requests for\nfor img_id, filename in enumerate(utils.get_images()):\n\n    print('Sending request for image #%s: %s' % (img_id, filename))\n\n    # Create the message\n    message = rabbitpy.Message(channel,\n                               utils.read_image(filename),\n                               {'content_type': utils.mime_type(filename),\n                                'correlation_id': str(img_id),\n                                'headers': {'source': 'profile',\n                                            'object': 'image',\n                                            'action': 'new'},\n                                'reply_to': queue_name},\n                               opinionated=True)\n\n    # Pubish the message\n    message.publish('headers-rpc-requests')\n\n    # Loop until there is a response message\n    message = None\n    while not message:\n        time.sleep(0.5)\n        message = response_queue.get()\n\n    # Ack the response message\n    message.ack()\n\n    # Caculate how long it took from publish to response\n    duration = (time.time() -\n                time.mktime(message.properties['headers']['first_publish']))\n\n    print('Facial detection RPC call for image %s total duration: %s' %\n          (message.properties['correlation_id'], duration))\n\n    # Display the image in the IPython notebook interface\n    utils.display_image(message.body, message.properties['content_type'])\n\nprint('RPC requests processed')\n\n# Close the channel and connection\nchannel.close()\nconnection.close()\n\n```\n\n\n示例程序：worker\n```python\nimport os\nimport rabbitpy\nimport time\nfrom ch6 import detect\nfrom ch6 import utils\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = 'rpc-worker-%s' % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print('Worker queue declared')\n\n# Bind the worker queue\nif queue.bind('headers-rpc-requests',\n              arguments={'x-match': 'all',\n                         'source': 'profile',\n                         'object': 'image',\n                         'action': 'new'}):\n    print('Worker queue bound')\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Display how long it took for the message to get here\n    duration = time.time() - int(message.properties['timestamp'].strftime('%s'))\n    print('Received RPC request published %.2f seconds ago' % duration)\n\n    # Write out the message body to a temp file for facial detection process\n    temp_file = utils.write_temp_file(message.body,\n                                      message.properties['content_type'])\n\n    # Detect faces\n    result_file = detect.faces(temp_file)\n\n    # Build response properties including the timestamp from the first publish\n    properties = {'app_id': 'Chapter 6 Listing 2 Consumer',\n                  'content_type': message.properties['content_type'],\n                  'correlation_id': message.properties['correlation_id'],\n                  'headers': {\n                      'first_publish': message.properties['timestamp']}}\n\n    # The result file could just be the original image if nothing detected\n    body = utils.read_image(result_file)\n\n    # Remove the temp file\n    os.unlink(temp_file)\n\n    # Remove the result file\n    os.unlink(result_file)\n\n    # Publish the response response\n    response = rabbitpy.Message(channel, body, properties, opinionated=True)\n    response.publish('rpc-replies', message.properties['reply_to'])\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n\n```\n\n## 交换器路由\n\n交换器间绑定，使用RPC方法Exchange.Bind。\n\n### 示例场景\n\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211108563-1049881640.jpg)\n\n\n示例代码：\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        tpc = rabbitpy.Exchange(channel, 'events',\n                                exchange_type='topic')\n        tpc.declare()\n        xch = rabbitpy.Exchange(channel, 'distributed-events',\n                                exchange_type='x-consistent-hash')\n        xch.declare()\n        xch.bind(foo, '#')\n```\n\n\n## 一致性哈希交换器\n\n用于消息队列的负载均衡，可以提升吞吐量\n\n### 示例场景\n\n\n示例代码：采用路由键的哈希值来分发消息\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, 'image-storage',\n                                     exchange_type='x-consistent-hash')\n        exchange.declare()\n```\n\n示例代码：header中的属性值作为哈希值\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, 'image-storage',\n                                     exchange_type='x-consistent-hash',\n                                     arguments={'hash-header': 'image-hash'})\n        exchange.declare()\n\n```\n\n示例代码：队列的创建与绑定\n```python\nimport rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        for queue_num in range(4):\n            queue = rabbitpy.Queue (channel, 'server%s' % queue_num)\n            queue.declare()\n            queue.bind('image-storage', '10')\n```","slug":"rabbitmq消息路由","published":1,"updated":"2020-10-26T14:15:38.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w8r000ni4ufpn20k8gg","content":"<hr>\n<p>[toc]</p>\n<hr>\n<h2 id=\"direct交换器\"><a href=\"#direct交换器\" class=\"headerlink\" title=\"direct交换器\"></a>direct交换器</h2><hr>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>投递的消息有一个或者多个确定的目标。</li>\n<li>检查字符串是否相等，不允许使用模式匹配。</li>\n<li>绑定相同路由键的队列都能收到该路由键对应的消息。</li>\n<li>适用于RPC消息通信模式下的路由应答消息</li>\n</ul>\n<p>示例代码：Direct交换器</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        exchange <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'direct-example'</span><span class=\"token punctuation\">,</span>\n                                     exchange_type<span class=\"token operator\">=</span><span class=\"token string\">'direct'</span><span class=\"token punctuation\">)</span>\n        exchange<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p>RPC worker消费图片实现面部识别，将结果发回给消息发布方。</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211436091-1891495455.jpg\" alt></p>\n<ul>\n<li>客户端应用程序上传图像</li>\n<li>应用程序处理请求，用唯一ID标识远程请求并创建一条消息</li>\n<li>图像发布到交换器，消息属性的reply-to对应相应队列的名称, correlation-id对应请求ID</li>\n<li>消息路由到队列，</li>\n<li>消费者消费队列中的消息</li>\n<li>结果以RPC请求形式返回前端。</li>\n</ul>\n<p>注意：RabbitMQ最大帧大小为131072字节，，消息体超过这个大小，就需要在AMQP协议级别分块。预先分配占用7字节，因此，每个消息体帧只能承载131065字节图片数据。</p>\n<p>示例代码：RPC Publisher</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">import</span> rabbitpy\n<span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">from</span> ch6 <span class=\"token keyword\">import</span> utils\n\n<span class=\"token comment\" spellcheck=\"true\"># Open the channel and connection</span>\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nchannel <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nexchange <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>DirectExchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'rpc-replies'</span><span class=\"token punctuation\">)</span>\nexchange<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Create the response queue that will automatically delete, is not durable and</span>\n<span class=\"token comment\" spellcheck=\"true\"># is exclusive to this publisher</span>\nqueue_name <span class=\"token operator\">=</span> <span class=\"token string\">'response-queue-%s'</span> <span class=\"token operator\">%</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nresponse_queue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                                queue_name<span class=\"token punctuation\">,</span>\n                                auto_delete<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n                                durable<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span>\n                                exclusive<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># Declare the response queue</span>\n<span class=\"token keyword\">if</span> response_queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Response queue declared'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Bind the response queue</span>\n<span class=\"token keyword\">if</span> response_queue<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token string\">'rpc-replies'</span><span class=\"token punctuation\">,</span> queue_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Response queue bound'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Iterate through the images to send RPC requests for</span>\n<span class=\"token keyword\">for</span> img_id<span class=\"token punctuation\">,</span> filename <span class=\"token keyword\">in</span> enumerate<span class=\"token punctuation\">(</span>utils<span class=\"token punctuation\">.</span>get_images<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Sending request for image #%s: %s'</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>img_id<span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Create the message</span>\n    message <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                               utils<span class=\"token punctuation\">.</span>read_image<span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                               <span class=\"token punctuation\">{</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> utils<span class=\"token punctuation\">.</span>mime_type<span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                <span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">:</span> str<span class=\"token punctuation\">(</span>img_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                <span class=\"token string\">'reply_to'</span><span class=\"token punctuation\">:</span> queue_name<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                               opinionated<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Pubish the message</span>\n    message<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'direct-rpc-requests'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'detect-faces'</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Loop until there is a response message</span>\n    message <span class=\"token operator\">=</span> None\n    <span class=\"token keyword\">while</span> <span class=\"token operator\">not</span> message<span class=\"token punctuation\">:</span>\n        time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span>\n        message <span class=\"token operator\">=</span> response_queue<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Ack the response message</span>\n    message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Caculate how long it took from publish to response</span>\n    duration <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span>\n                time<span class=\"token punctuation\">.</span>mktime<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'headers'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'first_publish'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Facial detection RPC call for image %s total duration: %s'</span> <span class=\"token operator\">%</span>\n          <span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Display the image in the IPython notebook interface</span>\n    utils<span class=\"token punctuation\">.</span>display_image<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'RPC requests processed'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Close the channel and connection</span>\nchannel<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nconnection<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例代码：RPC worker</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">import</span> rabbitpy\n<span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">from</span> ch6 <span class=\"token keyword\">import</span> detect\n<span class=\"token keyword\">from</span> ch6 <span class=\"token keyword\">import</span> utils\n\n<span class=\"token comment\" spellcheck=\"true\"># Open the connection and the channel</span>\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nchannel <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Create the worker queue</span>\nqueue_name <span class=\"token operator\">=</span> <span class=\"token string\">'rpc-worker-%s'</span> <span class=\"token operator\">%</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nqueue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> queue_name<span class=\"token punctuation\">,</span>\n                       auto_delete<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n                       durable<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span>\n                       exclusive<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Declare the worker queue</span>\n<span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Worker queue declared'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Bind the worker queue</span>\n<span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token string\">'direct-rpc-requests'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'detect-faces'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Worker queue bound'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Consume messages from RabbitMQ</span>\n<span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> queue<span class=\"token punctuation\">.</span>consume_messages<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Display how long it took for the message to get here</span>\n    duration <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> int<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'timestamp'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>strftime<span class=\"token punctuation\">(</span><span class=\"token string\">'%s'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Received RPC request published %.2f seconds ago'</span> <span class=\"token operator\">%</span> duration<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Write out the message body to a temp file for facial detection process</span>\n    temp_file <span class=\"token operator\">=</span> utils<span class=\"token punctuation\">.</span>write_temp_file<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span>\n                                      message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Detect faces</span>\n    result_file <span class=\"token operator\">=</span> detect<span class=\"token punctuation\">.</span>faces<span class=\"token punctuation\">(</span>temp_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Build response properties including the timestamp from the first publish</span>\n    properties <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'app_id'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'Chapter 6 Listing 2 Consumer'</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">:</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token string\">'headers'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n                      <span class=\"token string\">'first_publish'</span><span class=\"token punctuation\">:</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'timestamp'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># The result file could just be the original image if nothing detected</span>\n    body <span class=\"token operator\">=</span> utils<span class=\"token punctuation\">.</span>read_image<span class=\"token punctuation\">(</span>result_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Remove the temp file</span>\n    os<span class=\"token punctuation\">.</span>unlink<span class=\"token punctuation\">(</span>temp_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Remove the result file</span>\n    os<span class=\"token punctuation\">.</span>unlink<span class=\"token punctuation\">(</span>result_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Publish the response response</span>\n    response <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> body<span class=\"token punctuation\">,</span> properties<span class=\"token punctuation\">,</span> opinionated<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n    response<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'rpc-replies'</span><span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'reply_to'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Acknowledge the delivery of the RPC request message</span>\n    message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"fanout交换器\"><a href=\"#fanout交换器\" class=\"headerlink\" title=\"fanout交换器\"></a>fanout交换器</h2><h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>所有发往fanout交换器中的消息会被投递到所有该交换器绑定的队列中。</li>\n<li>消息投递不需要检测路由键，性能更好</li>\n</ul>\n<p>示例代码</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        exchange <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                                    <span class=\"token string\">'fanout-rpc-requests'</span><span class=\"token punctuation\">,</span>\n                                     exchange_type<span class=\"token operator\">=</span><span class=\"token string\">'fanout'</span><span class=\"token punctuation\">)</span>\n        exchange<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"示例场景-1\"><a href=\"#示例场景-1\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211416324-1179890043.jpg\" alt></p>\n<p>示例程序：Publisher</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">import</span> rabbitpy\n<span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">from</span> ch6 <span class=\"token keyword\">import</span> utils\n\n<span class=\"token comment\" spellcheck=\"true\"># Open the channel and connection</span>\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nchannel <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Create the response queue that will automatically delete, is not durable and</span>\n<span class=\"token comment\" spellcheck=\"true\"># is exclusive to this publisher</span>\nqueue_name <span class=\"token operator\">=</span> <span class=\"token string\">'response-queue-%s'</span> <span class=\"token operator\">%</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nresponse_queue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                                queue_name<span class=\"token punctuation\">,</span>\n                                auto_delete<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n                                durable<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span>\n                                exclusive<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># Declare the response queue</span>\n<span class=\"token keyword\">if</span> response_queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Response queue declared'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Bind the response queue</span>\n<span class=\"token keyword\">if</span> response_queue<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token string\">'rpc-replies'</span><span class=\"token punctuation\">,</span> queue_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Response queue bound'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Iterate through the images to send RPC requests for</span>\n<span class=\"token keyword\">for</span> img_id<span class=\"token punctuation\">,</span> filename <span class=\"token keyword\">in</span> enumerate<span class=\"token punctuation\">(</span>utils<span class=\"token punctuation\">.</span>get_images<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token keyword\">print</span> <span class=\"token string\">'Sending request for image #%s: %s'</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>img_id<span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Create the message</span>\n    message <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                               utils<span class=\"token punctuation\">.</span>read_image<span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                               <span class=\"token punctuation\">{</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> utils<span class=\"token punctuation\">.</span>mime_type<span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                <span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">:</span> str<span class=\"token punctuation\">(</span>img_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                <span class=\"token string\">'reply_to'</span><span class=\"token punctuation\">:</span> queue_name<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                               opinionated<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Pubish the message</span>\n    message<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'fanout-rpc-requests'</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Loop until there is a response message</span>\n    message <span class=\"token operator\">=</span> None\n    <span class=\"token keyword\">while</span> <span class=\"token operator\">not</span> message<span class=\"token punctuation\">:</span>\n        time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span>\n        message <span class=\"token operator\">=</span> response_queue<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Ack the response message</span>\n    message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Caculate how long it took from publish to response</span>\n    duration <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span>\n                time<span class=\"token punctuation\">.</span>mktime<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'headers'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'first_publish'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Facial detection RPC call for image %s total duration: %s'</span> <span class=\"token operator\">%</span>\n          <span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Display the image in the IPython notebook interface</span>\n    utils<span class=\"token punctuation\">.</span>display_image<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span> <span class=\"token string\">'RPC requests processed'</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Close the channel and connection</span>\nchannel<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nconnection<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例程序：detect worker</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">import</span> rabbitpy\n<span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">from</span> ch6 <span class=\"token keyword\">import</span> detect\n<span class=\"token keyword\">from</span> ch6 <span class=\"token keyword\">import</span> utils\n\n<span class=\"token comment\" spellcheck=\"true\"># Open the connection and the channel</span>\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nchannel <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Create the worker queue</span>\nqueue_name <span class=\"token operator\">=</span> <span class=\"token string\">'rpc-worker-%s'</span> <span class=\"token operator\">%</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nqueue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> queue_name<span class=\"token punctuation\">,</span>\n                       auto_delete<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n                       durable<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span>\n                       exclusive<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Declare the worker queue</span>\n<span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Worker queue declared'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Bind the worker queue</span>\n<span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token string\">'fanout-rpc-requests'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Worker queue bound'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Consume messages from RabbitMQ</span>\n<span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> queue<span class=\"token punctuation\">.</span>consume_messages<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Display how long it took for the message to get here</span>\n    duration <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> int<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'timestamp'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>strftime<span class=\"token punctuation\">(</span><span class=\"token string\">'%s'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Received RPC request published %.2f seconds ago'</span> <span class=\"token operator\">%</span> duration<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Write out the message body to a temp file for facial detection process</span>\n    temp_file <span class=\"token operator\">=</span> utils<span class=\"token punctuation\">.</span>write_temp_file<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span>\n                                      message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Detect faces</span>\n    result_file <span class=\"token operator\">=</span> detect<span class=\"token punctuation\">.</span>faces<span class=\"token punctuation\">(</span>temp_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Build response properties including the timestamp from the first publish</span>\n    properties <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'app_id'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'Chapter 6 Listing 2 Consumer'</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">:</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token string\">'headers'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n                      <span class=\"token string\">'first_publish'</span><span class=\"token punctuation\">:</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'timestamp'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># The result file could just be the original image if nothing detected</span>\n    body <span class=\"token operator\">=</span> utils<span class=\"token punctuation\">.</span>read_image<span class=\"token punctuation\">(</span>result_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Remove the temp file</span>\n    os<span class=\"token punctuation\">.</span>unlink<span class=\"token punctuation\">(</span>temp_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Remove the result file</span>\n    os<span class=\"token punctuation\">.</span>unlink<span class=\"token punctuation\">(</span>result_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Publish the response response</span>\n    response <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> body<span class=\"token punctuation\">,</span> properties<span class=\"token punctuation\">)</span>\n    response<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'rpc-replies'</span><span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'reply_to'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Acknowledge the delivery of the RPC request message</span>\n    message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例程序：Hash Consumer</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">import</span> hashlib\n<span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token comment\" spellcheck=\"true\"># Open the connection and the channel</span>\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nchannel <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Create the worker queue</span>\nqueue_name <span class=\"token operator\">=</span> <span class=\"token string\">'hashing-worker-%s'</span> <span class=\"token operator\">%</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nqueue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> queue_name<span class=\"token punctuation\">,</span>\n                       auto_delete<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n                       durable<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span>\n                       exclusive<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Declare the worker queue</span>\n<span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Worker queue declared'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Bind the worker queue</span>\n<span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token string\">'fanout-rpc-requests'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Worker queue bound'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Consume messages from RabbitMQ</span>\n<span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> queue<span class=\"token punctuation\">.</span>consume_messages<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Create the hashing object</span>\n    hash_obj <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>md5<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Print out the info, this might go into a database or log file</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Image with correlation-id of %s has a hash of %s'</span> <span class=\"token operator\">%</span>\n          <span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n           hash_obj<span class=\"token punctuation\">.</span>hexdigest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Acknowledge the delivery of the RPC request message</span>\n    message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"topic交换器\"><a href=\"#topic交换器\" class=\"headerlink\" title=\"topic交换器\"></a>topic交换器</h2><h3 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>消息会被投递到匹配路由键的队列中（*匹配下一.之前的所有字符,#匹配所有字符）。</li>\n</ul>\n<h3 id=\"示例场景-2\"><a href=\"#示例场景-2\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211241462-186905715.jpg\" alt></p>\n<h2 id=\"headers交换器\"><a href=\"#headers交换器\" class=\"headerlink\" title=\"headers交换器\"></a>headers交换器</h2><h3 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>使用消息属性中的headers属性匹配。</li>\n<li>queue.bind，x-match指定匹配策略，其他参数表示绑定值</li>\n<li>绑定策略可能会使得性能降低</li>\n</ul>\n<p>示例代码</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        exchange <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                                     <span class=\"token string\">'headers-rpc-requests'</span><span class=\"token punctuation\">,</span>\n                                     exchange_type<span class=\"token operator\">=</span><span class=\"token string\">'headers'</span><span class=\"token punctuation\">)</span>\n        exchange<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例程序：publisher</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">import</span> rabbitpy\n<span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">from</span> ch6 <span class=\"token keyword\">import</span> utils\n\n<span class=\"token comment\" spellcheck=\"true\"># Open the channel and connection</span>\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nchannel <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Create the response queue that will automatically delete, is not durable and</span>\n<span class=\"token comment\" spellcheck=\"true\"># is exclusive to this publisher</span>\nqueue_name <span class=\"token operator\">=</span> <span class=\"token string\">'response-queue-%s'</span> <span class=\"token operator\">%</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nresponse_queue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                                queue_name<span class=\"token punctuation\">,</span>\n                                auto_delete<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n                                durable<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span>\n                                exclusive<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># Declare the response queue</span>\n<span class=\"token keyword\">if</span> response_queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Response queue declared'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Bind the response queue</span>\n<span class=\"token keyword\">if</span> response_queue<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token string\">'rpc-replies'</span><span class=\"token punctuation\">,</span> queue_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Response queue bound'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Iterate through the images to send RPC requests for</span>\n<span class=\"token keyword\">for</span> img_id<span class=\"token punctuation\">,</span> filename <span class=\"token keyword\">in</span> enumerate<span class=\"token punctuation\">(</span>utils<span class=\"token punctuation\">.</span>get_images<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Sending request for image #%s: %s'</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>img_id<span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Create the message</span>\n    message <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span>\n                               utils<span class=\"token punctuation\">.</span>read_image<span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                               <span class=\"token punctuation\">{</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> utils<span class=\"token punctuation\">.</span>mime_type<span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                <span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">:</span> str<span class=\"token punctuation\">(</span>img_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                                <span class=\"token string\">'headers'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'source'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'profile'</span><span class=\"token punctuation\">,</span>\n                                            <span class=\"token string\">'object'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'image'</span><span class=\"token punctuation\">,</span>\n                                            <span class=\"token string\">'action'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                                <span class=\"token string\">'reply_to'</span><span class=\"token punctuation\">:</span> queue_name<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                               opinionated<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Pubish the message</span>\n    message<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'headers-rpc-requests'</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Loop until there is a response message</span>\n    message <span class=\"token operator\">=</span> None\n    <span class=\"token keyword\">while</span> <span class=\"token operator\">not</span> message<span class=\"token punctuation\">:</span>\n        time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span>\n        message <span class=\"token operator\">=</span> response_queue<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Ack the response message</span>\n    message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Caculate how long it took from publish to response</span>\n    duration <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span>\n                time<span class=\"token punctuation\">.</span>mktime<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'headers'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'first_publish'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Facial detection RPC call for image %s total duration: %s'</span> <span class=\"token operator\">%</span>\n          <span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Display the image in the IPython notebook interface</span>\n    utils<span class=\"token punctuation\">.</span>display_image<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'RPC requests processed'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Close the channel and connection</span>\nchannel<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nconnection<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例程序：worker</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> os\n<span class=\"token keyword\">import</span> rabbitpy\n<span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">from</span> ch6 <span class=\"token keyword\">import</span> detect\n<span class=\"token keyword\">from</span> ch6 <span class=\"token keyword\">import</span> utils\n\n<span class=\"token comment\" spellcheck=\"true\"># Open the connection and the channel</span>\nconnection <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nchannel <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Create the worker queue</span>\nqueue_name <span class=\"token operator\">=</span> <span class=\"token string\">'rpc-worker-%s'</span> <span class=\"token operator\">%</span> os<span class=\"token punctuation\">.</span>getpid<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nqueue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> queue_name<span class=\"token punctuation\">,</span>\n                       auto_delete<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>\n                       durable<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span>\n                       exclusive<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Declare the worker queue</span>\n<span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Worker queue declared'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Bind the worker queue</span>\n<span class=\"token keyword\">if</span> queue<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token string\">'headers-rpc-requests'</span><span class=\"token punctuation\">,</span>\n              arguments<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token string\">'x-match'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'all'</span><span class=\"token punctuation\">,</span>\n                         <span class=\"token string\">'source'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'profile'</span><span class=\"token punctuation\">,</span>\n                         <span class=\"token string\">'object'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'image'</span><span class=\"token punctuation\">,</span>\n                         <span class=\"token string\">'action'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'new'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Worker queue bound'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># Consume messages from RabbitMQ</span>\n<span class=\"token keyword\">for</span> message <span class=\"token keyword\">in</span> queue<span class=\"token punctuation\">.</span>consume_messages<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Display how long it took for the message to get here</span>\n    duration <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> int<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'timestamp'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>strftime<span class=\"token punctuation\">(</span><span class=\"token string\">'%s'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Received RPC request published %.2f seconds ago'</span> <span class=\"token operator\">%</span> duration<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Write out the message body to a temp file for facial detection process</span>\n    temp_file <span class=\"token operator\">=</span> utils<span class=\"token punctuation\">.</span>write_temp_file<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span>\n                                      message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Detect faces</span>\n    result_file <span class=\"token operator\">=</span> detect<span class=\"token punctuation\">.</span>faces<span class=\"token punctuation\">(</span>temp_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Build response properties including the timestamp from the first publish</span>\n    properties <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'app_id'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'Chapter 6 Listing 2 Consumer'</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token string\">'content_type'</span><span class=\"token punctuation\">:</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'content_type'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">:</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'correlation_id'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                  <span class=\"token string\">'headers'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n                      <span class=\"token string\">'first_publish'</span><span class=\"token punctuation\">:</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'timestamp'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># The result file could just be the original image if nothing detected</span>\n    body <span class=\"token operator\">=</span> utils<span class=\"token punctuation\">.</span>read_image<span class=\"token punctuation\">(</span>result_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Remove the temp file</span>\n    os<span class=\"token punctuation\">.</span>unlink<span class=\"token punctuation\">(</span>temp_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Remove the result file</span>\n    os<span class=\"token punctuation\">.</span>unlink<span class=\"token punctuation\">(</span>result_file<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Publish the response response</span>\n    response <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> body<span class=\"token punctuation\">,</span> properties<span class=\"token punctuation\">,</span> opinionated<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n    response<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">'rpc-replies'</span><span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">[</span><span class=\"token string\">'reply_to'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Acknowledge the delivery of the RPC request message</span>\n    message<span class=\"token punctuation\">.</span>ack<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"交换器路由\"><a href=\"#交换器路由\" class=\"headerlink\" title=\"交换器路由\"></a>交换器路由</h2><p>交换器间绑定，使用RPC方法Exchange.Bind。</p>\n<h3 id=\"示例场景-3\"><a href=\"#示例场景-3\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211108563-1049881640.jpg\" alt></p>\n<p>示例代码：</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        tpc <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'events'</span><span class=\"token punctuation\">,</span>\n                                exchange_type<span class=\"token operator\">=</span><span class=\"token string\">'topic'</span><span class=\"token punctuation\">)</span>\n        tpc<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        xch <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'distributed-events'</span><span class=\"token punctuation\">,</span>\n                                exchange_type<span class=\"token operator\">=</span><span class=\"token string\">'x-consistent-hash'</span><span class=\"token punctuation\">)</span>\n        xch<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        xch<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> <span class=\"token string\">'#'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"一致性哈希交换器\"><a href=\"#一致性哈希交换器\" class=\"headerlink\" title=\"一致性哈希交换器\"></a>一致性哈希交换器</h2><p>用于消息队列的负载均衡，可以提升吞吐量</p>\n<h3 id=\"示例场景-4\"><a href=\"#示例场景-4\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p>示例代码：采用路由键的哈希值来分发消息</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        exchange <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'image-storage'</span><span class=\"token punctuation\">,</span>\n                                     exchange_type<span class=\"token operator\">=</span><span class=\"token string\">'x-consistent-hash'</span><span class=\"token punctuation\">)</span>\n        exchange<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例代码：header中的属性值作为哈希值</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        exchange <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Exchange<span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'image-storage'</span><span class=\"token punctuation\">,</span>\n                                     exchange_type<span class=\"token operator\">=</span><span class=\"token string\">'x-consistent-hash'</span><span class=\"token punctuation\">,</span>\n                                     arguments<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token string\">'hash-header'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'image-hash'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        exchange<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>示例代码：队列的创建与绑定</p>\n<pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> rabbitpy\n\n<span class=\"token keyword\">with</span> rabbitpy<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> connection<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">with</span> connection<span class=\"token punctuation\">.</span>channel<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> channel<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> queue_num <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            queue <span class=\"token operator\">=</span> rabbitpy<span class=\"token punctuation\">.</span>Queue <span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">,</span> <span class=\"token string\">'server%s'</span> <span class=\"token operator\">%</span> queue_num<span class=\"token punctuation\">)</span>\n            queue<span class=\"token punctuation\">.</span>declare<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            queue<span class=\"token punctuation\">.</span>bind<span class=\"token punctuation\">(</span><span class=\"token string\">'image-storage'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'10'</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<hr>\n<p>[toc]</p>\n<hr>\n<h2 id=\"direct交换器\"><a href=\"#direct交换器\" class=\"headerlink\" title=\"direct交换器\"></a>direct交换器</h2><hr>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>投递的消息有一个或者多个确定的目标。</li>\n<li>检查字符串是否相等，不允许使用模式匹配。</li>\n<li>绑定相同路由键的队列都能收到该路由键对应的消息。</li>\n<li>适用于RPC消息通信模式下的路由应答消息</li>\n</ul>\n<p>示例代码：Direct交换器</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, &#39;direct-example&#39;,\n                                     exchange_type=&#39;direct&#39;)\n        exchange.declare()</code></pre>\n<h3 id=\"示例场景\"><a href=\"#示例场景\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p>RPC worker消费图片实现面部识别，将结果发回给消息发布方。</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211436091-1891495455.jpg\" alt></p>\n<ul>\n<li>客户端应用程序上传图像</li>\n<li>应用程序处理请求，用唯一ID标识远程请求并创建一条消息</li>\n<li>图像发布到交换器，消息属性的reply-to对应相应队列的名称, correlation-id对应请求ID</li>\n<li>消息路由到队列，</li>\n<li>消费者消费队列中的消息</li>\n<li>结果以RPC请求形式返回前端。</li>\n</ul>\n<p>注意：RabbitMQ最大帧大小为131072字节，，消息体超过这个大小，就需要在AMQP协议级别分块。预先分配占用7字节，因此，每个消息体帧只能承载131065字节图片数据。</p>\n<p>示例代码：RPC Publisher</p>\n<pre><code class=\"python\">import os\nimport rabbitpy\nimport time\nfrom ch6 import utils\n\n# Open the channel and connection\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\nexchange = rabbitpy.DirectExchange(channel, &#39;rpc-replies&#39;)\nexchange.declare()\n\n# Create the response queue that will automatically delete, is not durable and\n# is exclusive to this publisher\nqueue_name = &#39;response-queue-%s&#39; % os.getpid()\nresponse_queue = rabbitpy.Queue(channel,\n                                queue_name,\n                                auto_delete=True,\n                                durable=False,\n                                exclusive=True)\n# Declare the response queue\nif response_queue.declare():\n    print(&#39;Response queue declared&#39;)\n\n# Bind the response queue\nif response_queue.bind(&#39;rpc-replies&#39;, queue_name):\n    print(&#39;Response queue bound&#39;)\n\n# Iterate through the images to send RPC requests for\nfor img_id, filename in enumerate(utils.get_images()):\n\n    print(&#39;Sending request for image #%s: %s&#39; % (img_id, filename))\n\n    # Create the message\n    message = rabbitpy.Message(channel,\n                               utils.read_image(filename),\n                               {&#39;content_type&#39;: utils.mime_type(filename),\n                                &#39;correlation_id&#39;: str(img_id),\n                                &#39;reply_to&#39;: queue_name},\n                               opinionated=True)\n\n    # Pubish the message\n    message.publish(&#39;direct-rpc-requests&#39;, &#39;detect-faces&#39;)\n\n    # Loop until there is a response message\n    message = None\n    while not message:\n        time.sleep(0.5)\n        message = response_queue.get()\n\n    # Ack the response message\n    message.ack()\n\n    # Caculate how long it took from publish to response\n    duration = (time.time() -\n                time.mktime(message.properties[&#39;headers&#39;][&#39;first_publish&#39;]))\n\n    print(&#39;Facial detection RPC call for image %s total duration: %s&#39; %\n          (message.properties[&#39;correlation_id&#39;], duration))\n\n    # Display the image in the IPython notebook interface\n    utils.display_image(message.body, message.properties[&#39;content_type&#39;])\n\nprint(&#39;RPC requests processed&#39;)\n\n# Close the channel and connection\nchannel.close()\nconnection.close()\n</code></pre>\n<p>示例代码：RPC worker</p>\n<pre><code class=\"python\">import os\nimport rabbitpy\nimport time\nfrom ch6 import detect\nfrom ch6 import utils\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = &#39;rpc-worker-%s&#39; % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print(&#39;Worker queue declared&#39;)\n\n# Bind the worker queue\nif queue.bind(&#39;direct-rpc-requests&#39;, &#39;detect-faces&#39;):\n    print(&#39;Worker queue bound&#39;)\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Display how long it took for the message to get here\n    duration = time.time() - int(message.properties[&#39;timestamp&#39;].strftime(&#39;%s&#39;))\n    print(&#39;Received RPC request published %.2f seconds ago&#39; % duration)\n\n    # Write out the message body to a temp file for facial detection process\n    temp_file = utils.write_temp_file(message.body,\n                                      message.properties[&#39;content_type&#39;])\n\n    # Detect faces\n    result_file = detect.faces(temp_file)\n\n    # Build response properties including the timestamp from the first publish\n    properties = {&#39;app_id&#39;: &#39;Chapter 6 Listing 2 Consumer&#39;,\n                  &#39;content_type&#39;: message.properties[&#39;content_type&#39;],\n                  &#39;correlation_id&#39;: message.properties[&#39;correlation_id&#39;],\n                  &#39;headers&#39;: {\n                      &#39;first_publish&#39;: message.properties[&#39;timestamp&#39;]}}\n\n    # The result file could just be the original image if nothing detected\n    body = utils.read_image(result_file)\n\n    # Remove the temp file\n    os.unlink(temp_file)\n\n    # Remove the result file\n    os.unlink(result_file)\n\n    # Publish the response response\n    response = rabbitpy.Message(channel, body, properties, opinionated=True)\n    response.publish(&#39;rpc-replies&#39;, message.properties[&#39;reply_to&#39;])\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n</code></pre>\n<h2 id=\"fanout交换器\"><a href=\"#fanout交换器\" class=\"headerlink\" title=\"fanout交换器\"></a>fanout交换器</h2><h3 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>所有发往fanout交换器中的消息会被投递到所有该交换器绑定的队列中。</li>\n<li>消息投递不需要检测路由键，性能更好</li>\n</ul>\n<p>示例代码</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel,\n                                    &#39;fanout-rpc-requests&#39;,\n                                     exchange_type=&#39;fanout&#39;)\n        exchange.declare()</code></pre>\n<h3 id=\"示例场景-1\"><a href=\"#示例场景-1\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211416324-1179890043.jpg\" alt></p>\n<p>示例程序：Publisher</p>\n<pre><code class=\"python\">import os\nimport rabbitpy\nimport time\nfrom ch6 import utils\n\n# Open the channel and connection\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the response queue that will automatically delete, is not durable and\n# is exclusive to this publisher\nqueue_name = &#39;response-queue-%s&#39; % os.getpid()\nresponse_queue = rabbitpy.Queue(channel,\n                                queue_name,\n                                auto_delete=True,\n                                durable=False,\n                                exclusive=True)\n# Declare the response queue\nif response_queue.declare():\n    print(&#39;Response queue declared&#39;)\n\n# Bind the response queue\nif response_queue.bind(&#39;rpc-replies&#39;, queue_name):\n    print(&#39;Response queue bound&#39;)\n\n# Iterate through the images to send RPC requests for\nfor img_id, filename in enumerate(utils.get_images()):\n\n    print &#39;Sending request for image #%s: %s&#39; % (img_id, filename)\n\n    # Create the message\n    message = rabbitpy.Message(channel,\n                               utils.read_image(filename),\n                               {&#39;content_type&#39;: utils.mime_type(filename),\n                                &#39;correlation_id&#39;: str(img_id),\n                                &#39;reply_to&#39;: queue_name},\n                               opinionated=True)\n\n    # Pubish the message\n    message.publish(&#39;fanout-rpc-requests&#39;)\n\n    # Loop until there is a response message\n    message = None\n    while not message:\n        time.sleep(0.5)\n        message = response_queue.get()\n\n    # Ack the response message\n    message.ack()\n\n    # Caculate how long it took from publish to response\n    duration = (time.time() -\n                time.mktime(message.properties[&#39;headers&#39;][&#39;first_publish&#39;]))\n\n    print(&#39;Facial detection RPC call for image %s total duration: %s&#39; %\n          (message.properties[&#39;correlation_id&#39;], duration))\n\n    # Display the image in the IPython notebook interface\n    utils.display_image(message.body, message.properties[&#39;content_type&#39;])\n\nprint &#39;RPC requests processed&#39;\n\n# Close the channel and connection\nchannel.close()\nconnection.close()\n</code></pre>\n<p>示例程序：detect worker</p>\n<pre><code class=\"python\">import os\nimport rabbitpy\nimport time\nfrom ch6 import detect\nfrom ch6 import utils\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = &#39;rpc-worker-%s&#39; % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print(&#39;Worker queue declared&#39;)\n\n# Bind the worker queue\nif queue.bind(&#39;fanout-rpc-requests&#39;):\n    print(&#39;Worker queue bound&#39;)\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Display how long it took for the message to get here\n    duration = time.time() - int(message.properties[&#39;timestamp&#39;].strftime(&#39;%s&#39;))\n    print(&#39;Received RPC request published %.2f seconds ago&#39; % duration)\n\n    # Write out the message body to a temp file for facial detection process\n    temp_file = utils.write_temp_file(message.body,\n                                      message.properties[&#39;content_type&#39;])\n\n    # Detect faces\n    result_file = detect.faces(temp_file)\n\n    # Build response properties including the timestamp from the first publish\n    properties = {&#39;app_id&#39;: &#39;Chapter 6 Listing 2 Consumer&#39;,\n                  &#39;content_type&#39;: message.properties[&#39;content_type&#39;],\n                  &#39;correlation_id&#39;: message.properties[&#39;correlation_id&#39;],\n                  &#39;headers&#39;: {\n                      &#39;first_publish&#39;: message.properties[&#39;timestamp&#39;]}}\n\n    # The result file could just be the original image if nothing detected\n    body = utils.read_image(result_file)\n\n    # Remove the temp file\n    os.unlink(temp_file)\n\n    # Remove the result file\n    os.unlink(result_file)\n\n    # Publish the response response\n    response = rabbitpy.Message(channel, body, properties)\n    response.publish(&#39;rpc-replies&#39;, message.properties[&#39;reply_to&#39;])\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n</code></pre>\n<p>示例程序：Hash Consumer</p>\n<pre><code class=\"python\">import os\nimport hashlib\nimport rabbitpy\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = &#39;hashing-worker-%s&#39; % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print(&#39;Worker queue declared&#39;)\n\n# Bind the worker queue\nif queue.bind(&#39;fanout-rpc-requests&#39;):\n    print(&#39;Worker queue bound&#39;)\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Create the hashing object\n    hash_obj = hashlib.md5(message.body)\n\n    # Print out the info, this might go into a database or log file\n    print(&#39;Image with correlation-id of %s has a hash of %s&#39; %\n          (message.properties[&#39;correlation_id&#39;],\n           hash_obj.hexdigest()))\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n</code></pre>\n<h2 id=\"topic交换器\"><a href=\"#topic交换器\" class=\"headerlink\" title=\"topic交换器\"></a>topic交换器</h2><h3 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>消息会被投递到匹配路由键的队列中（*匹配下一.之前的所有字符,#匹配所有字符）。</li>\n</ul>\n<h3 id=\"示例场景-2\"><a href=\"#示例场景-2\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211241462-186905715.jpg\" alt></p>\n<h2 id=\"headers交换器\"><a href=\"#headers交换器\" class=\"headerlink\" title=\"headers交换器\"></a>headers交换器</h2><h3 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>使用消息属性中的headers属性匹配。</li>\n<li>queue.bind，x-match指定匹配策略，其他参数表示绑定值</li>\n<li>绑定策略可能会使得性能降低</li>\n</ul>\n<p>示例代码</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel,\n                                     &#39;headers-rpc-requests&#39;,\n                                     exchange_type=&#39;headers&#39;)\n        exchange.declare()\n</code></pre>\n<p>示例程序：publisher</p>\n<pre><code class=\"python\">import os\nimport rabbitpy\nimport time\nfrom ch6 import utils\n\n# Open the channel and connection\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the response queue that will automatically delete, is not durable and\n# is exclusive to this publisher\nqueue_name = &#39;response-queue-%s&#39; % os.getpid()\nresponse_queue = rabbitpy.Queue(channel,\n                                queue_name,\n                                auto_delete=True,\n                                durable=False,\n                                exclusive=True)\n# Declare the response queue\nif response_queue.declare():\n    print(&#39;Response queue declared&#39;)\n\n# Bind the response queue\nif response_queue.bind(&#39;rpc-replies&#39;, queue_name):\n    print(&#39;Response queue bound&#39;)\n\n# Iterate through the images to send RPC requests for\nfor img_id, filename in enumerate(utils.get_images()):\n\n    print(&#39;Sending request for image #%s: %s&#39; % (img_id, filename))\n\n    # Create the message\n    message = rabbitpy.Message(channel,\n                               utils.read_image(filename),\n                               {&#39;content_type&#39;: utils.mime_type(filename),\n                                &#39;correlation_id&#39;: str(img_id),\n                                &#39;headers&#39;: {&#39;source&#39;: &#39;profile&#39;,\n                                            &#39;object&#39;: &#39;image&#39;,\n                                            &#39;action&#39;: &#39;new&#39;},\n                                &#39;reply_to&#39;: queue_name},\n                               opinionated=True)\n\n    # Pubish the message\n    message.publish(&#39;headers-rpc-requests&#39;)\n\n    # Loop until there is a response message\n    message = None\n    while not message:\n        time.sleep(0.5)\n        message = response_queue.get()\n\n    # Ack the response message\n    message.ack()\n\n    # Caculate how long it took from publish to response\n    duration = (time.time() -\n                time.mktime(message.properties[&#39;headers&#39;][&#39;first_publish&#39;]))\n\n    print(&#39;Facial detection RPC call for image %s total duration: %s&#39; %\n          (message.properties[&#39;correlation_id&#39;], duration))\n\n    # Display the image in the IPython notebook interface\n    utils.display_image(message.body, message.properties[&#39;content_type&#39;])\n\nprint(&#39;RPC requests processed&#39;)\n\n# Close the channel and connection\nchannel.close()\nconnection.close()\n</code></pre>\n<p>示例程序：worker</p>\n<pre><code class=\"python\">import os\nimport rabbitpy\nimport time\nfrom ch6 import detect\nfrom ch6 import utils\n\n# Open the connection and the channel\nconnection = rabbitpy.Connection()\nchannel = connection.channel()\n\n# Create the worker queue\nqueue_name = &#39;rpc-worker-%s&#39; % os.getpid()\nqueue = rabbitpy.Queue(channel, queue_name,\n                       auto_delete=True,\n                       durable=False,\n                       exclusive=True)\n\n# Declare the worker queue\nif queue.declare():\n    print(&#39;Worker queue declared&#39;)\n\n# Bind the worker queue\nif queue.bind(&#39;headers-rpc-requests&#39;,\n              arguments={&#39;x-match&#39;: &#39;all&#39;,\n                         &#39;source&#39;: &#39;profile&#39;,\n                         &#39;object&#39;: &#39;image&#39;,\n                         &#39;action&#39;: &#39;new&#39;}):\n    print(&#39;Worker queue bound&#39;)\n\n# Consume messages from RabbitMQ\nfor message in queue.consume_messages():\n\n    # Display how long it took for the message to get here\n    duration = time.time() - int(message.properties[&#39;timestamp&#39;].strftime(&#39;%s&#39;))\n    print(&#39;Received RPC request published %.2f seconds ago&#39; % duration)\n\n    # Write out the message body to a temp file for facial detection process\n    temp_file = utils.write_temp_file(message.body,\n                                      message.properties[&#39;content_type&#39;])\n\n    # Detect faces\n    result_file = detect.faces(temp_file)\n\n    # Build response properties including the timestamp from the first publish\n    properties = {&#39;app_id&#39;: &#39;Chapter 6 Listing 2 Consumer&#39;,\n                  &#39;content_type&#39;: message.properties[&#39;content_type&#39;],\n                  &#39;correlation_id&#39;: message.properties[&#39;correlation_id&#39;],\n                  &#39;headers&#39;: {\n                      &#39;first_publish&#39;: message.properties[&#39;timestamp&#39;]}}\n\n    # The result file could just be the original image if nothing detected\n    body = utils.read_image(result_file)\n\n    # Remove the temp file\n    os.unlink(temp_file)\n\n    # Remove the result file\n    os.unlink(result_file)\n\n    # Publish the response response\n    response = rabbitpy.Message(channel, body, properties, opinionated=True)\n    response.publish(&#39;rpc-replies&#39;, message.properties[&#39;reply_to&#39;])\n\n    # Acknowledge the delivery of the RPC request message\n    message.ack()\n</code></pre>\n<h2 id=\"交换器路由\"><a href=\"#交换器路由\" class=\"headerlink\" title=\"交换器路由\"></a>交换器路由</h2><p>交换器间绑定，使用RPC方法Exchange.Bind。</p>\n<h3 id=\"示例场景-3\"><a href=\"#示例场景-3\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201009211108563-1049881640.jpg\" alt></p>\n<p>示例代码：</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        tpc = rabbitpy.Exchange(channel, &#39;events&#39;,\n                                exchange_type=&#39;topic&#39;)\n        tpc.declare()\n        xch = rabbitpy.Exchange(channel, &#39;distributed-events&#39;,\n                                exchange_type=&#39;x-consistent-hash&#39;)\n        xch.declare()\n        xch.bind(foo, &#39;#&#39;)</code></pre>\n<h2 id=\"一致性哈希交换器\"><a href=\"#一致性哈希交换器\" class=\"headerlink\" title=\"一致性哈希交换器\"></a>一致性哈希交换器</h2><p>用于消息队列的负载均衡，可以提升吞吐量</p>\n<h3 id=\"示例场景-4\"><a href=\"#示例场景-4\" class=\"headerlink\" title=\"示例场景\"></a>示例场景</h3><p>示例代码：采用路由键的哈希值来分发消息</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, &#39;image-storage&#39;,\n                                     exchange_type=&#39;x-consistent-hash&#39;)\n        exchange.declare()</code></pre>\n<p>示例代码：header中的属性值作为哈希值</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        exchange = rabbitpy.Exchange(channel, &#39;image-storage&#39;,\n                                     exchange_type=&#39;x-consistent-hash&#39;,\n                                     arguments={&#39;hash-header&#39;: &#39;image-hash&#39;})\n        exchange.declare()\n</code></pre>\n<p>示例代码：队列的创建与绑定</p>\n<pre><code class=\"python\">import rabbitpy\n\nwith rabbitpy.Connection() as connection:\n    with connection.channel() as channel:\n        for queue_num in range(4):\n            queue = rabbitpy.Queue (channel, &#39;server%s&#39; % queue_num)\n            queue.declare()\n            queue.bind(&#39;image-storage&#39;, &#39;10&#39;)</code></pre>\n"},{"title":"rabbitmq消息重复","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T14:18:39.000Z","password":null,"summary":null,"_content":"\n## 场景\n\n- 可靠性投递机制：mq收到生产者消息，mq在返回confirm的时候网络出现闪断，导致broker未收到应答，导致发送两次。\n- MQ Broker服务与消费端传输消息的过程中出现网络抖动。\n- 消费端故障、异常。\n\n## 解决方案\n\n### 可靠性投递解决\n\n对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是：\n（1）全局唯一\n（2）MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽\n有了这个inner-msg-id，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。\n\n### 消费抖动解决\n业务消息体中，必须有一个biz-id，作为去重和幂等的依据，这个业务ID的特性是：\n（1）对于同一个业务场景，全局唯一\n（2）由业务消息发送方生成，业务相关，对MQ透明\n（3）由业务消息消费方负责判重，以保证幂等","source":"_posts/rabbitmq消息重复.md","raw":"---\ntitle: rabbitmq消息重复\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 22:18:39\npassword:\nsummary:\ntags:\n- rabbitmq\ncategories:\n- rabbitmq\n---\n\n## 场景\n\n- 可靠性投递机制：mq收到生产者消息，mq在返回confirm的时候网络出现闪断，导致broker未收到应答，导致发送两次。\n- MQ Broker服务与消费端传输消息的过程中出现网络抖动。\n- 消费端故障、异常。\n\n## 解决方案\n\n### 可靠性投递解决\n\n对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是：\n（1）全局唯一\n（2）MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽\n有了这个inner-msg-id，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。\n\n### 消费抖动解决\n业务消息体中，必须有一个biz-id，作为去重和幂等的依据，这个业务ID的特性是：\n（1）对于同一个业务场景，全局唯一\n（2）由业务消息发送方生成，业务相关，对MQ透明\n（3）由业务消息消费方负责判重，以保证幂等","slug":"rabbitmq消息重复","published":1,"updated":"2020-10-26T14:19:10.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w8t000pi4ufh7qat27o","content":"<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><ul>\n<li>可靠性投递机制：mq收到生产者消息，mq在返回confirm的时候网络出现闪断，导致broker未收到应答，导致发送两次。</li>\n<li>MQ Broker服务与消费端传输消息的过程中出现网络抖动。</li>\n<li>消费端故障、异常。</li>\n</ul>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"可靠性投递解决\"><a href=\"#可靠性投递解决\" class=\"headerlink\" title=\"可靠性投递解决\"></a>可靠性投递解决</h3><p>对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是：<br>（1）全局唯一<br>（2）MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽<br>有了这个inner-msg-id，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。</p>\n<h3 id=\"消费抖动解决\"><a href=\"#消费抖动解决\" class=\"headerlink\" title=\"消费抖动解决\"></a>消费抖动解决</h3><p>业务消息体中，必须有一个biz-id，作为去重和幂等的依据，这个业务ID的特性是：<br>（1）对于同一个业务场景，全局唯一<br>（2）由业务消息发送方生成，业务相关，对MQ透明<br>（3）由业务消息消费方负责判重，以保证幂等</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><ul>\n<li>可靠性投递机制：mq收到生产者消息，mq在返回confirm的时候网络出现闪断，导致broker未收到应答，导致发送两次。</li>\n<li>MQ Broker服务与消费端传输消息的过程中出现网络抖动。</li>\n<li>消费端故障、异常。</li>\n</ul>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"可靠性投递解决\"><a href=\"#可靠性投递解决\" class=\"headerlink\" title=\"可靠性投递解决\"></a>可靠性投递解决</h3><p>对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是：<br>（1）全局唯一<br>（2）MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽<br>有了这个inner-msg-id，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。</p>\n<h3 id=\"消费抖动解决\"><a href=\"#消费抖动解决\" class=\"headerlink\" title=\"消费抖动解决\"></a>消费抖动解决</h3><p>业务消息体中，必须有一个biz-id，作为去重和幂等的依据，这个业务ID的特性是：<br>（1）对于同一个业务场景，全局唯一<br>（2）由业务消息发送方生成，业务相关，对MQ透明<br>（3）由业务消息消费方负责判重，以保证幂等</p>\n"},{"title":"rabbitmq集群","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T14:17:41.000Z","password":null,"summary":null,"_content":"\n## 集群概述\n\n------------\n\n### 集群节点类型\n\n- 磁盘节点：运行时状态信息（集群、队列、绑定虚拟主机、用户、策略等）存储在内存和磁盘中。集群至少有一个磁盘节点。关闭集群后，重启时需要按照一定顺序启动。\n- 内存节点：运行时状态信息（集群、队列、绑定虚拟主机、用户、策略等）存储在内存中。重启加入集群是，需要从其他节点同步。\n\n**统计节点**\nrabbitmq管理插件包含，必须搭配磁盘节点，且一个集群只能有一个统计节点。统计节点负责收集每个节点的全部统计数据和状态数据。主节点（统计节点）故障，备用磁盘节点将被指定为统计节点。\n\n## 集群设置\n\n**加入集群**\n\n```\n1、在第一节点上运行rabbitmq\n2、在第二节点上停止rabbitmq，并清除状态\nrabbitmqctl stop_app\nrabbitmqctl reset\n3、加入主节点，构成集群\nrabbitmqctl join_cluster rabbitmq@node1\n4、再次启动第二节点rabbitmq\nrabbitmqctl start_app\n\n\n\n```","source":"_posts/rabbitmq集群.md","raw":"---\ntitle: rabbitmq集群\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 22:17:41\npassword:\nsummary:\ntags:\n- rabbitmq\ncategories:\n- rabbitmq\n---\n\n## 集群概述\n\n------------\n\n### 集群节点类型\n\n- 磁盘节点：运行时状态信息（集群、队列、绑定虚拟主机、用户、策略等）存储在内存和磁盘中。集群至少有一个磁盘节点。关闭集群后，重启时需要按照一定顺序启动。\n- 内存节点：运行时状态信息（集群、队列、绑定虚拟主机、用户、策略等）存储在内存中。重启加入集群是，需要从其他节点同步。\n\n**统计节点**\nrabbitmq管理插件包含，必须搭配磁盘节点，且一个集群只能有一个统计节点。统计节点负责收集每个节点的全部统计数据和状态数据。主节点（统计节点）故障，备用磁盘节点将被指定为统计节点。\n\n## 集群设置\n\n**加入集群**\n\n```\n1、在第一节点上运行rabbitmq\n2、在第二节点上停止rabbitmq，并清除状态\nrabbitmqctl stop_app\nrabbitmqctl reset\n3、加入主节点，构成集群\nrabbitmqctl join_cluster rabbitmq@node1\n4、再次启动第二节点rabbitmq\nrabbitmqctl start_app\n\n\n\n```","slug":"rabbitmq集群","published":1,"updated":"2020-10-26T14:18:16.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w8w000ti4uf0eu92pjg","content":"<h2 id=\"集群概述\"><a href=\"#集群概述\" class=\"headerlink\" title=\"集群概述\"></a>集群概述</h2><hr>\n<h3 id=\"集群节点类型\"><a href=\"#集群节点类型\" class=\"headerlink\" title=\"集群节点类型\"></a>集群节点类型</h3><ul>\n<li>磁盘节点：运行时状态信息（集群、队列、绑定虚拟主机、用户、策略等）存储在内存和磁盘中。集群至少有一个磁盘节点。关闭集群后，重启时需要按照一定顺序启动。</li>\n<li>内存节点：运行时状态信息（集群、队列、绑定虚拟主机、用户、策略等）存储在内存中。重启加入集群是，需要从其他节点同步。</li>\n</ul>\n<p><strong>统计节点</strong><br>rabbitmq管理插件包含，必须搭配磁盘节点，且一个集群只能有一个统计节点。统计节点负责收集每个节点的全部统计数据和状态数据。主节点（统计节点）故障，备用磁盘节点将被指定为统计节点。</p>\n<h2 id=\"集群设置\"><a href=\"#集群设置\" class=\"headerlink\" title=\"集群设置\"></a>集群设置</h2><p><strong>加入集群</strong></p>\n<pre><code>1、在第一节点上运行rabbitmq\n2、在第二节点上停止rabbitmq，并清除状态\nrabbitmqctl stop_app\nrabbitmqctl reset\n3、加入主节点，构成集群\nrabbitmqctl join_cluster rabbitmq@node1\n4、再次启动第二节点rabbitmq\nrabbitmqctl start_app\n\n\n</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"集群概述\"><a href=\"#集群概述\" class=\"headerlink\" title=\"集群概述\"></a>集群概述</h2><hr>\n<h3 id=\"集群节点类型\"><a href=\"#集群节点类型\" class=\"headerlink\" title=\"集群节点类型\"></a>集群节点类型</h3><ul>\n<li>磁盘节点：运行时状态信息（集群、队列、绑定虚拟主机、用户、策略等）存储在内存和磁盘中。集群至少有一个磁盘节点。关闭集群后，重启时需要按照一定顺序启动。</li>\n<li>内存节点：运行时状态信息（集群、队列、绑定虚拟主机、用户、策略等）存储在内存中。重启加入集群是，需要从其他节点同步。</li>\n</ul>\n<p><strong>统计节点</strong><br>rabbitmq管理插件包含，必须搭配磁盘节点，且一个集群只能有一个统计节点。统计节点负责收集每个节点的全部统计数据和状态数据。主节点（统计节点）故障，备用磁盘节点将被指定为统计节点。</p>\n<h2 id=\"集群设置\"><a href=\"#集群设置\" class=\"headerlink\" title=\"集群设置\"></a>集群设置</h2><p><strong>加入集群</strong></p>\n<pre><code>1、在第一节点上运行rabbitmq\n2、在第二节点上停止rabbitmq，并清除状态\nrabbitmqctl stop_app\nrabbitmqctl reset\n3、加入主节点，构成集群\nrabbitmqctl join_cluster rabbitmq@node1\n4、再次启动第二节点rabbitmq\nrabbitmqctl start_app\n\n\n</code></pre>"},{"title":"redis AOF机制","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T14:07:40.000Z","password":null,"summary":null,"_content":"\n先写内存，在写日志。\n1、命令执行成功才会被记录日志。\n2、避免对当前命令的阻塞。\n\n## 风险\n1、突然宕机，Redis用作数据库的话，命令可能没有记入日志，所以就无法用日志进行恢复了。\n2、AOF写磁盘，当磁盘压力大，会导致写盘慢，阻塞后续操作。\n3、子进程要拷贝父进程的页表，这个过程的耗时和 Redis 实例的内存大小有关。如果 Redis 实例内存大，页表就会大，fork 执行时间就长，可能阻塞主线程。\n4、子进程和父进程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是 bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。\n\n## 日志写回策略与选择\n- Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；\n- Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；\n- No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。\n\n**对比如下**：\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201022202948278-1557328450.jpg)\n\n**选择如下**：\n- 高性能，选择 No；\n- 高可靠性，选择 Always；\n- 允许数据丢失，同时性能较好，选择 Everysec。\n\n## 重写机制\n\n后台线程bgwriteaof读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。\n\n**作用**\n1、避免日志文件过大。\n2、后台线程避免阻塞主线程\n\n**流程**\n一个拷贝，两处日志\n1、主线程 fork 出 bgrewriteaof 子进程，把主线程的内存拷贝一份给 bgrewriteaof 子进程\n2、正在使用的 AOF 日志，因为可能记录了最新操作，Redis 会把这个操作写到它的缓冲区\n3、拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件","source":"_posts/redis-AOF机制.md","raw":"---\ntitle: redis AOF机制\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 22:07:40\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n先写内存，在写日志。\n1、命令执行成功才会被记录日志。\n2、避免对当前命令的阻塞。\n\n## 风险\n1、突然宕机，Redis用作数据库的话，命令可能没有记入日志，所以就无法用日志进行恢复了。\n2、AOF写磁盘，当磁盘压力大，会导致写盘慢，阻塞后续操作。\n3、子进程要拷贝父进程的页表，这个过程的耗时和 Redis 实例的内存大小有关。如果 Redis 实例内存大，页表就会大，fork 执行时间就长，可能阻塞主线程。\n4、子进程和父进程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是 bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。\n\n## 日志写回策略与选择\n- Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；\n- Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；\n- No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。\n\n**对比如下**：\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201022202948278-1557328450.jpg)\n\n**选择如下**：\n- 高性能，选择 No；\n- 高可靠性，选择 Always；\n- 允许数据丢失，同时性能较好，选择 Everysec。\n\n## 重写机制\n\n后台线程bgwriteaof读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。\n\n**作用**\n1、避免日志文件过大。\n2、后台线程避免阻塞主线程\n\n**流程**\n一个拷贝，两处日志\n1、主线程 fork 出 bgrewriteaof 子进程，把主线程的内存拷贝一份给 bgrewriteaof 子进程\n2、正在使用的 AOF 日志，因为可能记录了最新操作，Redis 会把这个操作写到它的缓冲区\n3、拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件","slug":"redis-AOF机制","published":1,"updated":"2020-10-26T14:08:25.343Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w8z000vi4ufqec9qovy","content":"<p>先写内存，在写日志。<br>1、命令执行成功才会被记录日志。<br>2、避免对当前命令的阻塞。</p>\n<h2 id=\"风险\"><a href=\"#风险\" class=\"headerlink\" title=\"风险\"></a>风险</h2><p>1、突然宕机，Redis用作数据库的话，命令可能没有记入日志，所以就无法用日志进行恢复了。<br>2、AOF写磁盘，当磁盘压力大，会导致写盘慢，阻塞后续操作。<br>3、子进程要拷贝父进程的页表，这个过程的耗时和 Redis 实例的内存大小有关。如果 Redis 实例内存大，页表就会大，fork 执行时间就长，可能阻塞主线程。<br>4、子进程和父进程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是 bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。</p>\n<h2 id=\"日志写回策略与选择\"><a href=\"#日志写回策略与选择\" class=\"headerlink\" title=\"日志写回策略与选择\"></a>日志写回策略与选择</h2><ul>\n<li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li>\n<li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>\n<li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>\n</ul>\n<p><strong>对比如下</strong>：<br><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201022202948278-1557328450.jpg\" alt></p>\n<p><strong>选择如下</strong>：</p>\n<ul>\n<li>高性能，选择 No；</li>\n<li>高可靠性，选择 Always；</li>\n<li>允许数据丢失，同时性能较好，选择 Everysec。</li>\n</ul>\n<h2 id=\"重写机制\"><a href=\"#重写机制\" class=\"headerlink\" title=\"重写机制\"></a>重写机制</h2><p>后台线程bgwriteaof读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。</p>\n<p><strong>作用</strong><br>1、避免日志文件过大。<br>2、后台线程避免阻塞主线程</p>\n<p><strong>流程</strong><br>一个拷贝，两处日志<br>1、主线程 fork 出 bgrewriteaof 子进程，把主线程的内存拷贝一份给 bgrewriteaof 子进程<br>2、正在使用的 AOF 日志，因为可能记录了最新操作，Redis 会把这个操作写到它的缓冲区<br>3、拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<p>先写内存，在写日志。<br>1、命令执行成功才会被记录日志。<br>2、避免对当前命令的阻塞。</p>\n<h2 id=\"风险\"><a href=\"#风险\" class=\"headerlink\" title=\"风险\"></a>风险</h2><p>1、突然宕机，Redis用作数据库的话，命令可能没有记入日志，所以就无法用日志进行恢复了。<br>2、AOF写磁盘，当磁盘压力大，会导致写盘慢，阻塞后续操作。<br>3、子进程要拷贝父进程的页表，这个过程的耗时和 Redis 实例的内存大小有关。如果 Redis 实例内存大，页表就会大，fork 执行时间就长，可能阻塞主线程。<br>4、子进程和父进程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是 bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。</p>\n<h2 id=\"日志写回策略与选择\"><a href=\"#日志写回策略与选择\" class=\"headerlink\" title=\"日志写回策略与选择\"></a>日志写回策略与选择</h2><ul>\n<li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li>\n<li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>\n<li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>\n</ul>\n<p><strong>对比如下</strong>：<br><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201022202948278-1557328450.jpg\" alt></p>\n<p><strong>选择如下</strong>：</p>\n<ul>\n<li>高性能，选择 No；</li>\n<li>高可靠性，选择 Always；</li>\n<li>允许数据丢失，同时性能较好，选择 Everysec。</li>\n</ul>\n<h2 id=\"重写机制\"><a href=\"#重写机制\" class=\"headerlink\" title=\"重写机制\"></a>重写机制</h2><p>后台线程bgwriteaof读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。</p>\n<p><strong>作用</strong><br>1、避免日志文件过大。<br>2、后台线程避免阻塞主线程</p>\n<p><strong>流程</strong><br>一个拷贝，两处日志<br>1、主线程 fork 出 bgrewriteaof 子进程，把主线程的内存拷贝一份给 bgrewriteaof 子进程<br>2、正在使用的 AOF 日志，因为可能记录了最新操作，Redis 会把这个操作写到它的缓冲区<br>3、拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件</p>\n"},{"title":"redis RBD机制","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T14:09:31.000Z","password":null,"summary":null,"_content":"\nRDB 就是 Redis DataBase，内存中的全量数据在某一个时刻的状态记录。\n\n## 快照机制\n\n引入原因：AOF日志进行故障恢复的时候，需要逐一执行操作日志。如果操作日志非常多，Redis 恢复得很慢，影响到正常使用。\n\nbgsave命令：主进程fork出子进程，共享主线程的所有内存数据。子进程读取主线程的内存数据，并把它们写入 RDB 文件。\n借助了操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作，避免了主线程的阻塞。\n如果主线程要修改一块数据，这块数据就会被复制一份，生成数据副本。bgsave 子进程会把这个副本数据写入 RDB 文件。\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201024165305565-62767733.jpg)\n\n\n## 增量快照\n做了一次全量快照后，后续的快照只对修改的数据进行快照记录，避免每次全量快照的开销。\n需要使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。\n\n\n## 混用 AOF日志和RDB(Redis 4.0)\n\n内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。\n快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。\n\n## 备份机制选择\n\n数据不能丢失时，内存快照和 AOF 的混合使用；\n如果允许分钟级别的数据丢失，只使用 RDB；\n如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。","source":"_posts/redis-RDB机制.md","raw":"---\ntitle: redis RBD机制\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 22:09:31\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\nRDB 就是 Redis DataBase，内存中的全量数据在某一个时刻的状态记录。\n\n## 快照机制\n\n引入原因：AOF日志进行故障恢复的时候，需要逐一执行操作日志。如果操作日志非常多，Redis 恢复得很慢，影响到正常使用。\n\nbgsave命令：主进程fork出子进程，共享主线程的所有内存数据。子进程读取主线程的内存数据，并把它们写入 RDB 文件。\n借助了操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作，避免了主线程的阻塞。\n如果主线程要修改一块数据，这块数据就会被复制一份，生成数据副本。bgsave 子进程会把这个副本数据写入 RDB 文件。\n\n![](https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201024165305565-62767733.jpg)\n\n\n## 增量快照\n做了一次全量快照后，后续的快照只对修改的数据进行快照记录，避免每次全量快照的开销。\n需要使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。\n\n\n## 混用 AOF日志和RDB(Redis 4.0)\n\n内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。\n快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。\n\n## 备份机制选择\n\n数据不能丢失时，内存快照和 AOF 的混合使用；\n如果允许分钟级别的数据丢失，只使用 RDB；\n如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。","slug":"redis-RDB机制","published":1,"updated":"2020-10-26T14:10:13.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w940010i4ufq2x8t0gq","content":"<p>RDB 就是 Redis DataBase，内存中的全量数据在某一个时刻的状态记录。</p>\n<h2 id=\"快照机制\"><a href=\"#快照机制\" class=\"headerlink\" title=\"快照机制\"></a>快照机制</h2><p>引入原因：AOF日志进行故障恢复的时候，需要逐一执行操作日志。如果操作日志非常多，Redis 恢复得很慢，影响到正常使用。</p>\n<p>bgsave命令：主进程fork出子进程，共享主线程的所有内存数据。子进程读取主线程的内存数据，并把它们写入 RDB 文件。<br>借助了操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作，避免了主线程的阻塞。<br>如果主线程要修改一块数据，这块数据就会被复制一份，生成数据副本。bgsave 子进程会把这个副本数据写入 RDB 文件。</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201024165305565-62767733.jpg\" alt></p>\n<h2 id=\"增量快照\"><a href=\"#增量快照\" class=\"headerlink\" title=\"增量快照\"></a>增量快照</h2><p>做了一次全量快照后，后续的快照只对修改的数据进行快照记录，避免每次全量快照的开销。<br>需要使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。</p>\n<h2 id=\"混用-AOF日志和RDB-Redis-4-0\"><a href=\"#混用-AOF日志和RDB-Redis-4-0\" class=\"headerlink\" title=\"混用 AOF日志和RDB(Redis 4.0)\"></a>混用 AOF日志和RDB(Redis 4.0)</h2><p>内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。<br>快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>\n<h2 id=\"备份机制选择\"><a href=\"#备份机制选择\" class=\"headerlink\" title=\"备份机制选择\"></a>备份机制选择</h2><p>数据不能丢失时，内存快照和 AOF 的混合使用；<br>如果允许分钟级别的数据丢失，只使用 RDB；<br>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<p>RDB 就是 Redis DataBase，内存中的全量数据在某一个时刻的状态记录。</p>\n<h2 id=\"快照机制\"><a href=\"#快照机制\" class=\"headerlink\" title=\"快照机制\"></a>快照机制</h2><p>引入原因：AOF日志进行故障恢复的时候，需要逐一执行操作日志。如果操作日志非常多，Redis 恢复得很慢，影响到正常使用。</p>\n<p>bgsave命令：主进程fork出子进程，共享主线程的所有内存数据。子进程读取主线程的内存数据，并把它们写入 RDB 文件。<br>借助了操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作，避免了主线程的阻塞。<br>如果主线程要修改一块数据，这块数据就会被复制一份，生成数据副本。bgsave 子进程会把这个副本数据写入 RDB 文件。</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1030146/202010/1030146-20201024165305565-62767733.jpg\" alt></p>\n<h2 id=\"增量快照\"><a href=\"#增量快照\" class=\"headerlink\" title=\"增量快照\"></a>增量快照</h2><p>做了一次全量快照后，后续的快照只对修改的数据进行快照记录，避免每次全量快照的开销。<br>需要使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。</p>\n<h2 id=\"混用-AOF日志和RDB-Redis-4-0\"><a href=\"#混用-AOF日志和RDB-Redis-4-0\" class=\"headerlink\" title=\"混用 AOF日志和RDB(Redis 4.0)\"></a>混用 AOF日志和RDB(Redis 4.0)</h2><p>内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。<br>快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>\n<h2 id=\"备份机制选择\"><a href=\"#备份机制选择\" class=\"headerlink\" title=\"备份机制选择\"></a>备份机制选择</h2><p>数据不能丢失时，内存快照和 AOF 的混合使用；<br>如果允许分钟级别的数据丢失，只使用 RDB；<br>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</p>\n"},{"title":"redis6.0","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-12-09T05:35:15.000Z","password":null,"summary":null,"_content":"\n## 多线程\n\n**问题**\n\n单个主线程处理网络请求的速度跟不上底层网络硬件的速度。\n\n**优化**\n\n多个 IO 线程并行处理网络操作，可以提升实例的整体处理性能。使用单线程执行命令操作，就不用为了保证 Lua 脚本、事务的原子性，额外开发多线程互斥机制了。\n\n**具体流程**\n\n1、服务端和客户端建立 Socket 连接，并分配处理线程\n\n2、IO 线程读取并解析请求\n\n3、主线程执行请求操作\n\n4、IO 线程回写 Socket 和主线程清空全局队列\n\n相关配置：\n\n```\nio-threads-do-reads yes #启用多线程\nio-threads  6           #线程个数要小于 Redis 实例所在机器的 CPU 核个数\n```\n\n## 服务端协助的客户端缓存（Tracking）\n\n**问题**\n\n如果数据被修改了或是失效了，如何通知客户端对缓存的数据做失效处理。\n\n### 普通模式\n\n实例会在服务端记录客户端读取过的 key，并监测 key 是否有修改。一旦 key 的值发生变化，服务端会给客户端发送 invalidate 消息，通知客户端缓存失效了。\n\n服务端对于记录的 key 只会报告一次 invalidate 消息\n\n只有当客户端再次执行读命令时，服务端才会再次监测被读取的 key，并在 key 修改时发送 invalidate 消息\n\n**设置命令**\n\n```\nCLIENT TRACKING ON|OFF\n```\n\n### 广播模式\n\n服务端会给客户端广播所有 key 的失效情况，不过，这样做了之后，如果 key 被频繁修改，服务端会发送大量的失效广播消息，这就会消耗大量的网络带宽资源。\n\n**应用场景**\n\n我们会让客户端注册希望跟踪的 key 的前缀，当带有注册前缀的 key 被修改时，服务端会把失效消息广播给所有注册的客户端。\n\n**区别**：\n\n在广播模式下，即使客户端还没有读取过 key，但只要它注册了要跟踪的 key，服务端都会把 key 失效消息通知给这个客户端。\n\n## 细粒度的权限控制\n\n1、支持创建不同用户来使用 Redis\n\n```\nACL SETUSER normaluser on > abc #创建并启用一个用户 normaluser，把它的密码设置为“abc” \n```\n\n2、支持以用户为粒度设置命令操作的访问权限\n\n![acl_cmd](acl_cmd.jpg)\n\n","source":"_posts/redis6-0.md","raw":"---\ntitle: redis6.0\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-12-09 13:35:15\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## 多线程\n\n**问题**\n\n单个主线程处理网络请求的速度跟不上底层网络硬件的速度。\n\n**优化**\n\n多个 IO 线程并行处理网络操作，可以提升实例的整体处理性能。使用单线程执行命令操作，就不用为了保证 Lua 脚本、事务的原子性，额外开发多线程互斥机制了。\n\n**具体流程**\n\n1、服务端和客户端建立 Socket 连接，并分配处理线程\n\n2、IO 线程读取并解析请求\n\n3、主线程执行请求操作\n\n4、IO 线程回写 Socket 和主线程清空全局队列\n\n相关配置：\n\n```\nio-threads-do-reads yes #启用多线程\nio-threads  6           #线程个数要小于 Redis 实例所在机器的 CPU 核个数\n```\n\n## 服务端协助的客户端缓存（Tracking）\n\n**问题**\n\n如果数据被修改了或是失效了，如何通知客户端对缓存的数据做失效处理。\n\n### 普通模式\n\n实例会在服务端记录客户端读取过的 key，并监测 key 是否有修改。一旦 key 的值发生变化，服务端会给客户端发送 invalidate 消息，通知客户端缓存失效了。\n\n服务端对于记录的 key 只会报告一次 invalidate 消息\n\n只有当客户端再次执行读命令时，服务端才会再次监测被读取的 key，并在 key 修改时发送 invalidate 消息\n\n**设置命令**\n\n```\nCLIENT TRACKING ON|OFF\n```\n\n### 广播模式\n\n服务端会给客户端广播所有 key 的失效情况，不过，这样做了之后，如果 key 被频繁修改，服务端会发送大量的失效广播消息，这就会消耗大量的网络带宽资源。\n\n**应用场景**\n\n我们会让客户端注册希望跟踪的 key 的前缀，当带有注册前缀的 key 被修改时，服务端会把失效消息广播给所有注册的客户端。\n\n**区别**：\n\n在广播模式下，即使客户端还没有读取过 key，但只要它注册了要跟踪的 key，服务端都会把 key 失效消息通知给这个客户端。\n\n## 细粒度的权限控制\n\n1、支持创建不同用户来使用 Redis\n\n```\nACL SETUSER normaluser on > abc #创建并启用一个用户 normaluser，把它的密码设置为“abc” \n```\n\n2、支持以用户为粒度设置命令操作的访问权限\n\n![acl_cmd](acl_cmd.jpg)\n\n","slug":"redis6-0","published":1,"updated":"2020-12-09T05:53:02.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w960012i4uf9tewpxmj","content":"<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><p><strong>问题</strong></p>\n<p>单个主线程处理网络请求的速度跟不上底层网络硬件的速度。</p>\n<p><strong>优化</strong></p>\n<p>多个 IO 线程并行处理网络操作，可以提升实例的整体处理性能。使用单线程执行命令操作，就不用为了保证 Lua 脚本、事务的原子性，额外开发多线程互斥机制了。</p>\n<p><strong>具体流程</strong></p>\n<p>1、服务端和客户端建立 Socket 连接，并分配处理线程</p>\n<p>2、IO 线程读取并解析请求</p>\n<p>3、主线程执行请求操作</p>\n<p>4、IO 线程回写 Socket 和主线程清空全局队列</p>\n<p>相关配置：</p>\n<pre><code>io-threads-do-reads yes #启用多线程\nio-threads  6           #线程个数要小于 Redis 实例所在机器的 CPU 核个数</code></pre><h2 id=\"服务端协助的客户端缓存（Tracking）\"><a href=\"#服务端协助的客户端缓存（Tracking）\" class=\"headerlink\" title=\"服务端协助的客户端缓存（Tracking）\"></a>服务端协助的客户端缓存（Tracking）</h2><p><strong>问题</strong></p>\n<p>如果数据被修改了或是失效了，如何通知客户端对缓存的数据做失效处理。</p>\n<h3 id=\"普通模式\"><a href=\"#普通模式\" class=\"headerlink\" title=\"普通模式\"></a>普通模式</h3><p>实例会在服务端记录客户端读取过的 key，并监测 key 是否有修改。一旦 key 的值发生变化，服务端会给客户端发送 invalidate 消息，通知客户端缓存失效了。</p>\n<p>服务端对于记录的 key 只会报告一次 invalidate 消息</p>\n<p>只有当客户端再次执行读命令时，服务端才会再次监测被读取的 key，并在 key 修改时发送 invalidate 消息</p>\n<p><strong>设置命令</strong></p>\n<pre><code>CLIENT TRACKING ON|OFF</code></pre><h3 id=\"广播模式\"><a href=\"#广播模式\" class=\"headerlink\" title=\"广播模式\"></a>广播模式</h3><p>服务端会给客户端广播所有 key 的失效情况，不过，这样做了之后，如果 key 被频繁修改，服务端会发送大量的失效广播消息，这就会消耗大量的网络带宽资源。</p>\n<p><strong>应用场景</strong></p>\n<p>我们会让客户端注册希望跟踪的 key 的前缀，当带有注册前缀的 key 被修改时，服务端会把失效消息广播给所有注册的客户端。</p>\n<p><strong>区别</strong>：</p>\n<p>在广播模式下，即使客户端还没有读取过 key，但只要它注册了要跟踪的 key，服务端都会把 key 失效消息通知给这个客户端。</p>\n<h2 id=\"细粒度的权限控制\"><a href=\"#细粒度的权限控制\" class=\"headerlink\" title=\"细粒度的权限控制\"></a>细粒度的权限控制</h2><p>1、支持创建不同用户来使用 Redis</p>\n<pre><code>ACL SETUSER normaluser on &gt; abc #创建并启用一个用户 normaluser，把它的密码设置为“abc” </code></pre><p>2、支持以用户为粒度设置命令操作的访问权限</p>\n<p><img src=\"acl_cmd.jpg\" alt=\"acl_cmd\"></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><p><strong>问题</strong></p>\n<p>单个主线程处理网络请求的速度跟不上底层网络硬件的速度。</p>\n<p><strong>优化</strong></p>\n<p>多个 IO 线程并行处理网络操作，可以提升实例的整体处理性能。使用单线程执行命令操作，就不用为了保证 Lua 脚本、事务的原子性，额外开发多线程互斥机制了。</p>\n<p><strong>具体流程</strong></p>\n<p>1、服务端和客户端建立 Socket 连接，并分配处理线程</p>\n<p>2、IO 线程读取并解析请求</p>\n<p>3、主线程执行请求操作</p>\n<p>4、IO 线程回写 Socket 和主线程清空全局队列</p>\n<p>相关配置：</p>\n<pre><code>io-threads-do-reads yes #启用多线程\nio-threads  6           #线程个数要小于 Redis 实例所在机器的 CPU 核个数</code></pre><h2 id=\"服务端协助的客户端缓存（Tracking）\"><a href=\"#服务端协助的客户端缓存（Tracking）\" class=\"headerlink\" title=\"服务端协助的客户端缓存（Tracking）\"></a>服务端协助的客户端缓存（Tracking）</h2><p><strong>问题</strong></p>\n<p>如果数据被修改了或是失效了，如何通知客户端对缓存的数据做失效处理。</p>\n<h3 id=\"普通模式\"><a href=\"#普通模式\" class=\"headerlink\" title=\"普通模式\"></a>普通模式</h3><p>实例会在服务端记录客户端读取过的 key，并监测 key 是否有修改。一旦 key 的值发生变化，服务端会给客户端发送 invalidate 消息，通知客户端缓存失效了。</p>\n<p>服务端对于记录的 key 只会报告一次 invalidate 消息</p>\n<p>只有当客户端再次执行读命令时，服务端才会再次监测被读取的 key，并在 key 修改时发送 invalidate 消息</p>\n<p><strong>设置命令</strong></p>\n<pre><code>CLIENT TRACKING ON|OFF</code></pre><h3 id=\"广播模式\"><a href=\"#广播模式\" class=\"headerlink\" title=\"广播模式\"></a>广播模式</h3><p>服务端会给客户端广播所有 key 的失效情况，不过，这样做了之后，如果 key 被频繁修改，服务端会发送大量的失效广播消息，这就会消耗大量的网络带宽资源。</p>\n<p><strong>应用场景</strong></p>\n<p>我们会让客户端注册希望跟踪的 key 的前缀，当带有注册前缀的 key 被修改时，服务端会把失效消息广播给所有注册的客户端。</p>\n<p><strong>区别</strong>：</p>\n<p>在广播模式下，即使客户端还没有读取过 key，但只要它注册了要跟踪的 key，服务端都会把 key 失效消息通知给这个客户端。</p>\n<h2 id=\"细粒度的权限控制\"><a href=\"#细粒度的权限控制\" class=\"headerlink\" title=\"细粒度的权限控制\"></a>细粒度的权限控制</h2><p>1、支持创建不同用户来使用 Redis</p>\n<pre><code>ACL SETUSER normaluser on &gt; abc #创建并启用一个用户 normaluser，把它的密码设置为“abc” </code></pre><p>2、支持以用户为粒度设置命令操作的访问权限</p>\n<p><img src=\"acl_cmd.jpg\" alt=\"acl_cmd\"></p>\n"},{"title":"redis主从同步","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-25T08:30:01.000Z","password":null,"summary":null,"_content":"\n[toc]\n\n主从库之间采用读写分离。\n读操作：主库、从库都可以接收；\n写操作：首先到主库执行，然后，主库将写操作同步给从库。\n![读写分离](duxiefenli.jpg)\n\n## 同步机制\n\n通过 `replicaof`（Redis 5.0 之前使用 `slaveof`）命令形成主库和从库的关系。\n\n1、主从库间建立连接、协商同步，为全量复制做准备。\n**从库和主库建立起连接，发送 psync 命令**，表示要进行数据同步，**主库确认回复**，FULLRESYNC响应表示第一次复制采用的全量复制。\npsync 命令包含了主库的 runID 和复制进度 offset 两个参数。\n\n2、主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。\n主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。\n从库接收到 RDB 文件后，会先清空当前数据库（避免之前数据的影响），然后加载 RDB 文件。\n\n3、主库会把第二阶段执行过程中新收到的写命令(replication buffer中的修改操作)，再发送给从库。\n主库会在内存中使用 replication buffer，记录 RDB 文件生成后收到的所有写操作。\n\n![主从第一次同步](zhucongtongbu.jpg)\n\n## 主从级联\n\n### 问题\n\n- 从库数量很多且都要和主库进行全量复制时，会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。\n\n- 传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。\n\n### 解决\n\n通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上\n\n![级联的“主-从-从”模式](master_slave_slave.jpg)\n\n\n\n## 网络闪断\n\n网络闪断后，主从库会采用增量复制的方式继续同步。\n\n### 增量复制机制\n\n- 主库把断连期间收到的写操作命令写入 repl_backlog_buffer 缓冲区\n\n- repl_backlog_buffer 是一个环形缓冲区，主库会记录写到的位置，从库会记录已经读到的位置。\n- 连接恢复后，从库给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断 master_repl_offset 和 slave_repl_offset 之间的差距。把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库。\n- 库还未读取的操作被主库新写的操作覆盖，需要全量复制\n\n### 应对\n\n- repl_backlog_size 设置一个合理的值\n\n- 使用切片集群来分担单个主库的请求压力\n\n## 主从数据不一致\n\n根本原因：主从库间的命令复制是异步进行的\n\n直接原因：\n\n- 主从库间的网络可能会有传输延迟\n- 处理其它复杂度高的命令（例如集合操作命令）而阻塞同步\n- 主从库设置的 maxmemory 不同，如果 slave 比 master 小，那么 slave 内存就会优先达到 maxmemroy，然后开始淘汰数据，此时主从库也会产生不一致\n\n解决方法\n\n- 尽量保证主从库间的网络连接状况良好\n- 外部程序监控主从库间的复制进度（INFO replication ），依据从库和主库间的复制进度，设置客户端从库连接\n\n## 读取数据过期\n\n### 过期策略\n\n定期删除策略：Redis 每隔一段时间（默认 100ms），就会随机选出一定数量的数据，检查它们是否过期，并把其中过期的数据删除\n\n**惰性删除策略**：数据只有被再次访问时，才会被实际删除。从库本身不会执行删除操作，如果客户端在从库中访问留存的过期数据，从库并不会触发数据删除。**在 3.2 版本后**，如果读取的数据已经过期了，从库虽然不会删除，但是会返回空值。\n\n### 过期命令\n\n- EXPIRE 和 PEXPIRE：它们给数据设置的是从命令执行时开始计算的存活时间；\n- **EXPIREAT 和 PEXPIREA**：它们会直接把数据的过期时间设置为具体的一个时间点\n\n当主从库全量同步时，如果主库接收到了一条 EXPIRE 命令，那么，主库会直接执行这条命令。这条命令会在全量同步完成后，发给从库执行。而从库在执行时，就会在**当前时间的基础上加上数据的存活时间**，从库上数据的过期时间就会比主库上延后了\n\n### 解决\n\n- 使用 Redis 3.2 及以上版本和惰性删除策略\n- 在业务应用中使用 EXPIREAT/PEXPIREAT 命令，把数据的过期时间设置为具体的时间点，避免读到过期数据\n\n### 同步异常\n\n`protected-mode`：yes ，哨兵实例只能在部署的服务器本地进行访问。no ，其他服务器也可以访问这个哨兵实例。同时，bind 配置项设置为其它哨兵实例的 IP 地址。\n\n`cluster-node-timeout`:实例响应心跳消息的超时时间。主从切换时间可能较长，就会导致实例的心跳超时（超出 cluster-node-timeout）。实例超时后，就会被 Redis Cluster 判断为异常。有半数以上的实例异常，会导致整个集群挂掉。\n\n## 其他\n\n`slave-serve-stale-data `: 从库能否处理数据读写命令，推荐设置为 no，从库只能服务 INFO、SLAVEOF 命令，避免在从库中读到不一致的数据。\n\n`slave-read-only `：设置从库能否处理写命令， yes 时，从库只能处理读请求，无法处理写请求。\n\n","source":"_posts/redis主从同步.md","raw":"---\ntitle: redis主从同步\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-25 16:30:01\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n[toc]\n\n主从库之间采用读写分离。\n读操作：主库、从库都可以接收；\n写操作：首先到主库执行，然后，主库将写操作同步给从库。\n![读写分离](duxiefenli.jpg)\n\n## 同步机制\n\n通过 `replicaof`（Redis 5.0 之前使用 `slaveof`）命令形成主库和从库的关系。\n\n1、主从库间建立连接、协商同步，为全量复制做准备。\n**从库和主库建立起连接，发送 psync 命令**，表示要进行数据同步，**主库确认回复**，FULLRESYNC响应表示第一次复制采用的全量复制。\npsync 命令包含了主库的 runID 和复制进度 offset 两个参数。\n\n2、主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。\n主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。\n从库接收到 RDB 文件后，会先清空当前数据库（避免之前数据的影响），然后加载 RDB 文件。\n\n3、主库会把第二阶段执行过程中新收到的写命令(replication buffer中的修改操作)，再发送给从库。\n主库会在内存中使用 replication buffer，记录 RDB 文件生成后收到的所有写操作。\n\n![主从第一次同步](zhucongtongbu.jpg)\n\n## 主从级联\n\n### 问题\n\n- 从库数量很多且都要和主库进行全量复制时，会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。\n\n- 传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。\n\n### 解决\n\n通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上\n\n![级联的“主-从-从”模式](master_slave_slave.jpg)\n\n\n\n## 网络闪断\n\n网络闪断后，主从库会采用增量复制的方式继续同步。\n\n### 增量复制机制\n\n- 主库把断连期间收到的写操作命令写入 repl_backlog_buffer 缓冲区\n\n- repl_backlog_buffer 是一个环形缓冲区，主库会记录写到的位置，从库会记录已经读到的位置。\n- 连接恢复后，从库给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断 master_repl_offset 和 slave_repl_offset 之间的差距。把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库。\n- 库还未读取的操作被主库新写的操作覆盖，需要全量复制\n\n### 应对\n\n- repl_backlog_size 设置一个合理的值\n\n- 使用切片集群来分担单个主库的请求压力\n\n## 主从数据不一致\n\n根本原因：主从库间的命令复制是异步进行的\n\n直接原因：\n\n- 主从库间的网络可能会有传输延迟\n- 处理其它复杂度高的命令（例如集合操作命令）而阻塞同步\n- 主从库设置的 maxmemory 不同，如果 slave 比 master 小，那么 slave 内存就会优先达到 maxmemroy，然后开始淘汰数据，此时主从库也会产生不一致\n\n解决方法\n\n- 尽量保证主从库间的网络连接状况良好\n- 外部程序监控主从库间的复制进度（INFO replication ），依据从库和主库间的复制进度，设置客户端从库连接\n\n## 读取数据过期\n\n### 过期策略\n\n定期删除策略：Redis 每隔一段时间（默认 100ms），就会随机选出一定数量的数据，检查它们是否过期，并把其中过期的数据删除\n\n**惰性删除策略**：数据只有被再次访问时，才会被实际删除。从库本身不会执行删除操作，如果客户端在从库中访问留存的过期数据，从库并不会触发数据删除。**在 3.2 版本后**，如果读取的数据已经过期了，从库虽然不会删除，但是会返回空值。\n\n### 过期命令\n\n- EXPIRE 和 PEXPIRE：它们给数据设置的是从命令执行时开始计算的存活时间；\n- **EXPIREAT 和 PEXPIREA**：它们会直接把数据的过期时间设置为具体的一个时间点\n\n当主从库全量同步时，如果主库接收到了一条 EXPIRE 命令，那么，主库会直接执行这条命令。这条命令会在全量同步完成后，发给从库执行。而从库在执行时，就会在**当前时间的基础上加上数据的存活时间**，从库上数据的过期时间就会比主库上延后了\n\n### 解决\n\n- 使用 Redis 3.2 及以上版本和惰性删除策略\n- 在业务应用中使用 EXPIREAT/PEXPIREAT 命令，把数据的过期时间设置为具体的时间点，避免读到过期数据\n\n### 同步异常\n\n`protected-mode`：yes ，哨兵实例只能在部署的服务器本地进行访问。no ，其他服务器也可以访问这个哨兵实例。同时，bind 配置项设置为其它哨兵实例的 IP 地址。\n\n`cluster-node-timeout`:实例响应心跳消息的超时时间。主从切换时间可能较长，就会导致实例的心跳超时（超出 cluster-node-timeout）。实例超时后，就会被 Redis Cluster 判断为异常。有半数以上的实例异常，会导致整个集群挂掉。\n\n## 其他\n\n`slave-serve-stale-data `: 从库能否处理数据读写命令，推荐设置为 no，从库只能服务 INFO、SLAVEOF 命令，避免在从库中读到不一致的数据。\n\n`slave-read-only `：设置从库能否处理写命令， yes 时，从库只能处理读请求，无法处理写请求。\n\n","slug":"redis主从同步","published":1,"updated":"2020-11-02T13:20:17.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w9a0016i4ufulvvykz4","content":"<p>[toc]</p>\n<p>主从库之间采用读写分离。<br>读操作：主库、从库都可以接收；<br>写操作：首先到主库执行，然后，主库将写操作同步给从库。<br><img src=\"duxiefenli.jpg\" alt=\"读写分离\"></p>\n<h2 id=\"同步机制\"><a href=\"#同步机制\" class=\"headerlink\" title=\"同步机制\"></a>同步机制</h2><p>通过 <code>replicaof</code>（Redis 5.0 之前使用 <code>slaveof</code>）命令形成主库和从库的关系。</p>\n<p>1、主从库间建立连接、协商同步，为全量复制做准备。<br><strong>从库和主库建立起连接，发送 psync 命令</strong>，表示要进行数据同步，<strong>主库确认回复</strong>，FULLRESYNC响应表示第一次复制采用的全量复制。<br>psync 命令包含了主库的 runID 和复制进度 offset 两个参数。</p>\n<p>2、主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。<br>主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。<br>从库接收到 RDB 文件后，会先清空当前数据库（避免之前数据的影响），然后加载 RDB 文件。</p>\n<p>3、主库会把第二阶段执行过程中新收到的写命令(replication buffer中的修改操作)，再发送给从库。<br>主库会在内存中使用 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p>\n<p><img src=\"zhucongtongbu.jpg\" alt=\"主从第一次同步\"></p>\n<h2 id=\"主从级联\"><a href=\"#主从级联\" class=\"headerlink\" title=\"主从级联\"></a>主从级联</h2><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ul>\n<li><p>从库数量很多且都要和主库进行全量复制时，会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。</p>\n</li>\n<li><p>传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。</p>\n</li>\n</ul>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</p>\n<p><img src=\"master_slave_slave.jpg\" alt=\"级联的“主-从-从”模式\"></p>\n<h2 id=\"网络闪断\"><a href=\"#网络闪断\" class=\"headerlink\" title=\"网络闪断\"></a>网络闪断</h2><p>网络闪断后，主从库会采用增量复制的方式继续同步。</p>\n<h3 id=\"增量复制机制\"><a href=\"#增量复制机制\" class=\"headerlink\" title=\"增量复制机制\"></a>增量复制机制</h3><ul>\n<li><p>主库把断连期间收到的写操作命令写入 repl_backlog_buffer 缓冲区</p>\n</li>\n<li><p>repl_backlog_buffer 是一个环形缓冲区，主库会记录写到的位置，从库会记录已经读到的位置。</p>\n</li>\n<li><p>连接恢复后，从库给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断 master_repl_offset 和 slave_repl_offset 之间的差距。把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库。</p>\n</li>\n<li><p>库还未读取的操作被主库新写的操作覆盖，需要全量复制</p>\n</li>\n</ul>\n<h3 id=\"应对\"><a href=\"#应对\" class=\"headerlink\" title=\"应对\"></a>应对</h3><ul>\n<li><p>repl_backlog_size 设置一个合理的值</p>\n</li>\n<li><p>使用切片集群来分担单个主库的请求压力</p>\n</li>\n</ul>\n<h2 id=\"主从数据不一致\"><a href=\"#主从数据不一致\" class=\"headerlink\" title=\"主从数据不一致\"></a>主从数据不一致</h2><p>根本原因：主从库间的命令复制是异步进行的</p>\n<p>直接原因：</p>\n<ul>\n<li>主从库间的网络可能会有传输延迟</li>\n<li>处理其它复杂度高的命令（例如集合操作命令）而阻塞同步</li>\n<li>主从库设置的 maxmemory 不同，如果 slave 比 master 小，那么 slave 内存就会优先达到 maxmemroy，然后开始淘汰数据，此时主从库也会产生不一致</li>\n</ul>\n<p>解决方法</p>\n<ul>\n<li>尽量保证主从库间的网络连接状况良好</li>\n<li>外部程序监控主从库间的复制进度（INFO replication ），依据从库和主库间的复制进度，设置客户端从库连接</li>\n</ul>\n<h2 id=\"读取数据过期\"><a href=\"#读取数据过期\" class=\"headerlink\" title=\"读取数据过期\"></a>读取数据过期</h2><h3 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h3><p>定期删除策略：Redis 每隔一段时间（默认 100ms），就会随机选出一定数量的数据，检查它们是否过期，并把其中过期的数据删除</p>\n<p><strong>惰性删除策略</strong>：数据只有被再次访问时，才会被实际删除。从库本身不会执行删除操作，如果客户端在从库中访问留存的过期数据，从库并不会触发数据删除。<strong>在 3.2 版本后</strong>，如果读取的数据已经过期了，从库虽然不会删除，但是会返回空值。</p>\n<h3 id=\"过期命令\"><a href=\"#过期命令\" class=\"headerlink\" title=\"过期命令\"></a>过期命令</h3><ul>\n<li>EXPIRE 和 PEXPIRE：它们给数据设置的是从命令执行时开始计算的存活时间；</li>\n<li><strong>EXPIREAT 和 PEXPIREA</strong>：它们会直接把数据的过期时间设置为具体的一个时间点</li>\n</ul>\n<p>当主从库全量同步时，如果主库接收到了一条 EXPIRE 命令，那么，主库会直接执行这条命令。这条命令会在全量同步完成后，发给从库执行。而从库在执行时，就会在<strong>当前时间的基础上加上数据的存活时间</strong>，从库上数据的过期时间就会比主库上延后了</p>\n<h3 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决\"></a>解决</h3><ul>\n<li>使用 Redis 3.2 及以上版本和惰性删除策略</li>\n<li>在业务应用中使用 EXPIREAT/PEXPIREAT 命令，把数据的过期时间设置为具体的时间点，避免读到过期数据</li>\n</ul>\n<h3 id=\"同步异常\"><a href=\"#同步异常\" class=\"headerlink\" title=\"同步异常\"></a>同步异常</h3><p><code>protected-mode</code>：yes ，哨兵实例只能在部署的服务器本地进行访问。no ，其他服务器也可以访问这个哨兵实例。同时，bind 配置项设置为其它哨兵实例的 IP 地址。</p>\n<p><code>cluster-node-timeout</code>:实例响应心跳消息的超时时间。主从切换时间可能较长，就会导致实例的心跳超时（超出 cluster-node-timeout）。实例超时后，就会被 Redis Cluster 判断为异常。有半数以上的实例异常，会导致整个集群挂掉。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p><code>slave-serve-stale-data</code>: 从库能否处理数据读写命令，推荐设置为 no，从库只能服务 INFO、SLAVEOF 命令，避免在从库中读到不一致的数据。</p>\n<p><code>slave-read-only</code>：设置从库能否处理写命令， yes 时，从库只能处理读请求，无法处理写请求。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<p>[toc]</p>\n<p>主从库之间采用读写分离。<br>读操作：主库、从库都可以接收；<br>写操作：首先到主库执行，然后，主库将写操作同步给从库。<br><img src=\"duxiefenli.jpg\" alt=\"读写分离\"></p>\n<h2 id=\"同步机制\"><a href=\"#同步机制\" class=\"headerlink\" title=\"同步机制\"></a>同步机制</h2><p>通过 <code>replicaof</code>（Redis 5.0 之前使用 <code>slaveof</code>）命令形成主库和从库的关系。</p>\n<p>1、主从库间建立连接、协商同步，为全量复制做准备。<br><strong>从库和主库建立起连接，发送 psync 命令</strong>，表示要进行数据同步，<strong>主库确认回复</strong>，FULLRESYNC响应表示第一次复制采用的全量复制。<br>psync 命令包含了主库的 runID 和复制进度 offset 两个参数。</p>\n<p>2、主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。<br>主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。<br>从库接收到 RDB 文件后，会先清空当前数据库（避免之前数据的影响），然后加载 RDB 文件。</p>\n<p>3、主库会把第二阶段执行过程中新收到的写命令(replication buffer中的修改操作)，再发送给从库。<br>主库会在内存中使用 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p>\n<p><img src=\"zhucongtongbu.jpg\" alt=\"主从第一次同步\"></p>\n<h2 id=\"主从级联\"><a href=\"#主从级联\" class=\"headerlink\" title=\"主从级联\"></a>主从级联</h2><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ul>\n<li><p>从库数量很多且都要和主库进行全量复制时，会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。</p>\n</li>\n<li><p>传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。</p>\n</li>\n</ul>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</p>\n<p><img src=\"master_slave_slave.jpg\" alt=\"级联的“主-从-从”模式\"></p>\n<h2 id=\"网络闪断\"><a href=\"#网络闪断\" class=\"headerlink\" title=\"网络闪断\"></a>网络闪断</h2><p>网络闪断后，主从库会采用增量复制的方式继续同步。</p>\n<h3 id=\"增量复制机制\"><a href=\"#增量复制机制\" class=\"headerlink\" title=\"增量复制机制\"></a>增量复制机制</h3><ul>\n<li><p>主库把断连期间收到的写操作命令写入 repl_backlog_buffer 缓冲区</p>\n</li>\n<li><p>repl_backlog_buffer 是一个环形缓冲区，主库会记录写到的位置，从库会记录已经读到的位置。</p>\n</li>\n<li><p>连接恢复后，从库给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断 master_repl_offset 和 slave_repl_offset 之间的差距。把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库。</p>\n</li>\n<li><p>库还未读取的操作被主库新写的操作覆盖，需要全量复制</p>\n</li>\n</ul>\n<h3 id=\"应对\"><a href=\"#应对\" class=\"headerlink\" title=\"应对\"></a>应对</h3><ul>\n<li><p>repl_backlog_size 设置一个合理的值</p>\n</li>\n<li><p>使用切片集群来分担单个主库的请求压力</p>\n</li>\n</ul>\n<h2 id=\"主从数据不一致\"><a href=\"#主从数据不一致\" class=\"headerlink\" title=\"主从数据不一致\"></a>主从数据不一致</h2><p>根本原因：主从库间的命令复制是异步进行的</p>\n<p>直接原因：</p>\n<ul>\n<li>主从库间的网络可能会有传输延迟</li>\n<li>处理其它复杂度高的命令（例如集合操作命令）而阻塞同步</li>\n<li>主从库设置的 maxmemory 不同，如果 slave 比 master 小，那么 slave 内存就会优先达到 maxmemroy，然后开始淘汰数据，此时主从库也会产生不一致</li>\n</ul>\n<p>解决方法</p>\n<ul>\n<li>尽量保证主从库间的网络连接状况良好</li>\n<li>外部程序监控主从库间的复制进度（INFO replication ），依据从库和主库间的复制进度，设置客户端从库连接</li>\n</ul>\n<h2 id=\"读取数据过期\"><a href=\"#读取数据过期\" class=\"headerlink\" title=\"读取数据过期\"></a>读取数据过期</h2><h3 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h3><p>定期删除策略：Redis 每隔一段时间（默认 100ms），就会随机选出一定数量的数据，检查它们是否过期，并把其中过期的数据删除</p>\n<p><strong>惰性删除策略</strong>：数据只有被再次访问时，才会被实际删除。从库本身不会执行删除操作，如果客户端在从库中访问留存的过期数据，从库并不会触发数据删除。<strong>在 3.2 版本后</strong>，如果读取的数据已经过期了，从库虽然不会删除，但是会返回空值。</p>\n<h3 id=\"过期命令\"><a href=\"#过期命令\" class=\"headerlink\" title=\"过期命令\"></a>过期命令</h3><ul>\n<li>EXPIRE 和 PEXPIRE：它们给数据设置的是从命令执行时开始计算的存活时间；</li>\n<li><strong>EXPIREAT 和 PEXPIREA</strong>：它们会直接把数据的过期时间设置为具体的一个时间点</li>\n</ul>\n<p>当主从库全量同步时，如果主库接收到了一条 EXPIRE 命令，那么，主库会直接执行这条命令。这条命令会在全量同步完成后，发给从库执行。而从库在执行时，就会在<strong>当前时间的基础上加上数据的存活时间</strong>，从库上数据的过期时间就会比主库上延后了</p>\n<h3 id=\"解决-1\"><a href=\"#解决-1\" class=\"headerlink\" title=\"解决\"></a>解决</h3><ul>\n<li>使用 Redis 3.2 及以上版本和惰性删除策略</li>\n<li>在业务应用中使用 EXPIREAT/PEXPIREAT 命令，把数据的过期时间设置为具体的时间点，避免读到过期数据</li>\n</ul>\n<h3 id=\"同步异常\"><a href=\"#同步异常\" class=\"headerlink\" title=\"同步异常\"></a>同步异常</h3><p><code>protected-mode</code>：yes ，哨兵实例只能在部署的服务器本地进行访问。no ，其他服务器也可以访问这个哨兵实例。同时，bind 配置项设置为其它哨兵实例的 IP 地址。</p>\n<p><code>cluster-node-timeout</code>:实例响应心跳消息的超时时间。主从切换时间可能较长，就会导致实例的心跳超时（超出 cluster-node-timeout）。实例超时后，就会被 Redis Cluster 判断为异常。有半数以上的实例异常，会导致整个集群挂掉。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p><code>slave-serve-stale-data</code>: 从库能否处理数据读写命令，推荐设置为 no，从库只能服务 INFO、SLAVEOF 命令，避免在从库中读到不一致的数据。</p>\n<p><code>slave-read-only</code>：设置从库能否处理写命令， yes 时，从库只能处理读请求，无法处理写请求。</p>\n"},{"title":"redis事务","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-11-01T05:28:57.000Z","password":null,"summary":null,"_content":"\n## 事务实现\n\n### 基本命令\n\n- MULTI\n\n显式地表示一个事务的开启，把这些命令暂存到一个命令队列中\n\n- EXEC \n\n实际执行命令队列中的所有命令\n\n- DISCARD\n\n主动放弃事务执行，把暂存的命令队列清空（起不到回滚的效果）\n\n- WATCH\n\n在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行。\n\n### 异常分析\n\n1、客户端发送的操作命令中存在语法错误\n\n拒绝执行所有提交的命令操作，返回事务失败\n\n2、命令和操作的数据类型不匹配，但 Redis 实例没有检查出错误\n\nRedis 对错误命令报错，但正确的命令也会执行。（事务的原子性就无法得到保证）\n\n3、在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败\n\n- 如 Redis 开启了 AOF 日志，那么，只会有部分的事务操作被记录到 AOF 日志中。\n\n使用 redis-check-aof 工具检查 AOF 日志文件，可把已完成的事务操作从 AOF 文件中去除。使用 AOF 恢复实例后，事务操作不会再被执行，从而保证了原子性。\n\n- 如 AOF 日志没有开启，那么实例重启后，数据没法恢复了，此时，也就谈不上原子性了。","source":"_posts/redis事务.md","raw":"---\ntitle: redis事务\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-11-01 13:28:57\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## 事务实现\n\n### 基本命令\n\n- MULTI\n\n显式地表示一个事务的开启，把这些命令暂存到一个命令队列中\n\n- EXEC \n\n实际执行命令队列中的所有命令\n\n- DISCARD\n\n主动放弃事务执行，把暂存的命令队列清空（起不到回滚的效果）\n\n- WATCH\n\n在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行。\n\n### 异常分析\n\n1、客户端发送的操作命令中存在语法错误\n\n拒绝执行所有提交的命令操作，返回事务失败\n\n2、命令和操作的数据类型不匹配，但 Redis 实例没有检查出错误\n\nRedis 对错误命令报错，但正确的命令也会执行。（事务的原子性就无法得到保证）\n\n3、在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败\n\n- 如 Redis 开启了 AOF 日志，那么，只会有部分的事务操作被记录到 AOF 日志中。\n\n使用 redis-check-aof 工具检查 AOF 日志文件，可把已完成的事务操作从 AOF 文件中去除。使用 AOF 恢复实例后，事务操作不会再被执行，从而保证了原子性。\n\n- 如 AOF 日志没有开启，那么实例重启后，数据没法恢复了，此时，也就谈不上原子性了。","slug":"redis事务","published":1,"updated":"2020-11-01T13:00:22.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w9d0019i4ufz2thty9o","content":"<h2 id=\"事务实现\"><a href=\"#事务实现\" class=\"headerlink\" title=\"事务实现\"></a>事务实现</h2><h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ul>\n<li>MULTI</li>\n</ul>\n<p>显式地表示一个事务的开启，把这些命令暂存到一个命令队列中</p>\n<ul>\n<li>EXEC </li>\n</ul>\n<p>实际执行命令队列中的所有命令</p>\n<ul>\n<li>DISCARD</li>\n</ul>\n<p>主动放弃事务执行，把暂存的命令队列清空（起不到回滚的效果）</p>\n<ul>\n<li>WATCH</li>\n</ul>\n<p>在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行。</p>\n<h3 id=\"异常分析\"><a href=\"#异常分析\" class=\"headerlink\" title=\"异常分析\"></a>异常分析</h3><p>1、客户端发送的操作命令中存在语法错误</p>\n<p>拒绝执行所有提交的命令操作，返回事务失败</p>\n<p>2、命令和操作的数据类型不匹配，但 Redis 实例没有检查出错误</p>\n<p>Redis 对错误命令报错，但正确的命令也会执行。（事务的原子性就无法得到保证）</p>\n<p>3、在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败</p>\n<ul>\n<li>如 Redis 开启了 AOF 日志，那么，只会有部分的事务操作被记录到 AOF 日志中。</li>\n</ul>\n<p>使用 redis-check-aof 工具检查 AOF 日志文件，可把已完成的事务操作从 AOF 文件中去除。使用 AOF 恢复实例后，事务操作不会再被执行，从而保证了原子性。</p>\n<ul>\n<li>如 AOF 日志没有开启，那么实例重启后，数据没法恢复了，此时，也就谈不上原子性了。</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"事务实现\"><a href=\"#事务实现\" class=\"headerlink\" title=\"事务实现\"></a>事务实现</h2><h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ul>\n<li>MULTI</li>\n</ul>\n<p>显式地表示一个事务的开启，把这些命令暂存到一个命令队列中</p>\n<ul>\n<li>EXEC </li>\n</ul>\n<p>实际执行命令队列中的所有命令</p>\n<ul>\n<li>DISCARD</li>\n</ul>\n<p>主动放弃事务执行，把暂存的命令队列清空（起不到回滚的效果）</p>\n<ul>\n<li>WATCH</li>\n</ul>\n<p>在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行。</p>\n<h3 id=\"异常分析\"><a href=\"#异常分析\" class=\"headerlink\" title=\"异常分析\"></a>异常分析</h3><p>1、客户端发送的操作命令中存在语法错误</p>\n<p>拒绝执行所有提交的命令操作，返回事务失败</p>\n<p>2、命令和操作的数据类型不匹配，但 Redis 实例没有检查出错误</p>\n<p>Redis 对错误命令报错，但正确的命令也会执行。（事务的原子性就无法得到保证）</p>\n<p>3、在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败</p>\n<ul>\n<li>如 Redis 开启了 AOF 日志，那么，只会有部分的事务操作被记录到 AOF 日志中。</li>\n</ul>\n<p>使用 redis-check-aof 工具检查 AOF 日志文件，可把已完成的事务操作从 AOF 文件中去除。使用 AOF 恢复实例后，事务操作不会再被执行，从而保证了原子性。</p>\n<ul>\n<li>如 AOF 日志没有开启，那么实例重启后，数据没法恢复了，此时，也就谈不上原子性了。</li>\n</ul>\n"},{"title":"redis内存碎片","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-11-02T13:35:08.000Z","password":null,"summary":null,"_content":"","source":"_posts/redis内存碎片.md","raw":"---\ntitle: redis内存碎片\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-11-02 21:35:08\npassword:\nsummary:\ntags:\ncategories:\n---\n","slug":"redis内存碎片","published":1,"updated":"2020-11-02T13:35:08.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w9g001di4ufzz4z2hek","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":""},{"title":"redis分布式锁","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-29T15:52:36.000Z","password":null,"summary":null,"_content":"\n\n\n为了保证并发访问的正确性，Redis 提供了两种方法，分别是加锁和原子操作。\n\n## redis原子操作\n\n- 单命令操作（INCR/DECR）；\n- 把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本\n\n## 分布式锁\n\n- 分布式锁的加锁和释放锁的过程，涉及多个操作。需要保证这些锁操作的原子性；\n\n- 共享存储系统保存了锁变量，需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。\n\n### 单个 Redis 节点的分布式锁\n\n- **SETNX key value**\n\nkey 不存在， key 会被创建。执行完业务逻辑后，使用 DEL 命令删除锁变量，从而释放锁。\n\n**可能风险：**\n\n  - 操作共享数据时发生了异常，结果一直没有执行最后的 DEL 命令释放锁。\n  - 客户端 A 执行了 SETNX 命令加锁后，客户端 B 执行了 DEL 命令释放锁，客户端 A 的锁就被误释放\n\n+ SET key value [EX seconds | PX milliseconds]  [NX]\n\n### 多个 Redis 节点的高可靠分布式锁\n\n分布式锁算法 Redlock\n\n- 客户端获取当前时间。\n- 客户端按顺序依次向 N 个 Redis 实例执行加锁操作。\n- 一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时\n\n**加锁成功条件**\n\n- 客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；\n\n- 客户端获取锁的总耗时没有超过锁的有效时间。","source":"_posts/redis分布式锁.md","raw":"---\ntitle: redis分布式锁\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-29 23:52:36\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n\n\n为了保证并发访问的正确性，Redis 提供了两种方法，分别是加锁和原子操作。\n\n## redis原子操作\n\n- 单命令操作（INCR/DECR）；\n- 把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本\n\n## 分布式锁\n\n- 分布式锁的加锁和释放锁的过程，涉及多个操作。需要保证这些锁操作的原子性；\n\n- 共享存储系统保存了锁变量，需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。\n\n### 单个 Redis 节点的分布式锁\n\n- **SETNX key value**\n\nkey 不存在， key 会被创建。执行完业务逻辑后，使用 DEL 命令删除锁变量，从而释放锁。\n\n**可能风险：**\n\n  - 操作共享数据时发生了异常，结果一直没有执行最后的 DEL 命令释放锁。\n  - 客户端 A 执行了 SETNX 命令加锁后，客户端 B 执行了 DEL 命令释放锁，客户端 A 的锁就被误释放\n\n+ SET key value [EX seconds | PX milliseconds]  [NX]\n\n### 多个 Redis 节点的高可靠分布式锁\n\n分布式锁算法 Redlock\n\n- 客户端获取当前时间。\n- 客户端按顺序依次向 N 个 Redis 实例执行加锁操作。\n- 一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时\n\n**加锁成功条件**\n\n- 客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；\n\n- 客户端获取锁的总耗时没有超过锁的有效时间。","slug":"redis分布式锁","published":1,"updated":"2020-11-01T05:25:04.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w9i001fi4uf3t5z0cq8","content":"<p>为了保证并发访问的正确性，Redis 提供了两种方法，分别是加锁和原子操作。</p>\n<h2 id=\"redis原子操作\"><a href=\"#redis原子操作\" class=\"headerlink\" title=\"redis原子操作\"></a>redis原子操作</h2><ul>\n<li>单命令操作（INCR/DECR）；</li>\n<li>把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本</li>\n</ul>\n<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><ul>\n<li><p>分布式锁的加锁和释放锁的过程，涉及多个操作。需要保证这些锁操作的原子性；</p>\n</li>\n<li><p>共享存储系统保存了锁变量，需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。</p>\n</li>\n</ul>\n<h3 id=\"单个-Redis-节点的分布式锁\"><a href=\"#单个-Redis-节点的分布式锁\" class=\"headerlink\" title=\"单个 Redis 节点的分布式锁\"></a>单个 Redis 节点的分布式锁</h3><ul>\n<li><strong>SETNX key value</strong></li>\n</ul>\n<p>key 不存在， key 会被创建。执行完业务逻辑后，使用 DEL 命令删除锁变量，从而释放锁。</p>\n<p><strong>可能风险：</strong></p>\n<ul>\n<li>操作共享数据时发生了异常，结果一直没有执行最后的 DEL 命令释放锁。</li>\n<li>客户端 A 执行了 SETNX 命令加锁后，客户端 B 执行了 DEL 命令释放锁，客户端 A 的锁就被误释放</li>\n</ul>\n<ul>\n<li>SET key value [EX seconds | PX milliseconds]  [NX]</li>\n</ul>\n<h3 id=\"多个-Redis-节点的高可靠分布式锁\"><a href=\"#多个-Redis-节点的高可靠分布式锁\" class=\"headerlink\" title=\"多个 Redis 节点的高可靠分布式锁\"></a>多个 Redis 节点的高可靠分布式锁</h3><p>分布式锁算法 Redlock</p>\n<ul>\n<li>客户端获取当前时间。</li>\n<li>客户端按顺序依次向 N 个 Redis 实例执行加锁操作。</li>\n<li>一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时</li>\n</ul>\n<p><strong>加锁成功条件</strong></p>\n<ul>\n<li><p>客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；</p>\n</li>\n<li><p>客户端获取锁的总耗时没有超过锁的有效时间。</p>\n</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<p>为了保证并发访问的正确性，Redis 提供了两种方法，分别是加锁和原子操作。</p>\n<h2 id=\"redis原子操作\"><a href=\"#redis原子操作\" class=\"headerlink\" title=\"redis原子操作\"></a>redis原子操作</h2><ul>\n<li>单命令操作（INCR/DECR）；</li>\n<li>把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本</li>\n</ul>\n<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><ul>\n<li><p>分布式锁的加锁和释放锁的过程，涉及多个操作。需要保证这些锁操作的原子性；</p>\n</li>\n<li><p>共享存储系统保存了锁变量，需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。</p>\n</li>\n</ul>\n<h3 id=\"单个-Redis-节点的分布式锁\"><a href=\"#单个-Redis-节点的分布式锁\" class=\"headerlink\" title=\"单个 Redis 节点的分布式锁\"></a>单个 Redis 节点的分布式锁</h3><ul>\n<li><strong>SETNX key value</strong></li>\n</ul>\n<p>key 不存在， key 会被创建。执行完业务逻辑后，使用 DEL 命令删除锁变量，从而释放锁。</p>\n<p><strong>可能风险：</strong></p>\n<ul>\n<li>操作共享数据时发生了异常，结果一直没有执行最后的 DEL 命令释放锁。</li>\n<li>客户端 A 执行了 SETNX 命令加锁后，客户端 B 执行了 DEL 命令释放锁，客户端 A 的锁就被误释放</li>\n</ul>\n<ul>\n<li>SET key value [EX seconds | PX milliseconds]  [NX]</li>\n</ul>\n<h3 id=\"多个-Redis-节点的高可靠分布式锁\"><a href=\"#多个-Redis-节点的高可靠分布式锁\" class=\"headerlink\" title=\"多个 Redis 节点的高可靠分布式锁\"></a>多个 Redis 节点的高可靠分布式锁</h3><p>分布式锁算法 Redlock</p>\n<ul>\n<li>客户端获取当前时间。</li>\n<li>客户端按顺序依次向 N 个 Redis 实例执行加锁操作。</li>\n<li>一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时</li>\n</ul>\n<p><strong>加锁成功条件</strong></p>\n<ul>\n<li><p>客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；</p>\n</li>\n<li><p>客户端获取锁的总耗时没有超过锁的有效时间。</p>\n</li>\n</ul>\n"},{"title":"redis切片集群","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T12:32:35.000Z","password":null,"summary":null,"_content":"\n## 问题\n\n RDB 持久化时，fork 子进程用时和 Redis 的数据量是正相关的。数据量越大，fork 操作造成的主线程阻塞的时间越长。\n\n## 切片集群机制\n\n- 一个切片集群共有 16384 个哈希槽，哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。\n- 映射方法：按照CRC16 算法计算一个 16 bit 的值；再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，对应相应编号的哈希槽\n- Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。\n- 客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端\n\n## 难点\n\n- 集群实例有新增或删除，Redis 需要重新分配哈希槽；\n- 为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。\n\n## 解决方法\n\n**重定向机制**，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，实例返回的 MOVED 命令响应，其中包含了新实例的访问地址，客户端给对应新实例发送操作命令（客户端更新了本地缓存）。\n\n注：如果数据在实例中迁移到一半，实例返回ASK 报错信息，表明 Slot 数据还在迁移中，并返回最新实例地址（客户端不更新本地缓存）。","source":"_posts/redis切片集群.md","raw":"---\ntitle: redis切片集群\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 20:32:35\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## 问题\n\n RDB 持久化时，fork 子进程用时和 Redis 的数据量是正相关的。数据量越大，fork 操作造成的主线程阻塞的时间越长。\n\n## 切片集群机制\n\n- 一个切片集群共有 16384 个哈希槽，哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。\n- 映射方法：按照CRC16 算法计算一个 16 bit 的值；再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，对应相应编号的哈希槽\n- Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。\n- 客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端\n\n## 难点\n\n- 集群实例有新增或删除，Redis 需要重新分配哈希槽；\n- 为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。\n\n## 解决方法\n\n**重定向机制**，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，实例返回的 MOVED 命令响应，其中包含了新实例的访问地址，客户端给对应新实例发送操作命令（客户端更新了本地缓存）。\n\n注：如果数据在实例中迁移到一半，实例返回ASK 报错信息，表明 Slot 数据还在迁移中，并返回最新实例地址（客户端不更新本地缓存）。","slug":"redis切片集群","published":1,"updated":"2021-03-07T11:43:34.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w9m001ji4uft4z787p7","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p> RDB 持久化时，fork 子进程用时和 Redis 的数据量是正相关的。数据量越大，fork 操作造成的主线程阻塞的时间越长。</p>\n<h2 id=\"切片集群机制\"><a href=\"#切片集群机制\" class=\"headerlink\" title=\"切片集群机制\"></a>切片集群机制</h2><ul>\n<li>一个切片集群共有 16384 个哈希槽，哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</li>\n<li>映射方法：按照CRC16 算法计算一个 16 bit 的值；再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，对应相应编号的哈希槽</li>\n<li>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。</li>\n<li>客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端</li>\n</ul>\n<h2 id=\"难点\"><a href=\"#难点\" class=\"headerlink\" title=\"难点\"></a>难点</h2><ul>\n<li>集群实例有新增或删除，Redis 需要重新分配哈希槽；</li>\n<li>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</li>\n</ul>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p><strong>重定向机制</strong>，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，实例返回的 MOVED 命令响应，其中包含了新实例的访问地址，客户端给对应新实例发送操作命令（客户端更新了本地缓存）。</p>\n<p>注：如果数据在实例中迁移到一半，实例返回ASK 报错信息，表明 Slot 数据还在迁移中，并返回最新实例地址（客户端不更新本地缓存）。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p> RDB 持久化时，fork 子进程用时和 Redis 的数据量是正相关的。数据量越大，fork 操作造成的主线程阻塞的时间越长。</p>\n<h2 id=\"切片集群机制\"><a href=\"#切片集群机制\" class=\"headerlink\" title=\"切片集群机制\"></a>切片集群机制</h2><ul>\n<li>一个切片集群共有 16384 个哈希槽，哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</li>\n<li>映射方法：按照CRC16 算法计算一个 16 bit 的值；再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，对应相应编号的哈希槽</li>\n<li>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。</li>\n<li>客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端</li>\n</ul>\n<h2 id=\"难点\"><a href=\"#难点\" class=\"headerlink\" title=\"难点\"></a>难点</h2><ul>\n<li>集群实例有新增或删除，Redis 需要重新分配哈希槽；</li>\n<li>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</li>\n</ul>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p><strong>重定向机制</strong>，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，实例返回的 MOVED 命令响应，其中包含了新实例的访问地址，客户端给对应新实例发送操作命令（客户端更新了本地缓存）。</p>\n<p>注：如果数据在实例中迁移到一半，实例返回ASK 报错信息，表明 Slot 数据还在迁移中，并返回最新实例地址（客户端不更新本地缓存）。</p>\n"},{"title":"redis变慢以及优化方法","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T13:42:19.000Z","password":null,"summary":null,"_content":"\n## 确定问题\n\n1、查看 Redis 的响应延迟。\n2、基于当前环境下的 Redis 基线性能做判断\n基线性能是系统在低压力、无干扰下的基本性能，Redis 运行时延迟是其基线性能的 2 倍及以上，可认定 Redis 变慢了。\n\n\n## 问题定位\n\n1、通过 Redis 日志，或者是 latency monitor 工具，查询变慢的请求，确认是否采用了复杂度高的慢查询命令。\n2、检查业务代码在使用 EXPIREAT 命令设置 key 过期时间时，是否使用了相同的 UNIX 时间戳，有没有使用 EXPIRE 命令给批量的 key 设置相同的过期秒数。从而造成大量 key 在同一时间过期，导致性能变慢。删除操作是阻塞的（Redis 4.0 后可以用异步线程机制来减少阻塞影响）\n3、检查是否使用了慢查询命令，KEYS *xxx\n\n\n## 优化\n1.a.用其他高效命令代替。比如说，如果你需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，避免一次返回大量数据，造成线程阻塞。\n1.b.当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。\n\n2.如果一批 key 的确是同时过期，你还可以在 EXPIREAT 和 EXPIRE 的过期时间参数上，加上一个一定大小范围内的随机数\n\n3.获取整个实例的所有key，建议使用SCAN命令代替。客户端通过执行SCAN $cursor COUNT $count可以得到一批key以及下一个游标$cursor，然后把这个$cursor当作SCAN的参数，再次执行，以此往复，直到返回的$cursor为0时，就把整个实例中的所有key遍历出来了。","source":"_posts/redis变慢以及优化方法.md","raw":"---\ntitle: redis变慢以及优化方法\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 21:42:19\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## 确定问题\n\n1、查看 Redis 的响应延迟。\n2、基于当前环境下的 Redis 基线性能做判断\n基线性能是系统在低压力、无干扰下的基本性能，Redis 运行时延迟是其基线性能的 2 倍及以上，可认定 Redis 变慢了。\n\n\n## 问题定位\n\n1、通过 Redis 日志，或者是 latency monitor 工具，查询变慢的请求，确认是否采用了复杂度高的慢查询命令。\n2、检查业务代码在使用 EXPIREAT 命令设置 key 过期时间时，是否使用了相同的 UNIX 时间戳，有没有使用 EXPIRE 命令给批量的 key 设置相同的过期秒数。从而造成大量 key 在同一时间过期，导致性能变慢。删除操作是阻塞的（Redis 4.0 后可以用异步线程机制来减少阻塞影响）\n3、检查是否使用了慢查询命令，KEYS *xxx\n\n\n## 优化\n1.a.用其他高效命令代替。比如说，如果你需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，避免一次返回大量数据，造成线程阻塞。\n1.b.当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。\n\n2.如果一批 key 的确是同时过期，你还可以在 EXPIREAT 和 EXPIRE 的过期时间参数上，加上一个一定大小范围内的随机数\n\n3.获取整个实例的所有key，建议使用SCAN命令代替。客户端通过执行SCAN $cursor COUNT $count可以得到一批key以及下一个游标$cursor，然后把这个$cursor当作SCAN的参数，再次执行，以此往复，直到返回的$cursor为0时，就把整个实例中的所有key遍历出来了。","slug":"redis变慢以及优化方法","published":1,"updated":"2020-10-26T13:43:17.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w9q001li4ufqwyl9gxk","content":"<h2 id=\"确定问题\"><a href=\"#确定问题\" class=\"headerlink\" title=\"确定问题\"></a>确定问题</h2><p>1、查看 Redis 的响应延迟。<br>2、基于当前环境下的 Redis 基线性能做判断<br>基线性能是系统在低压力、无干扰下的基本性能，Redis 运行时延迟是其基线性能的 2 倍及以上，可认定 Redis 变慢了。</p>\n<h2 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h2><p>1、通过 Redis 日志，或者是 latency monitor 工具，查询变慢的请求，确认是否采用了复杂度高的慢查询命令。<br>2、检查业务代码在使用 EXPIREAT 命令设置 key 过期时间时，是否使用了相同的 UNIX 时间戳，有没有使用 EXPIRE 命令给批量的 key 设置相同的过期秒数。从而造成大量 key 在同一时间过期，导致性能变慢。删除操作是阻塞的（Redis 4.0 后可以用异步线程机制来减少阻塞影响）<br>3、检查是否使用了慢查询命令，KEYS *xxx</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>1.a.用其他高效命令代替。比如说，如果你需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，避免一次返回大量数据，造成线程阻塞。<br>1.b.当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。</p>\n<p>2.如果一批 key 的确是同时过期，你还可以在 EXPIREAT 和 EXPIRE 的过期时间参数上，加上一个一定大小范围内的随机数</p>\n<p>3.获取整个实例的所有key，建议使用SCAN命令代替。客户端通过执行SCAN $cursor COUNT $count可以得到一批key以及下一个游标$cursor，然后把这个$cursor当作SCAN的参数，再次执行，以此往复，直到返回的$cursor为0时，就把整个实例中的所有key遍历出来了。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"确定问题\"><a href=\"#确定问题\" class=\"headerlink\" title=\"确定问题\"></a>确定问题</h2><p>1、查看 Redis 的响应延迟。<br>2、基于当前环境下的 Redis 基线性能做判断<br>基线性能是系统在低压力、无干扰下的基本性能，Redis 运行时延迟是其基线性能的 2 倍及以上，可认定 Redis 变慢了。</p>\n<h2 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h2><p>1、通过 Redis 日志，或者是 latency monitor 工具，查询变慢的请求，确认是否采用了复杂度高的慢查询命令。<br>2、检查业务代码在使用 EXPIREAT 命令设置 key 过期时间时，是否使用了相同的 UNIX 时间戳，有没有使用 EXPIRE 命令给批量的 key 设置相同的过期秒数。从而造成大量 key 在同一时间过期，导致性能变慢。删除操作是阻塞的（Redis 4.0 后可以用异步线程机制来减少阻塞影响）<br>3、检查是否使用了慢查询命令，KEYS *xxx</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>1.a.用其他高效命令代替。比如说，如果你需要返回一个 SET 中的所有成员时，不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回，避免一次返回大量数据，造成线程阻塞。<br>1.b.当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。</p>\n<p>2.如果一批 key 的确是同时过期，你还可以在 EXPIREAT 和 EXPIRE 的过期时间参数上，加上一个一定大小范围内的随机数</p>\n<p>3.获取整个实例的所有key，建议使用SCAN命令代替。客户端通过执行SCAN $cursor COUNT $count可以得到一批key以及下一个游标$cursor，然后把这个$cursor当作SCAN的参数，再次执行，以此往复，直到返回的$cursor为0时，就把整个实例中的所有key遍历出来了。</p>\n"},{"title":"redis哨兵机制","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-25T13:16:39.000Z","password":null,"summary":null,"_content":"\n## 问题\n\n主库故障的相关问题：\n\n1、确定主库故障\n\n2、选择新的主库\n\n3、新主库信息通知\n\n## 基本功能\n\n### 监控\n\n- 哨兵进程周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。\n\n- 主库或从库对 PING 命令的响应超时了，哨兵会标记为“主观下线”。\n\n- 需有quorum 个实例判断主库为“主观下线”，才能判定主库为“客观下线”\n\n### 选主\n\n- 筛选当前在线从库，且网络连接状况较好；\n\n- 选择从库优先级最高的从库\n\n- 选择从库复制进度最快的\n\n- 选择从库 ID 号小的\n\n### 通知\n\n- 通知从库执行replicaof，与新主库同步\n- 通知客户端，像新主库请求\n\n**通知客户端**的实现方法\n\n1、哨兵会把新主库的地址写入自己实例的pubsub中。客户端需要订阅这个pubsub，当这个pubsub有数据时，客户端就能感知到主库发生变更，同时可以拿到最新的主库地址。\n\n2、客户端需要支持主动去获取最新主从的地址进行访问。\n\n## 哨兵集群pub/sub\n\n**连接关系的实现**\n\n- 哨兵-哨兵：哨兵订阅主库上的“__sentinel__:hello”，实现哨兵连接信息的发布获取\n- 哨兵-从库：哨兵给主库发送 INFO 命令，主库接受到后，返回从库列表。从而哨兵可以连接从库\n- 哨兵-客户端：客户端订阅哨兵消息\n\n\n**哨兵Leader竞选 （总从切换）**\n\n1、拿到半数以上的赞成票；\n\n2、拿到的票数同时还需要大于等于仲裁所需的赞成票数（quorum ）。","source":"_posts/redis哨兵机制.md","raw":"---\ntitle: redis哨兵机制\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-25 21:16:39\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## 问题\n\n主库故障的相关问题：\n\n1、确定主库故障\n\n2、选择新的主库\n\n3、新主库信息通知\n\n## 基本功能\n\n### 监控\n\n- 哨兵进程周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。\n\n- 主库或从库对 PING 命令的响应超时了，哨兵会标记为“主观下线”。\n\n- 需有quorum 个实例判断主库为“主观下线”，才能判定主库为“客观下线”\n\n### 选主\n\n- 筛选当前在线从库，且网络连接状况较好；\n\n- 选择从库优先级最高的从库\n\n- 选择从库复制进度最快的\n\n- 选择从库 ID 号小的\n\n### 通知\n\n- 通知从库执行replicaof，与新主库同步\n- 通知客户端，像新主库请求\n\n**通知客户端**的实现方法\n\n1、哨兵会把新主库的地址写入自己实例的pubsub中。客户端需要订阅这个pubsub，当这个pubsub有数据时，客户端就能感知到主库发生变更，同时可以拿到最新的主库地址。\n\n2、客户端需要支持主动去获取最新主从的地址进行访问。\n\n## 哨兵集群pub/sub\n\n**连接关系的实现**\n\n- 哨兵-哨兵：哨兵订阅主库上的“__sentinel__:hello”，实现哨兵连接信息的发布获取\n- 哨兵-从库：哨兵给主库发送 INFO 命令，主库接受到后，返回从库列表。从而哨兵可以连接从库\n- 哨兵-客户端：客户端订阅哨兵消息\n\n\n**哨兵Leader竞选 （总从切换）**\n\n1、拿到半数以上的赞成票；\n\n2、拿到的票数同时还需要大于等于仲裁所需的赞成票数（quorum ）。","slug":"redis哨兵机制","published":1,"updated":"2020-10-25T14:06:19.503Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w9t001pi4ufmhei7hw4","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>主库故障的相关问题：</p>\n<p>1、确定主库故障</p>\n<p>2、选择新的主库</p>\n<p>3、新主库信息通知</p>\n<h2 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h2><h3 id=\"监控\"><a href=\"#监控\" class=\"headerlink\" title=\"监控\"></a>监控</h3><ul>\n<li><p>哨兵进程周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。</p>\n</li>\n<li><p>主库或从库对 PING 命令的响应超时了，哨兵会标记为“主观下线”。</p>\n</li>\n<li><p>需有quorum 个实例判断主库为“主观下线”，才能判定主库为“客观下线”</p>\n</li>\n</ul>\n<h3 id=\"选主\"><a href=\"#选主\" class=\"headerlink\" title=\"选主\"></a>选主</h3><ul>\n<li><p>筛选当前在线从库，且网络连接状况较好；</p>\n</li>\n<li><p>选择从库优先级最高的从库</p>\n</li>\n<li><p>选择从库复制进度最快的</p>\n</li>\n<li><p>选择从库 ID 号小的</p>\n</li>\n</ul>\n<h3 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h3><ul>\n<li>通知从库执行replicaof，与新主库同步</li>\n<li>通知客户端，像新主库请求</li>\n</ul>\n<p><strong>通知客户端</strong>的实现方法</p>\n<p>1、哨兵会把新主库的地址写入自己实例的pubsub中。客户端需要订阅这个pubsub，当这个pubsub有数据时，客户端就能感知到主库发生变更，同时可以拿到最新的主库地址。</p>\n<p>2、客户端需要支持主动去获取最新主从的地址进行访问。</p>\n<h2 id=\"哨兵集群pub-sub\"><a href=\"#哨兵集群pub-sub\" class=\"headerlink\" title=\"哨兵集群pub/sub\"></a>哨兵集群pub/sub</h2><p><strong>连接关系的实现</strong></p>\n<ul>\n<li>哨兵-哨兵：哨兵订阅主库上的“<strong>sentinel</strong>:hello”，实现哨兵连接信息的发布获取</li>\n<li>哨兵-从库：哨兵给主库发送 INFO 命令，主库接受到后，返回从库列表。从而哨兵可以连接从库</li>\n<li>哨兵-客户端：客户端订阅哨兵消息</li>\n</ul>\n<p><strong>哨兵Leader竞选 （总从切换）</strong></p>\n<p>1、拿到半数以上的赞成票；</p>\n<p>2、拿到的票数同时还需要大于等于仲裁所需的赞成票数（quorum ）。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>主库故障的相关问题：</p>\n<p>1、确定主库故障</p>\n<p>2、选择新的主库</p>\n<p>3、新主库信息通知</p>\n<h2 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h2><h3 id=\"监控\"><a href=\"#监控\" class=\"headerlink\" title=\"监控\"></a>监控</h3><ul>\n<li><p>哨兵进程周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。</p>\n</li>\n<li><p>主库或从库对 PING 命令的响应超时了，哨兵会标记为“主观下线”。</p>\n</li>\n<li><p>需有quorum 个实例判断主库为“主观下线”，才能判定主库为“客观下线”</p>\n</li>\n</ul>\n<h3 id=\"选主\"><a href=\"#选主\" class=\"headerlink\" title=\"选主\"></a>选主</h3><ul>\n<li><p>筛选当前在线从库，且网络连接状况较好；</p>\n</li>\n<li><p>选择从库优先级最高的从库</p>\n</li>\n<li><p>选择从库复制进度最快的</p>\n</li>\n<li><p>选择从库 ID 号小的</p>\n</li>\n</ul>\n<h3 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h3><ul>\n<li>通知从库执行replicaof，与新主库同步</li>\n<li>通知客户端，像新主库请求</li>\n</ul>\n<p><strong>通知客户端</strong>的实现方法</p>\n<p>1、哨兵会把新主库的地址写入自己实例的pubsub中。客户端需要订阅这个pubsub，当这个pubsub有数据时，客户端就能感知到主库发生变更，同时可以拿到最新的主库地址。</p>\n<p>2、客户端需要支持主动去获取最新主从的地址进行访问。</p>\n<h2 id=\"哨兵集群pub-sub\"><a href=\"#哨兵集群pub-sub\" class=\"headerlink\" title=\"哨兵集群pub/sub\"></a>哨兵集群pub/sub</h2><p><strong>连接关系的实现</strong></p>\n<ul>\n<li>哨兵-哨兵：哨兵订阅主库上的“<strong>sentinel</strong>:hello”，实现哨兵连接信息的发布获取</li>\n<li>哨兵-从库：哨兵给主库发送 INFO 命令，主库接受到后，返回从库列表。从而哨兵可以连接从库</li>\n<li>哨兵-客户端：客户端订阅哨兵消息</li>\n</ul>\n<p><strong>哨兵Leader竞选 （总从切换）</strong></p>\n<p>1、拿到半数以上的赞成票；</p>\n<p>2、拿到的票数同时还需要大于等于仲裁所需的赞成票数（quorum ）。</p>\n"},{"title":"redis应用","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-10T13:22:09.000Z","password":null,"summary":null,"_content":"\n## 分布式锁\n\n实现：set lock:codehole true ex5 nx\n\n注意：不要用于较长任务，可能超时释放\n\n优化：设置value是一个随机值，保证不会被其他线程释放\n\n可重入锁：基于线程的Threadlocal变量存储当前持有锁的计数。如果当前有该锁的记录，则计数加一，返回加锁成功。否则尝试加锁，若不存在锁则成功，其他线程/进程会加锁失败。\n\n## 延时队列\n\n实现：使用zset ，消息序列化成value，到期时间作为score。为保障可用性，可以使用多个线程/进程轮询到期任务进行处理（zrangebyscore）。通过zrem结果，判断任务被哪个线程/进程获取，再进一步处理。\n\n优化：考虑将zrangebyscore 和zrem，封装lua scripting,避免获取任务的浪费操作。\n\n## 用户一年的签到统计\n\n使用位图，1天的签到记录只需要占据一个位，一年365位。\n\n## 页面访问量\n\n简单方案：使用set集合存储当天访问某一个用户ID， scard可以统计集合大小。\n\n优化：用户很多时，使用HyperLogLog，提供了不精确的去重方案，节省空间。pfadd/pfcount\n\n## 数据去重\n\n场景：用户为看过的内容推荐去重；爬虫URL去重；\n\n实现：简单去重，使用set。大数据去重，使用布隆过滤器（redis>4.0）bf.add/bf.exists。\n\n误差：布隆过滤器返回存在，实际可能不存在；返回不存在，实际一定不存在。\n\n原理：大型位数组和几个不一样的无偏hash函数。\n\n## 简单限流\n\n场景：限制用户行为在一定时间内的次数\n\n实现：每个用户每种行为作为key，使用zset,value和score都使用时间戳。在pipeline中，增加用户行为，移除时间窗口之前数据，**获取当前剩下行为总数**，并给该key增加过期时间，避免长期占用内存。通过剩下行为总数，判断是否超额。\n\n缺点：不适合1min操作不超过100万次这种场景。\n\n## 漏斗限流\n\n实现：使用redis-cell（redis 4.0），其使用漏斗算法，提供了限流指令。cl.throttle。\n\n非常棒，被拒绝还提供了重试时间。\n\n## 附近的人\n\n实现：使用GeoHash.\n\n原理：将二维经纬度数据映射到一维整数，距离近的点映射距离也会比较近。类似逐步切分蛋糕。\n\n注意：Geo数据将被放到一个zset中。集群环境中集合迁移，可能会影响线上服务运行，建议GEO数据使用单独的redis示例部署。\n\n","source":"_posts/redis应用.md","raw":"---\ntitle: redis应用\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-10 21:22:09\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## 分布式锁\n\n实现：set lock:codehole true ex5 nx\n\n注意：不要用于较长任务，可能超时释放\n\n优化：设置value是一个随机值，保证不会被其他线程释放\n\n可重入锁：基于线程的Threadlocal变量存储当前持有锁的计数。如果当前有该锁的记录，则计数加一，返回加锁成功。否则尝试加锁，若不存在锁则成功，其他线程/进程会加锁失败。\n\n## 延时队列\n\n实现：使用zset ，消息序列化成value，到期时间作为score。为保障可用性，可以使用多个线程/进程轮询到期任务进行处理（zrangebyscore）。通过zrem结果，判断任务被哪个线程/进程获取，再进一步处理。\n\n优化：考虑将zrangebyscore 和zrem，封装lua scripting,避免获取任务的浪费操作。\n\n## 用户一年的签到统计\n\n使用位图，1天的签到记录只需要占据一个位，一年365位。\n\n## 页面访问量\n\n简单方案：使用set集合存储当天访问某一个用户ID， scard可以统计集合大小。\n\n优化：用户很多时，使用HyperLogLog，提供了不精确的去重方案，节省空间。pfadd/pfcount\n\n## 数据去重\n\n场景：用户为看过的内容推荐去重；爬虫URL去重；\n\n实现：简单去重，使用set。大数据去重，使用布隆过滤器（redis>4.0）bf.add/bf.exists。\n\n误差：布隆过滤器返回存在，实际可能不存在；返回不存在，实际一定不存在。\n\n原理：大型位数组和几个不一样的无偏hash函数。\n\n## 简单限流\n\n场景：限制用户行为在一定时间内的次数\n\n实现：每个用户每种行为作为key，使用zset,value和score都使用时间戳。在pipeline中，增加用户行为，移除时间窗口之前数据，**获取当前剩下行为总数**，并给该key增加过期时间，避免长期占用内存。通过剩下行为总数，判断是否超额。\n\n缺点：不适合1min操作不超过100万次这种场景。\n\n## 漏斗限流\n\n实现：使用redis-cell（redis 4.0），其使用漏斗算法，提供了限流指令。cl.throttle。\n\n非常棒，被拒绝还提供了重试时间。\n\n## 附近的人\n\n实现：使用GeoHash.\n\n原理：将二维经纬度数据映射到一维整数，距离近的点映射距离也会比较近。类似逐步切分蛋糕。\n\n注意：Geo数据将被放到一个zset中。集群环境中集合迁移，可能会影响线上服务运行，建议GEO数据使用单独的redis示例部署。\n\n","slug":"redis应用","published":1,"updated":"2021-03-10T13:23:00.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w9v001ri4ufarnzk2s2","content":"<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p>实现：set lock:codehole true ex5 nx</p>\n<p>注意：不要用于较长任务，可能超时释放</p>\n<p>优化：设置value是一个随机值，保证不会被其他线程释放</p>\n<p>可重入锁：基于线程的Threadlocal变量存储当前持有锁的计数。如果当前有该锁的记录，则计数加一，返回加锁成功。否则尝试加锁，若不存在锁则成功，其他线程/进程会加锁失败。</p>\n<h2 id=\"延时队列\"><a href=\"#延时队列\" class=\"headerlink\" title=\"延时队列\"></a>延时队列</h2><p>实现：使用zset ，消息序列化成value，到期时间作为score。为保障可用性，可以使用多个线程/进程轮询到期任务进行处理（zrangebyscore）。通过zrem结果，判断任务被哪个线程/进程获取，再进一步处理。</p>\n<p>优化：考虑将zrangebyscore 和zrem，封装lua scripting,避免获取任务的浪费操作。</p>\n<h2 id=\"用户一年的签到统计\"><a href=\"#用户一年的签到统计\" class=\"headerlink\" title=\"用户一年的签到统计\"></a>用户一年的签到统计</h2><p>使用位图，1天的签到记录只需要占据一个位，一年365位。</p>\n<h2 id=\"页面访问量\"><a href=\"#页面访问量\" class=\"headerlink\" title=\"页面访问量\"></a>页面访问量</h2><p>简单方案：使用set集合存储当天访问某一个用户ID， scard可以统计集合大小。</p>\n<p>优化：用户很多时，使用HyperLogLog，提供了不精确的去重方案，节省空间。pfadd/pfcount</p>\n<h2 id=\"数据去重\"><a href=\"#数据去重\" class=\"headerlink\" title=\"数据去重\"></a>数据去重</h2><p>场景：用户为看过的内容推荐去重；爬虫URL去重；</p>\n<p>实现：简单去重，使用set。大数据去重，使用布隆过滤器（redis&gt;4.0）bf.add/bf.exists。</p>\n<p>误差：布隆过滤器返回存在，实际可能不存在；返回不存在，实际一定不存在。</p>\n<p>原理：大型位数组和几个不一样的无偏hash函数。</p>\n<h2 id=\"简单限流\"><a href=\"#简单限流\" class=\"headerlink\" title=\"简单限流\"></a>简单限流</h2><p>场景：限制用户行为在一定时间内的次数</p>\n<p>实现：每个用户每种行为作为key，使用zset,value和score都使用时间戳。在pipeline中，增加用户行为，移除时间窗口之前数据，<strong>获取当前剩下行为总数</strong>，并给该key增加过期时间，避免长期占用内存。通过剩下行为总数，判断是否超额。</p>\n<p>缺点：不适合1min操作不超过100万次这种场景。</p>\n<h2 id=\"漏斗限流\"><a href=\"#漏斗限流\" class=\"headerlink\" title=\"漏斗限流\"></a>漏斗限流</h2><p>实现：使用redis-cell（redis 4.0），其使用漏斗算法，提供了限流指令。cl.throttle。</p>\n<p>非常棒，被拒绝还提供了重试时间。</p>\n<h2 id=\"附近的人\"><a href=\"#附近的人\" class=\"headerlink\" title=\"附近的人\"></a>附近的人</h2><p>实现：使用GeoHash.</p>\n<p>原理：将二维经纬度数据映射到一维整数，距离近的点映射距离也会比较近。类似逐步切分蛋糕。</p>\n<p>注意：Geo数据将被放到一个zset中。集群环境中集合迁移，可能会影响线上服务运行，建议GEO数据使用单独的redis示例部署。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p>实现：set lock:codehole true ex5 nx</p>\n<p>注意：不要用于较长任务，可能超时释放</p>\n<p>优化：设置value是一个随机值，保证不会被其他线程释放</p>\n<p>可重入锁：基于线程的Threadlocal变量存储当前持有锁的计数。如果当前有该锁的记录，则计数加一，返回加锁成功。否则尝试加锁，若不存在锁则成功，其他线程/进程会加锁失败。</p>\n<h2 id=\"延时队列\"><a href=\"#延时队列\" class=\"headerlink\" title=\"延时队列\"></a>延时队列</h2><p>实现：使用zset ，消息序列化成value，到期时间作为score。为保障可用性，可以使用多个线程/进程轮询到期任务进行处理（zrangebyscore）。通过zrem结果，判断任务被哪个线程/进程获取，再进一步处理。</p>\n<p>优化：考虑将zrangebyscore 和zrem，封装lua scripting,避免获取任务的浪费操作。</p>\n<h2 id=\"用户一年的签到统计\"><a href=\"#用户一年的签到统计\" class=\"headerlink\" title=\"用户一年的签到统计\"></a>用户一年的签到统计</h2><p>使用位图，1天的签到记录只需要占据一个位，一年365位。</p>\n<h2 id=\"页面访问量\"><a href=\"#页面访问量\" class=\"headerlink\" title=\"页面访问量\"></a>页面访问量</h2><p>简单方案：使用set集合存储当天访问某一个用户ID， scard可以统计集合大小。</p>\n<p>优化：用户很多时，使用HyperLogLog，提供了不精确的去重方案，节省空间。pfadd/pfcount</p>\n<h2 id=\"数据去重\"><a href=\"#数据去重\" class=\"headerlink\" title=\"数据去重\"></a>数据去重</h2><p>场景：用户为看过的内容推荐去重；爬虫URL去重；</p>\n<p>实现：简单去重，使用set。大数据去重，使用布隆过滤器（redis&gt;4.0）bf.add/bf.exists。</p>\n<p>误差：布隆过滤器返回存在，实际可能不存在；返回不存在，实际一定不存在。</p>\n<p>原理：大型位数组和几个不一样的无偏hash函数。</p>\n<h2 id=\"简单限流\"><a href=\"#简单限流\" class=\"headerlink\" title=\"简单限流\"></a>简单限流</h2><p>场景：限制用户行为在一定时间内的次数</p>\n<p>实现：每个用户每种行为作为key，使用zset,value和score都使用时间戳。在pipeline中，增加用户行为，移除时间窗口之前数据，<strong>获取当前剩下行为总数</strong>，并给该key增加过期时间，避免长期占用内存。通过剩下行为总数，判断是否超额。</p>\n<p>缺点：不适合1min操作不超过100万次这种场景。</p>\n<h2 id=\"漏斗限流\"><a href=\"#漏斗限流\" class=\"headerlink\" title=\"漏斗限流\"></a>漏斗限流</h2><p>实现：使用redis-cell（redis 4.0），其使用漏斗算法，提供了限流指令。cl.throttle。</p>\n<p>非常棒，被拒绝还提供了重试时间。</p>\n<h2 id=\"附近的人\"><a href=\"#附近的人\" class=\"headerlink\" title=\"附近的人\"></a>附近的人</h2><p>实现：使用GeoHash.</p>\n<p>原理：将二维经纬度数据映射到一维整数，距离近的点映射距离也会比较近。类似逐步切分蛋糕。</p>\n<p>注意：Geo数据将被放到一个zset中。集群环境中集合迁移，可能会影响线上服务运行，建议GEO数据使用单独的redis示例部署。</p>\n"},{"title":"redis思维导图","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-08T00:06:00.000Z","password":null,"summary":null,"_content":"\n![思维导图](redis.png)","source":"_posts/redis思维导图.md","raw":"---\ntitle: redis思维导图\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-08 08:06:00\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n![思维导图](redis.png)","slug":"redis思维导图","published":1,"updated":"2021-03-08T00:09:25.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944w9y001wi4uflyc3v3kt","content":"<p><img src=\"redis.png\" alt=\"思维导图\"></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<p><img src=\"redis.png\" alt=\"思维导图\"></p>\n"},{"title":"redis数据结构","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T13:44:02.000Z","password":null,"summary":null,"_content":"\n\n\n基本数据结构包括：String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）\n\n| 基本数据结构 | 底层实现           |\n| ------------ | ------------------ |\n| string       | 动态字符串         |\n| List         | 双向链表、压缩列表 |\n| Hash         | 哈希表，压缩列表   |\n| Sorted Set   | 跳表，压缩列表     |\n| Set          | 哈希表、数组       |\n\nredis中的键值对采用哈希表，哈希表就是一个数组，数组的每个元素称为一个哈希桶，每个哈希桶中保存了键值对数据的指针。\n哈希冲突采用链式哈希。同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。\n冲突增多时，Redis 会对哈希表做渐进式 rehash操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。渐进式 rehash时指拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries\n\n## 压缩列表\n压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。\n\n压缩列表是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。\n\n## 跳表\n跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。\n\n## 复杂度\n\n各个数据结构的查找时间复杂度\n| 数据结构 | 复杂度  |\n| -------- | ------- |\n| 哈希表   | O(1)    |\n| 跳表     | O(logN) |\n| 双向链表 | O(N)    |\n| 压缩列表 | O(N)    |\n| 数组     | O(N)    |","source":"_posts/redis数据结构.md","raw":"---\ntitle: redis数据结构\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 21:44:02\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n\n\n基本数据结构包括：String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）\n\n| 基本数据结构 | 底层实现           |\n| ------------ | ------------------ |\n| string       | 动态字符串         |\n| List         | 双向链表、压缩列表 |\n| Hash         | 哈希表，压缩列表   |\n| Sorted Set   | 跳表，压缩列表     |\n| Set          | 哈希表、数组       |\n\nredis中的键值对采用哈希表，哈希表就是一个数组，数组的每个元素称为一个哈希桶，每个哈希桶中保存了键值对数据的指针。\n哈希冲突采用链式哈希。同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。\n冲突增多时，Redis 会对哈希表做渐进式 rehash操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。渐进式 rehash时指拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries\n\n## 压缩列表\n压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。\n\n压缩列表是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。\n\n## 跳表\n跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。\n\n## 复杂度\n\n各个数据结构的查找时间复杂度\n| 数据结构 | 复杂度  |\n| -------- | ------- |\n| 哈希表   | O(1)    |\n| 跳表     | O(logN) |\n| 双向链表 | O(N)    |\n| 压缩列表 | O(N)    |\n| 数组     | O(N)    |","slug":"redis数据结构","published":1,"updated":"2020-10-26T14:05:41.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wa2001yi4uf5ryusvsr","content":"<p>基本数据结构包括：String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）</p>\n<table>\n<thead>\n<tr>\n<th>基本数据结构</th>\n<th>底层实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>动态字符串</td>\n</tr>\n<tr>\n<td>List</td>\n<td>双向链表、压缩列表</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>哈希表，压缩列表</td>\n</tr>\n<tr>\n<td>Sorted Set</td>\n<td>跳表，压缩列表</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>哈希表、数组</td>\n</tr>\n</tbody></table>\n<p>redis中的键值对采用哈希表，哈希表就是一个数组，数组的每个元素称为一个哈希桶，每个哈希桶中保存了键值对数据的指针。<br>哈希冲突采用链式哈希。同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。<br>冲突增多时，Redis 会对哈希表做渐进式 rehash操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。渐进式 rehash时指拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries</p>\n<h2 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h2><p>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p>\n<p>压缩列表是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。</p>\n<h2 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h2><p>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。</p>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><p>各个数据结构的查找时间复杂度<br>| 数据结构 | 复杂度  |<br>| ——– | ——- |<br>| 哈希表   | O(1)    |<br>| 跳表     | O(logN) |<br>| 双向链表 | O(N)    |<br>| 压缩列表 | O(N)    |<br>| 数组     | O(N)    |</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<p>基本数据结构包括：String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）</p>\n<table>\n<thead>\n<tr>\n<th>基本数据结构</th>\n<th>底层实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>动态字符串</td>\n</tr>\n<tr>\n<td>List</td>\n<td>双向链表、压缩列表</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>哈希表，压缩列表</td>\n</tr>\n<tr>\n<td>Sorted Set</td>\n<td>跳表，压缩列表</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>哈希表、数组</td>\n</tr>\n</tbody></table>\n<p>redis中的键值对采用哈希表，哈希表就是一个数组，数组的每个元素称为一个哈希桶，每个哈希桶中保存了键值对数据的指针。<br>哈希冲突采用链式哈希。同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。<br>冲突增多时，Redis 会对哈希表做渐进式 rehash操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。渐进式 rehash时指拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries</p>\n<h2 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h2><p>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p>\n<p>压缩列表是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。</p>\n<h2 id=\"跳表\"><a href=\"#跳表\" class=\"headerlink\" title=\"跳表\"></a>跳表</h2><p>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位。</p>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><p>各个数据结构的查找时间复杂度<br>| 数据结构 | 复杂度  |<br>| ——– | ——- |<br>| 哈希表   | O(1)    |<br>| 跳表     | O(logN) |<br>| 双向链表 | O(N)    |<br>| 压缩列表 | O(N)    |<br>| 数组     | O(N)    |</p>\n"},{"title":"redis消息队列","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-11-02T13:35:36.000Z","password":null,"summary":null,"_content":"\n## 需求分析\n\n- 消息保序：消费者需要按照生产者发送消息的顺序来处理消息\n\n- 处理重复的消息：消费者避免多次处理重复的消息\n\n- 保证消息可靠性：消费者重启后，可以重新读取消息再次进行处理\n\n## 基于List\n\n-  LPUSH \n\n把要发送的消息依次写入 List\n\n- BRPOP \n\n阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列。\n\n- 消费者程序本身能对重复消息进行判断\n\n消息队列要能给每一个消息提供全局唯一的 ID 号消费者程序要把已经处理过的消息的 ID 号记录下来。ID号需要生产者程序在发送消息前自行生成，并在LPUSH的时候插入List。\n\n- BRPOPLPUSH\n\n让消费者程序从一个 List 中读取消息，同时，把这个消息再插入到另一个 List（可以叫作备份 List）留存\n\n缺点：不支持消费组\n\n## 基于 Streams（Redis 5.0）\n\n- XADD：插入消息，保证有序，可以自动生成全局唯一 ID；\n- XREAD：用于读取消息，可以按 ID 读取数据；\n- XREADGROUP：按消费组形式读取消息\n- XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。\n\n## 缺点\n\n在用Redis当作队列或存储数据时，是有可能丢失数据的：AOF同步写盘会降低性能。主从集群切换也可能丢数据。\n\n","source":"_posts/redis消息队列.md","raw":"---\ntitle: redis消息队列\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-11-02 21:35:36\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## 需求分析\n\n- 消息保序：消费者需要按照生产者发送消息的顺序来处理消息\n\n- 处理重复的消息：消费者避免多次处理重复的消息\n\n- 保证消息可靠性：消费者重启后，可以重新读取消息再次进行处理\n\n## 基于List\n\n-  LPUSH \n\n把要发送的消息依次写入 List\n\n- BRPOP \n\n阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列。\n\n- 消费者程序本身能对重复消息进行判断\n\n消息队列要能给每一个消息提供全局唯一的 ID 号消费者程序要把已经处理过的消息的 ID 号记录下来。ID号需要生产者程序在发送消息前自行生成，并在LPUSH的时候插入List。\n\n- BRPOPLPUSH\n\n让消费者程序从一个 List 中读取消息，同时，把这个消息再插入到另一个 List（可以叫作备份 List）留存\n\n缺点：不支持消费组\n\n## 基于 Streams（Redis 5.0）\n\n- XADD：插入消息，保证有序，可以自动生成全局唯一 ID；\n- XREAD：用于读取消息，可以按 ID 读取数据；\n- XREADGROUP：按消费组形式读取消息\n- XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。\n\n## 缺点\n\n在用Redis当作队列或存储数据时，是有可能丢失数据的：AOF同步写盘会降低性能。主从集群切换也可能丢数据。\n\n","slug":"redis消息队列","published":1,"updated":"2020-11-02T14:14:19.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wa70023i4ufy1mpau47","content":"<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><ul>\n<li><p>消息保序：消费者需要按照生产者发送消息的顺序来处理消息</p>\n</li>\n<li><p>处理重复的消息：消费者避免多次处理重复的消息</p>\n</li>\n<li><p>保证消息可靠性：消费者重启后，可以重新读取消息再次进行处理</p>\n</li>\n</ul>\n<h2 id=\"基于List\"><a href=\"#基于List\" class=\"headerlink\" title=\"基于List\"></a>基于List</h2><ul>\n<li>LPUSH </li>\n</ul>\n<p>把要发送的消息依次写入 List</p>\n<ul>\n<li>BRPOP </li>\n</ul>\n<p>阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列。</p>\n<ul>\n<li>消费者程序本身能对重复消息进行判断</li>\n</ul>\n<p>消息队列要能给每一个消息提供全局唯一的 ID 号消费者程序要把已经处理过的消息的 ID 号记录下来。ID号需要生产者程序在发送消息前自行生成，并在LPUSH的时候插入List。</p>\n<ul>\n<li>BRPOPLPUSH</li>\n</ul>\n<p>让消费者程序从一个 List 中读取消息，同时，把这个消息再插入到另一个 List（可以叫作备份 List）留存</p>\n<p>缺点：不支持消费组</p>\n<h2 id=\"基于-Streams（Redis-5-0）\"><a href=\"#基于-Streams（Redis-5-0）\" class=\"headerlink\" title=\"基于 Streams（Redis 5.0）\"></a>基于 Streams（Redis 5.0）</h2><ul>\n<li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li>\n<li>XREAD：用于读取消息，可以按 ID 读取数据；</li>\n<li>XREADGROUP：按消费组形式读取消息</li>\n<li>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><p>在用Redis当作队列或存储数据时，是有可能丢失数据的：AOF同步写盘会降低性能。主从集群切换也可能丢数据。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><ul>\n<li><p>消息保序：消费者需要按照生产者发送消息的顺序来处理消息</p>\n</li>\n<li><p>处理重复的消息：消费者避免多次处理重复的消息</p>\n</li>\n<li><p>保证消息可靠性：消费者重启后，可以重新读取消息再次进行处理</p>\n</li>\n</ul>\n<h2 id=\"基于List\"><a href=\"#基于List\" class=\"headerlink\" title=\"基于List\"></a>基于List</h2><ul>\n<li>LPUSH </li>\n</ul>\n<p>把要发送的消息依次写入 List</p>\n<ul>\n<li>BRPOP </li>\n</ul>\n<p>阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列。</p>\n<ul>\n<li>消费者程序本身能对重复消息进行判断</li>\n</ul>\n<p>消息队列要能给每一个消息提供全局唯一的 ID 号消费者程序要把已经处理过的消息的 ID 号记录下来。ID号需要生产者程序在发送消息前自行生成，并在LPUSH的时候插入List。</p>\n<ul>\n<li>BRPOPLPUSH</li>\n</ul>\n<p>让消费者程序从一个 List 中读取消息，同时，把这个消息再插入到另一个 List（可以叫作备份 List）留存</p>\n<p>缺点：不支持消费组</p>\n<h2 id=\"基于-Streams（Redis-5-0）\"><a href=\"#基于-Streams（Redis-5-0）\" class=\"headerlink\" title=\"基于 Streams（Redis 5.0）\"></a>基于 Streams（Redis 5.0）</h2><ul>\n<li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li>\n<li>XREAD：用于读取消息，可以按 ID 读取数据；</li>\n<li>XREADGROUP：按消费组形式读取消息</li>\n<li>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><p>在用Redis当作队列或存储数据时，是有可能丢失数据的：AOF同步写盘会降低性能。主从集群切换也可能丢数据。</p>\n"},{"title":"redis缓存","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-27T12:04:59.000Z","password":null,"summary":null,"_content":"\n## redis缓存\n\n- 应用读取数据时，需要先读取 Redis；\n\n- 发生缓存缺失时，需要从数据库读取数据；\n\n- 发生缓存缺失时，还需要更新缓存。\n\nRedis也称为旁路缓存，因为读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。\n\n## 缓存分类\n\n- 只读缓存能加速读请求。\n\n- 读写缓存可以同时加速读写请求。读写缓存又有两种数据写回策略，可根据业务需求，在保证性能和保证数据可靠性之间进行选择。\n\n### 只读缓存\n\n- 读取数据先调用 Redis GET 接口；若不存在，应用从数据库中读取，并写到缓存中。\n- 写请求，直接发往后端的数据库；删改数据时，应用需要把这些缓存的数据删除。\n\n**优点**\n\n数据库和缓存可以保证完全一致，并且缓存中永远保留的是经常访问的热点数据。\n\n**缺点**\n\n每次修改操作都会把缓存中的数据删除，之后访问时都会先触发一次缓存缺失，然后从后端数据库加载数据到缓存中，这个过程访问延迟会变大。\n\n### 读写缓存\n\n读写请求都会发送到缓存，在缓存中直接操作数据。最新数据在redis，考虑掉电风险。\n\n#### 同步直写\n\n- 写请求发给缓存的同时，也会发给后端数据库，等到缓存和数据库都写完数据，才给客户端返回\n- 需要在业务应用中使用事务实现\n\n**缺点**：降低缓存的访问性能\n\n**优点**：被修改后的数据永远在缓存中存在，下次访问时，能够直接命中缓存\n\n#### 异步直写\n\n- 所有写请求都先在缓存中处理。等到增改的数据要被从缓存中淘汰出来时，将它们写回后端数据库\n\n注意：Redis 本身不提供机制将淘汰数据写回数据库\n\n\n\n**Read/Write Throught策略**\n\n应用层读写只需要操作缓存，不需要关心后端数据库。应用层在操作缓存时，缓存层会自动从数据库中加载或写回到数据库中，\n\n**优点**\n\n对于应用层的使用非常友好，只需要操作缓存即可\n\n**缺点**\n\n需要缓存层支持和后端数据库的联动。\n\n**Write Back策略**\n\n写操作只写缓存，比较简单。而读操作如果命中缓存则直接返回，否则需要从数据库中加载到缓存中，在加载之前，如果缓存已满，则先把需要淘汰的缓存数据写回到后端数据库中，再把对应的数据放入到缓存中。\n\n**优点**\n\n写操作飞快（只写缓存）\n\n**缺点**\n\n如果数据还未来得及写入后端数据库，系统发生异常会导致缓存和数据库的不一致。\n\n## 缓存淘汰\n\n“八二原理”：80% 的请求实际只访问了 20% 的数据。\n\n**缓存大小设置**：结合应用数据实际访问特征和成本开销综合考虑，建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。\n\n- 在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis  4.0 后新增）。\n- 在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）。\n\n**LRU**\n\nRedis 中，LRU 算法被做了简化。\n\n- Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为候选集合。\n\n- Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。\n- 再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值\n\n**LFU**\n\n从两个维度来筛选并淘汰数据：\n\n- 数据的被访问次数\n\n- 数据访问的时效性，访问时间离当前时间的远近\n\n**计数规则**：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。\n\n**counter 值的衰减机制**\n\nLFU 策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，LFU 策略再把这个差值除以 lfu_decay_time 值，所得的结果就是数据 counter 要衰减的值。\n\n## 缓存一致性\n\n### 原因1：更新操作失败\n\n只读缓存：无法保证删改数据库和删除缓存的原子性。\n\n- 先删缓存，后更数据库（失败）：缓存缺失，数据库读取到旧值。\n- 先更数据库，后删缓存（失败）：先在缓存中查询，但此时，就会读到旧值了\n\n**解决办法：重试机制**\n\n- 把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。\n- 如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。\n\n### 原因2：大量并发请求\n\n**先删缓存，后更数据库**\n\n![并发缓存不一致](buyizhi.jpg)\n\n**解决办法：延迟双删**\n\n在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间（保证“偷菜”完成），再进行一次缓存删除操作。\n\n难点：sleep时间不好控制\n\n**先更数据库，后删缓存**\n\n![并发缓存不一致2](buyizhi2.jpg)\n\n其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小，不需要解决。\n\n优点：不存在缓存缺失的问题，推荐！！\n\n**缓存更新替代删除**\n\n写+写并发时，必然会有数据不一致的情况。因此需要配合**分布式锁**使用。\n\n写+读并发时，先更数据库可能会有短时不一致。\n\n## 缓存异常\n\n### 缓存雪崩\n\n大量的应用请求无法在 Redis 缓存中进行处理，应用将大量请求发送到数据库层，导致数据库层的压力激增。\n\n**原因**\n\n- 缓存中有大量数据同时过期\n- Redis 缓存实例发生故障宕机了，无法处理请求\n\n**解决办法**\n\n- 原因1：避免给大量的数据设置相同的过期时间，数据的过期时间增加一个较小的随机数\n- 原因1：服务降级：非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取\n- 原因2：业务系统中实现服务熔断或请求限流机制。暂停业务应用对缓存系统的接口访问。业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。\n- 事前预防。建 Redis 缓存高可靠主从集群。\n\n### 缓存击穿\n\n某个访问非常频繁的热点数据，无法在缓存中进行处理，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。\n\n**解决办法**\n\n访问特别频繁的热点数据，不设置过期时间\n\n### 缓存穿透\n\n要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。缓存也就成了“摆设”。\n\n**原因**\n\n- 业务层误操作：缓存中的数据和数据库中的数据被误删除了\n\n- 恶意攻击：专门访问数据库中没有的数据。\n\n**解决办法**\n\n- 针对穿透查询数据，缓存空值或缺省值。\n- 使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。大量请求只会查询 Redis 和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常运行。\n- 前端进行请求检测，恶意的请求（例如请求参数不合理、请求参数是非法值、请求字段不存在）直接过滤掉，不让它们访问后端缓存和数据库\n\n","source":"_posts/redis缓存.md","raw":"---\ntitle: redis缓存\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-27 20:04:59\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## redis缓存\n\n- 应用读取数据时，需要先读取 Redis；\n\n- 发生缓存缺失时，需要从数据库读取数据；\n\n- 发生缓存缺失时，还需要更新缓存。\n\nRedis也称为旁路缓存，因为读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。\n\n## 缓存分类\n\n- 只读缓存能加速读请求。\n\n- 读写缓存可以同时加速读写请求。读写缓存又有两种数据写回策略，可根据业务需求，在保证性能和保证数据可靠性之间进行选择。\n\n### 只读缓存\n\n- 读取数据先调用 Redis GET 接口；若不存在，应用从数据库中读取，并写到缓存中。\n- 写请求，直接发往后端的数据库；删改数据时，应用需要把这些缓存的数据删除。\n\n**优点**\n\n数据库和缓存可以保证完全一致，并且缓存中永远保留的是经常访问的热点数据。\n\n**缺点**\n\n每次修改操作都会把缓存中的数据删除，之后访问时都会先触发一次缓存缺失，然后从后端数据库加载数据到缓存中，这个过程访问延迟会变大。\n\n### 读写缓存\n\n读写请求都会发送到缓存，在缓存中直接操作数据。最新数据在redis，考虑掉电风险。\n\n#### 同步直写\n\n- 写请求发给缓存的同时，也会发给后端数据库，等到缓存和数据库都写完数据，才给客户端返回\n- 需要在业务应用中使用事务实现\n\n**缺点**：降低缓存的访问性能\n\n**优点**：被修改后的数据永远在缓存中存在，下次访问时，能够直接命中缓存\n\n#### 异步直写\n\n- 所有写请求都先在缓存中处理。等到增改的数据要被从缓存中淘汰出来时，将它们写回后端数据库\n\n注意：Redis 本身不提供机制将淘汰数据写回数据库\n\n\n\n**Read/Write Throught策略**\n\n应用层读写只需要操作缓存，不需要关心后端数据库。应用层在操作缓存时，缓存层会自动从数据库中加载或写回到数据库中，\n\n**优点**\n\n对于应用层的使用非常友好，只需要操作缓存即可\n\n**缺点**\n\n需要缓存层支持和后端数据库的联动。\n\n**Write Back策略**\n\n写操作只写缓存，比较简单。而读操作如果命中缓存则直接返回，否则需要从数据库中加载到缓存中，在加载之前，如果缓存已满，则先把需要淘汰的缓存数据写回到后端数据库中，再把对应的数据放入到缓存中。\n\n**优点**\n\n写操作飞快（只写缓存）\n\n**缺点**\n\n如果数据还未来得及写入后端数据库，系统发生异常会导致缓存和数据库的不一致。\n\n## 缓存淘汰\n\n“八二原理”：80% 的请求实际只访问了 20% 的数据。\n\n**缓存大小设置**：结合应用数据实际访问特征和成本开销综合考虑，建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。\n\n- 在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis  4.0 后新增）。\n- 在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）。\n\n**LRU**\n\nRedis 中，LRU 算法被做了简化。\n\n- Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为候选集合。\n\n- Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。\n- 再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值\n\n**LFU**\n\n从两个维度来筛选并淘汰数据：\n\n- 数据的被访问次数\n\n- 数据访问的时效性，访问时间离当前时间的远近\n\n**计数规则**：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。\n\n**counter 值的衰减机制**\n\nLFU 策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，LFU 策略再把这个差值除以 lfu_decay_time 值，所得的结果就是数据 counter 要衰减的值。\n\n## 缓存一致性\n\n### 原因1：更新操作失败\n\n只读缓存：无法保证删改数据库和删除缓存的原子性。\n\n- 先删缓存，后更数据库（失败）：缓存缺失，数据库读取到旧值。\n- 先更数据库，后删缓存（失败）：先在缓存中查询，但此时，就会读到旧值了\n\n**解决办法：重试机制**\n\n- 把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。\n- 如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。\n\n### 原因2：大量并发请求\n\n**先删缓存，后更数据库**\n\n![并发缓存不一致](buyizhi.jpg)\n\n**解决办法：延迟双删**\n\n在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间（保证“偷菜”完成），再进行一次缓存删除操作。\n\n难点：sleep时间不好控制\n\n**先更数据库，后删缓存**\n\n![并发缓存不一致2](buyizhi2.jpg)\n\n其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小，不需要解决。\n\n优点：不存在缓存缺失的问题，推荐！！\n\n**缓存更新替代删除**\n\n写+写并发时，必然会有数据不一致的情况。因此需要配合**分布式锁**使用。\n\n写+读并发时，先更数据库可能会有短时不一致。\n\n## 缓存异常\n\n### 缓存雪崩\n\n大量的应用请求无法在 Redis 缓存中进行处理，应用将大量请求发送到数据库层，导致数据库层的压力激增。\n\n**原因**\n\n- 缓存中有大量数据同时过期\n- Redis 缓存实例发生故障宕机了，无法处理请求\n\n**解决办法**\n\n- 原因1：避免给大量的数据设置相同的过期时间，数据的过期时间增加一个较小的随机数\n- 原因1：服务降级：非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取\n- 原因2：业务系统中实现服务熔断或请求限流机制。暂停业务应用对缓存系统的接口访问。业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。\n- 事前预防。建 Redis 缓存高可靠主从集群。\n\n### 缓存击穿\n\n某个访问非常频繁的热点数据，无法在缓存中进行处理，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。\n\n**解决办法**\n\n访问特别频繁的热点数据，不设置过期时间\n\n### 缓存穿透\n\n要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。缓存也就成了“摆设”。\n\n**原因**\n\n- 业务层误操作：缓存中的数据和数据库中的数据被误删除了\n\n- 恶意攻击：专门访问数据库中没有的数据。\n\n**解决办法**\n\n- 针对穿透查询数据，缓存空值或缺省值。\n- 使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。大量请求只会查询 Redis 和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常运行。\n- 前端进行请求检测，恶意的请求（例如请求参数不合理、请求参数是非法值、请求字段不存在）直接过滤掉，不让它们访问后端缓存和数据库\n\n","slug":"redis缓存","published":1,"updated":"2021-03-08T14:04:39.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wac0026i4uf2xszbp4r","content":"<h2 id=\"redis缓存\"><a href=\"#redis缓存\" class=\"headerlink\" title=\"redis缓存\"></a>redis缓存</h2><ul>\n<li><p>应用读取数据时，需要先读取 Redis；</p>\n</li>\n<li><p>发生缓存缺失时，需要从数据库读取数据；</p>\n</li>\n<li><p>发生缓存缺失时，还需要更新缓存。</p>\n</li>\n</ul>\n<p>Redis也称为旁路缓存，因为读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p>\n<h2 id=\"缓存分类\"><a href=\"#缓存分类\" class=\"headerlink\" title=\"缓存分类\"></a>缓存分类</h2><ul>\n<li><p>只读缓存能加速读请求。</p>\n</li>\n<li><p>读写缓存可以同时加速读写请求。读写缓存又有两种数据写回策略，可根据业务需求，在保证性能和保证数据可靠性之间进行选择。</p>\n</li>\n</ul>\n<h3 id=\"只读缓存\"><a href=\"#只读缓存\" class=\"headerlink\" title=\"只读缓存\"></a>只读缓存</h3><ul>\n<li>读取数据先调用 Redis GET 接口；若不存在，应用从数据库中读取，并写到缓存中。</li>\n<li>写请求，直接发往后端的数据库；删改数据时，应用需要把这些缓存的数据删除。</li>\n</ul>\n<p><strong>优点</strong></p>\n<p>数据库和缓存可以保证完全一致，并且缓存中永远保留的是经常访问的热点数据。</p>\n<p><strong>缺点</strong></p>\n<p>每次修改操作都会把缓存中的数据删除，之后访问时都会先触发一次缓存缺失，然后从后端数据库加载数据到缓存中，这个过程访问延迟会变大。</p>\n<h3 id=\"读写缓存\"><a href=\"#读写缓存\" class=\"headerlink\" title=\"读写缓存\"></a>读写缓存</h3><p>读写请求都会发送到缓存，在缓存中直接操作数据。最新数据在redis，考虑掉电风险。</p>\n<h4 id=\"同步直写\"><a href=\"#同步直写\" class=\"headerlink\" title=\"同步直写\"></a>同步直写</h4><ul>\n<li>写请求发给缓存的同时，也会发给后端数据库，等到缓存和数据库都写完数据，才给客户端返回</li>\n<li>需要在业务应用中使用事务实现</li>\n</ul>\n<p><strong>缺点</strong>：降低缓存的访问性能</p>\n<p><strong>优点</strong>：被修改后的数据永远在缓存中存在，下次访问时，能够直接命中缓存</p>\n<h4 id=\"异步直写\"><a href=\"#异步直写\" class=\"headerlink\" title=\"异步直写\"></a>异步直写</h4><ul>\n<li>所有写请求都先在缓存中处理。等到增改的数据要被从缓存中淘汰出来时，将它们写回后端数据库</li>\n</ul>\n<p>注意：Redis 本身不提供机制将淘汰数据写回数据库</p>\n<p><strong>Read/Write Throught策略</strong></p>\n<p>应用层读写只需要操作缓存，不需要关心后端数据库。应用层在操作缓存时，缓存层会自动从数据库中加载或写回到数据库中，</p>\n<p><strong>优点</strong></p>\n<p>对于应用层的使用非常友好，只需要操作缓存即可</p>\n<p><strong>缺点</strong></p>\n<p>需要缓存层支持和后端数据库的联动。</p>\n<p><strong>Write Back策略</strong></p>\n<p>写操作只写缓存，比较简单。而读操作如果命中缓存则直接返回，否则需要从数据库中加载到缓存中，在加载之前，如果缓存已满，则先把需要淘汰的缓存数据写回到后端数据库中，再把对应的数据放入到缓存中。</p>\n<p><strong>优点</strong></p>\n<p>写操作飞快（只写缓存）</p>\n<p><strong>缺点</strong></p>\n<p>如果数据还未来得及写入后端数据库，系统发生异常会导致缓存和数据库的不一致。</p>\n<h2 id=\"缓存淘汰\"><a href=\"#缓存淘汰\" class=\"headerlink\" title=\"缓存淘汰\"></a>缓存淘汰</h2><p>“八二原理”：80% 的请求实际只访问了 20% 的数据。</p>\n<p><strong>缓存大小设置</strong>：结合应用数据实际访问特征和成本开销综合考虑，建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。</p>\n<ul>\n<li>在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis  4.0 后新增）。</li>\n<li>在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）。</li>\n</ul>\n<p><strong>LRU</strong></p>\n<p>Redis 中，LRU 算法被做了简化。</p>\n<ul>\n<li><p>Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为候选集合。</p>\n</li>\n<li><p>Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。</p>\n</li>\n<li><p>再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值</p>\n</li>\n</ul>\n<p><strong>LFU</strong></p>\n<p>从两个维度来筛选并淘汰数据：</p>\n<ul>\n<li><p>数据的被访问次数</p>\n</li>\n<li><p>数据访问的时效性，访问时间离当前时间的远近</p>\n</li>\n</ul>\n<p><strong>计数规则</strong>：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。</p>\n<p><strong>counter 值的衰减机制</strong></p>\n<p>LFU 策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，LFU 策略再把这个差值除以 lfu_decay_time 值，所得的结果就是数据 counter 要衰减的值。</p>\n<h2 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h2><h3 id=\"原因1：更新操作失败\"><a href=\"#原因1：更新操作失败\" class=\"headerlink\" title=\"原因1：更新操作失败\"></a>原因1：更新操作失败</h3><p>只读缓存：无法保证删改数据库和删除缓存的原子性。</p>\n<ul>\n<li>先删缓存，后更数据库（失败）：缓存缺失，数据库读取到旧值。</li>\n<li>先更数据库，后删缓存（失败）：先在缓存中查询，但此时，就会读到旧值了</li>\n</ul>\n<p><strong>解决办法：重试机制</strong></p>\n<ul>\n<li>把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。</li>\n<li>如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li>\n</ul>\n<h3 id=\"原因2：大量并发请求\"><a href=\"#原因2：大量并发请求\" class=\"headerlink\" title=\"原因2：大量并发请求\"></a>原因2：大量并发请求</h3><p><strong>先删缓存，后更数据库</strong></p>\n<p><img src=\"buyizhi.jpg\" alt=\"并发缓存不一致\"></p>\n<p><strong>解决办法：延迟双删</strong></p>\n<p>在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间（保证“偷菜”完成），再进行一次缓存删除操作。</p>\n<p>难点：sleep时间不好控制</p>\n<p><strong>先更数据库，后删缓存</strong></p>\n<p><img src=\"buyizhi2.jpg\" alt=\"并发缓存不一致2\"></p>\n<p>其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小，不需要解决。</p>\n<p>优点：不存在缓存缺失的问题，推荐！！</p>\n<p><strong>缓存更新替代删除</strong></p>\n<p>写+写并发时，必然会有数据不一致的情况。因此需要配合<strong>分布式锁</strong>使用。</p>\n<p>写+读并发时，先更数据库可能会有短时不一致。</p>\n<h2 id=\"缓存异常\"><a href=\"#缓存异常\" class=\"headerlink\" title=\"缓存异常\"></a>缓存异常</h2><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>大量的应用请求无法在 Redis 缓存中进行处理，应用将大量请求发送到数据库层，导致数据库层的压力激增。</p>\n<p><strong>原因</strong></p>\n<ul>\n<li>缓存中有大量数据同时过期</li>\n<li>Redis 缓存实例发生故障宕机了，无法处理请求</li>\n</ul>\n<p><strong>解决办法</strong></p>\n<ul>\n<li>原因1：避免给大量的数据设置相同的过期时间，数据的过期时间增加一个较小的随机数</li>\n<li>原因1：服务降级：非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取</li>\n<li>原因2：业务系统中实现服务熔断或请求限流机制。暂停业务应用对缓存系统的接口访问。业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。</li>\n<li>事前预防。建 Redis 缓存高可靠主从集群。</li>\n</ul>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>某个访问非常频繁的热点数据，无法在缓存中进行处理，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。</p>\n<p><strong>解决办法</strong></p>\n<p>访问特别频繁的热点数据，不设置过期时间</p>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。缓存也就成了“摆设”。</p>\n<p><strong>原因</strong></p>\n<ul>\n<li><p>业务层误操作：缓存中的数据和数据库中的数据被误删除了</p>\n</li>\n<li><p>恶意攻击：专门访问数据库中没有的数据。</p>\n</li>\n</ul>\n<p><strong>解决办法</strong></p>\n<ul>\n<li>针对穿透查询数据，缓存空值或缺省值。</li>\n<li>使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。大量请求只会查询 Redis 和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常运行。</li>\n<li>前端进行请求检测，恶意的请求（例如请求参数不合理、请求参数是非法值、请求字段不存在）直接过滤掉，不让它们访问后端缓存和数据库</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"redis缓存\"><a href=\"#redis缓存\" class=\"headerlink\" title=\"redis缓存\"></a>redis缓存</h2><ul>\n<li><p>应用读取数据时，需要先读取 Redis；</p>\n</li>\n<li><p>发生缓存缺失时，需要从数据库读取数据；</p>\n</li>\n<li><p>发生缓存缺失时，还需要更新缓存。</p>\n</li>\n</ul>\n<p>Redis也称为旁路缓存，因为读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p>\n<h2 id=\"缓存分类\"><a href=\"#缓存分类\" class=\"headerlink\" title=\"缓存分类\"></a>缓存分类</h2><ul>\n<li><p>只读缓存能加速读请求。</p>\n</li>\n<li><p>读写缓存可以同时加速读写请求。读写缓存又有两种数据写回策略，可根据业务需求，在保证性能和保证数据可靠性之间进行选择。</p>\n</li>\n</ul>\n<h3 id=\"只读缓存\"><a href=\"#只读缓存\" class=\"headerlink\" title=\"只读缓存\"></a>只读缓存</h3><ul>\n<li>读取数据先调用 Redis GET 接口；若不存在，应用从数据库中读取，并写到缓存中。</li>\n<li>写请求，直接发往后端的数据库；删改数据时，应用需要把这些缓存的数据删除。</li>\n</ul>\n<p><strong>优点</strong></p>\n<p>数据库和缓存可以保证完全一致，并且缓存中永远保留的是经常访问的热点数据。</p>\n<p><strong>缺点</strong></p>\n<p>每次修改操作都会把缓存中的数据删除，之后访问时都会先触发一次缓存缺失，然后从后端数据库加载数据到缓存中，这个过程访问延迟会变大。</p>\n<h3 id=\"读写缓存\"><a href=\"#读写缓存\" class=\"headerlink\" title=\"读写缓存\"></a>读写缓存</h3><p>读写请求都会发送到缓存，在缓存中直接操作数据。最新数据在redis，考虑掉电风险。</p>\n<h4 id=\"同步直写\"><a href=\"#同步直写\" class=\"headerlink\" title=\"同步直写\"></a>同步直写</h4><ul>\n<li>写请求发给缓存的同时，也会发给后端数据库，等到缓存和数据库都写完数据，才给客户端返回</li>\n<li>需要在业务应用中使用事务实现</li>\n</ul>\n<p><strong>缺点</strong>：降低缓存的访问性能</p>\n<p><strong>优点</strong>：被修改后的数据永远在缓存中存在，下次访问时，能够直接命中缓存</p>\n<h4 id=\"异步直写\"><a href=\"#异步直写\" class=\"headerlink\" title=\"异步直写\"></a>异步直写</h4><ul>\n<li>所有写请求都先在缓存中处理。等到增改的数据要被从缓存中淘汰出来时，将它们写回后端数据库</li>\n</ul>\n<p>注意：Redis 本身不提供机制将淘汰数据写回数据库</p>\n<p><strong>Read/Write Throught策略</strong></p>\n<p>应用层读写只需要操作缓存，不需要关心后端数据库。应用层在操作缓存时，缓存层会自动从数据库中加载或写回到数据库中，</p>\n<p><strong>优点</strong></p>\n<p>对于应用层的使用非常友好，只需要操作缓存即可</p>\n<p><strong>缺点</strong></p>\n<p>需要缓存层支持和后端数据库的联动。</p>\n<p><strong>Write Back策略</strong></p>\n<p>写操作只写缓存，比较简单。而读操作如果命中缓存则直接返回，否则需要从数据库中加载到缓存中，在加载之前，如果缓存已满，则先把需要淘汰的缓存数据写回到后端数据库中，再把对应的数据放入到缓存中。</p>\n<p><strong>优点</strong></p>\n<p>写操作飞快（只写缓存）</p>\n<p><strong>缺点</strong></p>\n<p>如果数据还未来得及写入后端数据库，系统发生异常会导致缓存和数据库的不一致。</p>\n<h2 id=\"缓存淘汰\"><a href=\"#缓存淘汰\" class=\"headerlink\" title=\"缓存淘汰\"></a>缓存淘汰</h2><p>“八二原理”：80% 的请求实际只访问了 20% 的数据。</p>\n<p><strong>缓存大小设置</strong>：结合应用数据实际访问特征和成本开销综合考虑，建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。</p>\n<ul>\n<li>在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis  4.0 后新增）。</li>\n<li>在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）。</li>\n</ul>\n<p><strong>LRU</strong></p>\n<p>Redis 中，LRU 算法被做了简化。</p>\n<ul>\n<li><p>Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为候选集合。</p>\n</li>\n<li><p>Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。</p>\n</li>\n<li><p>再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值</p>\n</li>\n</ul>\n<p><strong>LFU</strong></p>\n<p>从两个维度来筛选并淘汰数据：</p>\n<ul>\n<li><p>数据的被访问次数</p>\n</li>\n<li><p>数据访问的时效性，访问时间离当前时间的远近</p>\n</li>\n</ul>\n<p><strong>计数规则</strong>：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。</p>\n<p><strong>counter 值的衰减机制</strong></p>\n<p>LFU 策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，LFU 策略再把这个差值除以 lfu_decay_time 值，所得的结果就是数据 counter 要衰减的值。</p>\n<h2 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h2><h3 id=\"原因1：更新操作失败\"><a href=\"#原因1：更新操作失败\" class=\"headerlink\" title=\"原因1：更新操作失败\"></a>原因1：更新操作失败</h3><p>只读缓存：无法保证删改数据库和删除缓存的原子性。</p>\n<ul>\n<li>先删缓存，后更数据库（失败）：缓存缺失，数据库读取到旧值。</li>\n<li>先更数据库，后删缓存（失败）：先在缓存中查询，但此时，就会读到旧值了</li>\n</ul>\n<p><strong>解决办法：重试机制</strong></p>\n<ul>\n<li>把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。</li>\n<li>如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li>\n</ul>\n<h3 id=\"原因2：大量并发请求\"><a href=\"#原因2：大量并发请求\" class=\"headerlink\" title=\"原因2：大量并发请求\"></a>原因2：大量并发请求</h3><p><strong>先删缓存，后更数据库</strong></p>\n<p><img src=\"buyizhi.jpg\" alt=\"并发缓存不一致\"></p>\n<p><strong>解决办法：延迟双删</strong></p>\n<p>在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间（保证“偷菜”完成），再进行一次缓存删除操作。</p>\n<p>难点：sleep时间不好控制</p>\n<p><strong>先更数据库，后删缓存</strong></p>\n<p><img src=\"buyizhi2.jpg\" alt=\"并发缓存不一致2\"></p>\n<p>其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小，不需要解决。</p>\n<p>优点：不存在缓存缺失的问题，推荐！！</p>\n<p><strong>缓存更新替代删除</strong></p>\n<p>写+写并发时，必然会有数据不一致的情况。因此需要配合<strong>分布式锁</strong>使用。</p>\n<p>写+读并发时，先更数据库可能会有短时不一致。</p>\n<h2 id=\"缓存异常\"><a href=\"#缓存异常\" class=\"headerlink\" title=\"缓存异常\"></a>缓存异常</h2><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>大量的应用请求无法在 Redis 缓存中进行处理，应用将大量请求发送到数据库层，导致数据库层的压力激增。</p>\n<p><strong>原因</strong></p>\n<ul>\n<li>缓存中有大量数据同时过期</li>\n<li>Redis 缓存实例发生故障宕机了，无法处理请求</li>\n</ul>\n<p><strong>解决办法</strong></p>\n<ul>\n<li>原因1：避免给大量的数据设置相同的过期时间，数据的过期时间增加一个较小的随机数</li>\n<li>原因1：服务降级：非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取</li>\n<li>原因2：业务系统中实现服务熔断或请求限流机制。暂停业务应用对缓存系统的接口访问。业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。</li>\n<li>事前预防。建 Redis 缓存高可靠主从集群。</li>\n</ul>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>某个访问非常频繁的热点数据，无法在缓存中进行处理，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。</p>\n<p><strong>解决办法</strong></p>\n<p>访问特别频繁的热点数据，不设置过期时间</p>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。缓存也就成了“摆设”。</p>\n<p><strong>原因</strong></p>\n<ul>\n<li><p>业务层误操作：缓存中的数据和数据库中的数据被误删除了</p>\n</li>\n<li><p>恶意攻击：专门访问数据库中没有的数据。</p>\n</li>\n</ul>\n<p><strong>解决办法</strong></p>\n<ul>\n<li>针对穿透查询数据，缓存空值或缺省值。</li>\n<li>使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。大量请求只会查询 Redis 和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常运行。</li>\n<li>前端进行请求检测，恶意的请求（例如请求参数不合理、请求参数是非法值、请求字段不存在）直接过滤掉，不让它们访问后端缓存和数据库</li>\n</ul>\n"},{"title":"redis网络IO模型","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T14:06:23.000Z","password":null,"summary":null,"_content":"\n## 单线程\n\nRedis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的。持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。\n\n避免了多线程编程模式面临的共享资源的并发访问控制问题。\n\n## 多路复用机制\n\n一个线程处理多个 IO 流（select/epoll）：在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。\n\n为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。","source":"_posts/redis网络IO模型.md","raw":"---\ntitle: redis网络IO模型\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 22:06:23\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## 单线程\n\nRedis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的。持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。\n\n避免了多线程编程模式面临的共享资源的并发访问控制问题。\n\n## 多路复用机制\n\n一个线程处理多个 IO 流（select/epoll）：在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。\n\n为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。","slug":"redis网络IO模型","published":1,"updated":"2020-10-26T14:06:52.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wai002bi4uf8niy5qnk","content":"<h2 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h2><p>Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的。持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p>\n<p>避免了多线程编程模式面临的共享资源的并发访问控制问题。</p>\n<h2 id=\"多路复用机制\"><a href=\"#多路复用机制\" class=\"headerlink\" title=\"多路复用机制\"></a>多路复用机制</h2><p>一个线程处理多个 IO 流（select/epoll）：在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>\n<p>为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h2><p>Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的。持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p>\n<p>避免了多线程编程模式面临的共享资源的并发访问控制问题。</p>\n<h2 id=\"多路复用机制\"><a href=\"#多路复用机制\" class=\"headerlink\" title=\"多路复用机制\"></a>多路复用机制</h2><p>一个线程处理多个 IO 流（select/epoll）：在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>\n<p>为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。</p>\n"},{"title":"redis阻塞及解决办法","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T13:39:01.000Z","password":null,"summary":null,"_content":"\n\n\n---\n\n## 阻塞分析\n\n### 客户端\n\n**复杂度高的增删改查操作**\n1、集合全量查询和聚合操作\n2、bigkey 删除\n3、清空数据库\n\n\n### 磁盘\n\n1、AOF 日志同步写\n\n### 主从节点\n\n1、从库接收 RDB 文件后、**清空数据库、加载 RDB 文件**；\n\n### 切片集群\n\n向其他实例传输哈希槽信息，数据迁移时遇到big key。\n\n### 小结\n\n关键路径：集合全量查询和聚合操作和从库加载 RDB 文件\n非关键路径： bigkey 删除，清空数据库，以及 AOF 日志同步写。\n\n## 解决方案\n\n### 异步的子线程机制\n\nRedis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成（惰性删除）。当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完了。\n\n注：异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能。之前的版本Big key删除可以先使用集合类型提供的 SCAN 命令读取数据，然后再进行删除。因为用 SCAN 命令可以每次只读取一部分数据并进行删除，这样可以避免一次性删除大量 key 给主线程带来的阻塞。\n\n### 分批读取\n集合全量查询和聚合操作：可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算\n\n### 控制RBD大小\n从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。","source":"_posts/redis阻塞及解决办法.md","raw":"---\ntitle: redis阻塞及解决办法\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 21:39:01\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n\n\n---\n\n## 阻塞分析\n\n### 客户端\n\n**复杂度高的增删改查操作**\n1、集合全量查询和聚合操作\n2、bigkey 删除\n3、清空数据库\n\n\n### 磁盘\n\n1、AOF 日志同步写\n\n### 主从节点\n\n1、从库接收 RDB 文件后、**清空数据库、加载 RDB 文件**；\n\n### 切片集群\n\n向其他实例传输哈希槽信息，数据迁移时遇到big key。\n\n### 小结\n\n关键路径：集合全量查询和聚合操作和从库加载 RDB 文件\n非关键路径： bigkey 删除，清空数据库，以及 AOF 日志同步写。\n\n## 解决方案\n\n### 异步的子线程机制\n\nRedis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成（惰性删除）。当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完了。\n\n注：异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能。之前的版本Big key删除可以先使用集合类型提供的 SCAN 命令读取数据，然后再进行删除。因为用 SCAN 命令可以每次只读取一部分数据并进行删除，这样可以避免一次性删除大量 key 给主线程带来的阻塞。\n\n### 分批读取\n集合全量查询和聚合操作：可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算\n\n### 控制RBD大小\n从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。","slug":"redis阻塞及解决办法","published":1,"updated":"2021-03-07T12:24:43.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944waq002ei4uf1roy3d8l","content":"<hr>\n<h2 id=\"阻塞分析\"><a href=\"#阻塞分析\" class=\"headerlink\" title=\"阻塞分析\"></a>阻塞分析</h2><h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p><strong>复杂度高的增删改查操作</strong><br>1、集合全量查询和聚合操作<br>2、bigkey 删除<br>3、清空数据库</p>\n<h3 id=\"磁盘\"><a href=\"#磁盘\" class=\"headerlink\" title=\"磁盘\"></a>磁盘</h3><p>1、AOF 日志同步写</p>\n<h3 id=\"主从节点\"><a href=\"#主从节点\" class=\"headerlink\" title=\"主从节点\"></a>主从节点</h3><p>1、从库接收 RDB 文件后、<strong>清空数据库、加载 RDB 文件</strong>；</p>\n<h3 id=\"切片集群\"><a href=\"#切片集群\" class=\"headerlink\" title=\"切片集群\"></a>切片集群</h3><p>向其他实例传输哈希槽信息，数据迁移时遇到big key。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>关键路径：集合全量查询和聚合操作和从库加载 RDB 文件<br>非关键路径： bigkey 删除，清空数据库，以及 AOF 日志同步写。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"异步的子线程机制\"><a href=\"#异步的子线程机制\" class=\"headerlink\" title=\"异步的子线程机制\"></a>异步的子线程机制</h3><p>Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成（惰性删除）。当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完了。</p>\n<p>注：异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能。之前的版本Big key删除可以先使用集合类型提供的 SCAN 命令读取数据，然后再进行删除。因为用 SCAN 命令可以每次只读取一部分数据并进行删除，这样可以避免一次性删除大量 key 给主线程带来的阻塞。</p>\n<h3 id=\"分批读取\"><a href=\"#分批读取\" class=\"headerlink\" title=\"分批读取\"></a>分批读取</h3><p>集合全量查询和聚合操作：可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算</p>\n<h3 id=\"控制RBD大小\"><a href=\"#控制RBD大小\" class=\"headerlink\" title=\"控制RBD大小\"></a>控制RBD大小</h3><p>从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<hr>\n<h2 id=\"阻塞分析\"><a href=\"#阻塞分析\" class=\"headerlink\" title=\"阻塞分析\"></a>阻塞分析</h2><h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p><strong>复杂度高的增删改查操作</strong><br>1、集合全量查询和聚合操作<br>2、bigkey 删除<br>3、清空数据库</p>\n<h3 id=\"磁盘\"><a href=\"#磁盘\" class=\"headerlink\" title=\"磁盘\"></a>磁盘</h3><p>1、AOF 日志同步写</p>\n<h3 id=\"主从节点\"><a href=\"#主从节点\" class=\"headerlink\" title=\"主从节点\"></a>主从节点</h3><p>1、从库接收 RDB 文件后、<strong>清空数据库、加载 RDB 文件</strong>；</p>\n<h3 id=\"切片集群\"><a href=\"#切片集群\" class=\"headerlink\" title=\"切片集群\"></a>切片集群</h3><p>向其他实例传输哈希槽信息，数据迁移时遇到big key。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>关键路径：集合全量查询和聚合操作和从库加载 RDB 文件<br>非关键路径： bigkey 删除，清空数据库，以及 AOF 日志同步写。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"异步的子线程机制\"><a href=\"#异步的子线程机制\" class=\"headerlink\" title=\"异步的子线程机制\"></a>异步的子线程机制</h3><p>Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成（惰性删除）。当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完了。</p>\n<p>注：异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能。之前的版本Big key删除可以先使用集合类型提供的 SCAN 命令读取数据，然后再进行删除。因为用 SCAN 命令可以每次只读取一部分数据并进行删除，这样可以避免一次性删除大量 key 给主线程带来的阻塞。</p>\n<h3 id=\"分批读取\"><a href=\"#分批读取\" class=\"headerlink\" title=\"分批读取\"></a>分批读取</h3><p>集合全量查询和聚合操作：可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算</p>\n<h3 id=\"控制RBD大小\"><a href=\"#控制RBD大小\" class=\"headerlink\" title=\"控制RBD大小\"></a>控制RBD大小</h3><p>从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。</p>\n"},{"title":"十大经典排序算法整理汇总（附代码）","top":true,"cover":false,"toc":true,"mathjax":true,"date":"2020-02-16T07:09:23.000Z","password":null,"summary":"本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。","_content":"\n> 关注公众号【算法码上来】，每日算法干货马上就来！\n\n![](/medias/contact.jpg)\n\n## 前言\n\n本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。\n\n**本文并不会详细讲解每种排序算法的原理**，网上有很多很好的教程，大家可以自己去搜了看。\n\n最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 [LeetCode 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/ \"LeetCode 912. 排序数组\") 这道题。\n\n## 性质汇总\n\n> 如果发现表中有错误，请留言告知。\n\n|   算法  |   最好  |  最坏   |  平均   |  空间   |  稳定性   | 是否基于比较\n| --- | --- | --- | --- | --- | :---: | :---: |\n|  冒泡排序   |  $O(n)$   |   $O(n^2)$  |  $O(n^2)$   |  $O(1)$   | $\\checkmark$  | $\\checkmark$ |\n|   选择排序  |  $O(n^2)$  |   $O(n^2)$  |  $O(n^2)$   |  $O(1)$   | $\\times$  | $\\checkmark$ |\n|   插入排序  |  $O(n)$   |   $O(n^2)$  |  $O(n^2)$   |  $O(1)$   | $\\checkmark$  | $\\checkmark$ |\n|  快速排序   |  $O(n\\log n)$   |  $O(n^2)$   |  $O(n\\log n)$   |  $O(\\log n)$~$O(n)$   |  $\\times$   | $\\checkmark$ |\n|  归并排序   |  $O(n\\log n)$   |   $O(n\\log n)$  |  $O(n\\log n)$   |   $O(n)$  |  $\\checkmark$   | $\\checkmark$ |\n|   希尔排序  |  $O(n^{1.3})$   |   $O(n^2)$  |  $O(n\\log n)$~$O(n^2)$   |  $O(1)$   | $\\times$    | $\\checkmark$ |\n|  计数排序   |  $O(n+k)$   |   $O(n+k)$  |   $O(n+k)$  |  $O(n+k)$   |  $\\checkmark$   | $\\times$ |\n|   基数排序  |   $O(nk)$  |  $O(nk)$   |   $O(nk)$  |   $O(n+k)$  |  $\\checkmark$   | $\\times$ |\n|  桶排序   |   $O(n)$  |   $O(n)$  |   $O(n)$  |  $O(n+m)$   |  $\\checkmark$   | $\\times$ |\n|  堆排序   |  $O(n\\log n)$   |   $O(n\\log n)$  |  $O(n\\log n)$   |   $O(1)$  |  $\\times$   | $\\checkmark$ |\n\n\n\n> 如果表格显示有问题的话，还可以直接看下面的汇总图：\n\n![十大经典排序算法性质汇总](1.png)\n\n### 维基百科\n\n我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。\n\n**冒泡排序**  \n[https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)\n\n**选择排序**  \n[https://en.wikipedia.org/wiki/Selection_sort](https://en.wikipedia.org/wiki/Selection_sort)\n\n**插入排序**  \n[https://en.wikipedia.org/wiki/Insertion_sort](https://en.wikipedia.org/wiki/Insertion_sort)\n\n**快速排序**  \n[https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort)\n\n**归并排序**  \n[https://en.wikipedia.org/wiki/Merge_sort](https://en.wikipedia.org/wiki/Merge_sort)\n\n**希尔排序**  \n[https://en.wikipedia.org/wiki/Shellsort](https://en.wikipedia.org/wiki/Shellsort)\n\n**计数排序**  \n[https://en.wikipedia.org/wiki/Counting_sort](https://en.wikipedia.org/wiki/Counting_sort)\n\n**基数排序**  \n[https://en.wikipedia.org/wiki/Radix_sort](https://en.wikipedia.org/wiki/Radix_sort)\n\n**桶排序**  \n[https://en.wikipedia.org/wiki/Bucket_sort](https://en.wikipedia.org/wiki/Bucket_sort)\n\n**堆排序**  \n[https://en.wikipedia.org/wiki/Heapsort](https://en.wikipedia.org/wiki/Heapsort)\n\n## 代码实现\n\n所有的排序算法接口都是相同的，也就是 `vector<int> xxxSort(vector<int>& nums)` 。只需要你传入一个 `vector<int>` 类型的数组，就能返回排序后的结果。\n\n运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        return quickSort(nums);\n    }\n\n    // 冒泡排序（超时）\n    vector<int> bubbleSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = n-2; j >= i; --j) {\n                if (nums[j] > nums[j+1]) {\n                    swap(nums[j], nums[j+1]);\n                }\n            }\n        }\n        return nums;\n    }\n\n    // 选择排序（超时）\n    vector<int> selectSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            int idx = i;\n            for (int j = i; j < n; ++j) {\n                if (nums[j] < nums[idx]) {\n                    idx = j;\n                }\n            }\n            swap(nums[i], nums[idx]);\n        }\n        return nums;\n    }\n\n    // 插入排序（超时）\n    vector<int> insertSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = i; j > 0 && nums[j] < nums[j-1]; --j) {\n                swap(nums[j], nums[j-1]);\n            }\n        }\n        return nums;\n    }\n\n    // 快速排序（24 ms）\n    void qSort(vector<int>& nums, int l, int r) {\n        if (l >= r) return;\n        int m = l;\n        for (int i = l; i < r; ++i) {\n            if (nums[i] < nums[r]) {\n                swap(nums[m++], nums[i]);\n            }\n        }\n        swap(nums[m], nums[r]);\n        qSort(nums, l, m-1);\n        qSort(nums, m+1, r);\n    }\n\n    vector<int> quickSort(vector<int>& nums) {\n        int n = nums.size();\n        qSort(nums, 0, n-1);\n        return nums;\n    }\n\n    // 归并排序（192 ms）\n    vector<int> mSort(vector<int>& nums, int l, int r) {\n        if (l >= r) return {nums[l]};\n        int m = l+(r-l)/2;\n        vector<int> lnums = mSort(nums, l, m);\n        vector<int> rnums = mSort(nums, m+1, r);\n        vector<int> res;\n        int i = 0, j = 0;\n        while (i <= m-l && j <= r-m-1) {\n            if (lnums[i] < rnums[j]) {\n                res.push_back(lnums[i++]);\n            } else {\n                res.push_back(rnums[j++]);\n            }\n        }\n        while (i <= m-l) {\n            res.push_back(lnums[i++]);\n        }\n        while (j <= r-m-1) {\n            res.push_back(rnums[j++]);\n        }\n        return res;\n    }\n\n    vector<int> mergeSort(vector<int>& nums) {\n        int n = nums.size();\n        nums = mSort(nums, 0, n-1);\n        return nums;\n    }\n\n    // 归并排序 + 非递归（80 ms）\n    vector<int> mergeSortNR(vector<int>& nums) {\n        int n = nums.size();\n        for (int len = 1; len < n; len <<= 1) {\n            for (int l = 0; l < n-len; l += 2*len) {\n                int m = l+len-1;\n                int r = min(n-1, l+2*len-1);\n                vector<int> res;\n                int i = l, j = m+1;\n                while (i <= m && j <= r) {\n                    if (nums[i] < nums[j]) {\n                        res.push_back(nums[i++]);\n                    } else {\n                        res.push_back(nums[j++]);\n                    }\n                }\n                while (i <= m) {\n                    res.push_back(nums[i++]);\n                }\n                while (j <= r) {\n                    res.push_back(nums[j++]);\n                }\n                for (int i = l; i <= r; ++i) {\n                    nums[i] = res[i-l];\n                }\n            }\n        }\n        return nums;\n    }\n\n    // 希尔排序（40 ms）\n    vector<int> shellSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int gap = n/2; gap > 0; gap /= 2) {\n            for (int i = gap; i < n; ++i) {\n                for (int j = i; j-gap >= 0 && nums[j-gap] > nums[j]; j -= gap) {\n                    swap(nums[j-gap], nums[j]);\n                }\n            }\n        }\n        return nums;\n    }\n\n    // 计数排序（32 ms）\n    vector<int> countSort(vector<int>& nums) {\n        int n = nums.size();\n        if (!n) return {};\n        int minv = *min_element(nums.begin(), nums.end());\n        int maxv = *max_element(nums.begin(), nums.end());\n        int m = maxv-minv+1;\n        vector<int> count(m, 0);\n        for (int i = 0; i < n; ++i) {\n            count[nums[i]-minv]++;\n        }\n        vector<int> res;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < count[i]; ++j) {\n                res.push_back(i+minv);\n            }\n        }\n        return res;\n    }\n\n    // 基数排序（不适用于负数）\n    vector<int> radixSort(vector<int>& nums) {\n        int n = nums.size();\n        int maxv = *max_element(nums.begin(), nums.end());\n        int maxd = 0;\n        while (maxv > 0) {\n            maxv /= 10;\n            maxd++;\n        }\n        vector<int> count(10, 0), rank(n, 0);\n        int base = 1;\n        while (maxd > 0) {\n            count.assign(10, 0);\n            for (int i = 0; i < n; ++i) {\n                count[(nums[i]/base)%10]++;\n            }\n            for (int i = 1; i < 10; ++i) {\n                count[i] += count[i-1];\n            }\n            for (int i = n-1; i >= 0; --i) {\n                rank[--count[(nums[i]/base)%10]] = nums[i];\n            }\n            for (int i = 0; i < n; ++i) {\n                nums[i] = rank[i];\n            }\n            maxd--;\n            base *= 10;\n        }\n        return nums;\n    }\n\n    // 桶排序 (20 ms)\n    vector<int> bucketSort(vector<int>& nums) {\n        int n = nums.size();\n        int maxv = *max_element(nums.begin(), nums.end());\n        int minv = *min_element(nums.begin(), nums.end());\n        int bs = 1000;\n        int m = (maxv-minv)/bs+1;\n        vector<vector<int> > bucket(m);\n        for (int i = 0; i < n; ++i) {\n            bucket[(nums[i]-minv)/bs].push_back(nums[i]);\n        }\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            int sz = bucket[i].size();\n            bucket[i] = quickSort(bucket[i]);\n            for (int j = 0; j < sz; ++j) {\n                nums[idx++] = bucket[i][j];\n            }\n        }\n        return nums;\n    }\n\n    // 堆排序（32 ms）\n    void adjust(vector<int>& nums, int p, int s) {\n        while (2*p+1 < s) {\n            int c1 = 2*p+1;\n            int c2 = 2*p+2;\n            int c = (c2<s && nums[c2]>nums[c1]) ? c2 : c1;\n            if (nums[c] > nums[p]) swap(nums[c], nums[p]);\n            else break;\n            p = c;\n        }\n    }\n\n    vector<int> heapSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = n/2-1; i >= 0; --i) {\n            adjust(nums, i, n);\n        }\n        for (int i = n-1; i > 0; --i) {\n            swap(nums[0], nums[i]);\n            adjust(nums, 0, i);\n        }\n        return nums;\n    }\n};\n```","source":"_posts/sort-algorithms.md","raw":"---\ntitle: 十大经典排序算法整理汇总（附代码）\ntop: true\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-02-16 15:09:23\npassword:\nsummary: 本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。\ntags:\n- leetcode\n- 算法\ncategories:\n- 编程算法\n---\n\n> 关注公众号【算法码上来】，每日算法干货马上就来！\n\n![](/medias/contact.jpg)\n\n## 前言\n\n本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。\n\n**本文并不会详细讲解每种排序算法的原理**，网上有很多很好的教程，大家可以自己去搜了看。\n\n最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 [LeetCode 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/ \"LeetCode 912. 排序数组\") 这道题。\n\n## 性质汇总\n\n> 如果发现表中有错误，请留言告知。\n\n|   算法  |   最好  |  最坏   |  平均   |  空间   |  稳定性   | 是否基于比较\n| --- | --- | --- | --- | --- | :---: | :---: |\n|  冒泡排序   |  $O(n)$   |   $O(n^2)$  |  $O(n^2)$   |  $O(1)$   | $\\checkmark$  | $\\checkmark$ |\n|   选择排序  |  $O(n^2)$  |   $O(n^2)$  |  $O(n^2)$   |  $O(1)$   | $\\times$  | $\\checkmark$ |\n|   插入排序  |  $O(n)$   |   $O(n^2)$  |  $O(n^2)$   |  $O(1)$   | $\\checkmark$  | $\\checkmark$ |\n|  快速排序   |  $O(n\\log n)$   |  $O(n^2)$   |  $O(n\\log n)$   |  $O(\\log n)$~$O(n)$   |  $\\times$   | $\\checkmark$ |\n|  归并排序   |  $O(n\\log n)$   |   $O(n\\log n)$  |  $O(n\\log n)$   |   $O(n)$  |  $\\checkmark$   | $\\checkmark$ |\n|   希尔排序  |  $O(n^{1.3})$   |   $O(n^2)$  |  $O(n\\log n)$~$O(n^2)$   |  $O(1)$   | $\\times$    | $\\checkmark$ |\n|  计数排序   |  $O(n+k)$   |   $O(n+k)$  |   $O(n+k)$  |  $O(n+k)$   |  $\\checkmark$   | $\\times$ |\n|   基数排序  |   $O(nk)$  |  $O(nk)$   |   $O(nk)$  |   $O(n+k)$  |  $\\checkmark$   | $\\times$ |\n|  桶排序   |   $O(n)$  |   $O(n)$  |   $O(n)$  |  $O(n+m)$   |  $\\checkmark$   | $\\times$ |\n|  堆排序   |  $O(n\\log n)$   |   $O(n\\log n)$  |  $O(n\\log n)$   |   $O(1)$  |  $\\times$   | $\\checkmark$ |\n\n\n\n> 如果表格显示有问题的话，还可以直接看下面的汇总图：\n\n![十大经典排序算法性质汇总](1.png)\n\n### 维基百科\n\n我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。\n\n**冒泡排序**  \n[https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)\n\n**选择排序**  \n[https://en.wikipedia.org/wiki/Selection_sort](https://en.wikipedia.org/wiki/Selection_sort)\n\n**插入排序**  \n[https://en.wikipedia.org/wiki/Insertion_sort](https://en.wikipedia.org/wiki/Insertion_sort)\n\n**快速排序**  \n[https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort)\n\n**归并排序**  \n[https://en.wikipedia.org/wiki/Merge_sort](https://en.wikipedia.org/wiki/Merge_sort)\n\n**希尔排序**  \n[https://en.wikipedia.org/wiki/Shellsort](https://en.wikipedia.org/wiki/Shellsort)\n\n**计数排序**  \n[https://en.wikipedia.org/wiki/Counting_sort](https://en.wikipedia.org/wiki/Counting_sort)\n\n**基数排序**  \n[https://en.wikipedia.org/wiki/Radix_sort](https://en.wikipedia.org/wiki/Radix_sort)\n\n**桶排序**  \n[https://en.wikipedia.org/wiki/Bucket_sort](https://en.wikipedia.org/wiki/Bucket_sort)\n\n**堆排序**  \n[https://en.wikipedia.org/wiki/Heapsort](https://en.wikipedia.org/wiki/Heapsort)\n\n## 代码实现\n\n所有的排序算法接口都是相同的，也就是 `vector<int> xxxSort(vector<int>& nums)` 。只需要你传入一个 `vector<int>` 类型的数组，就能返回排序后的结果。\n\n运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        return quickSort(nums);\n    }\n\n    // 冒泡排序（超时）\n    vector<int> bubbleSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = n-2; j >= i; --j) {\n                if (nums[j] > nums[j+1]) {\n                    swap(nums[j], nums[j+1]);\n                }\n            }\n        }\n        return nums;\n    }\n\n    // 选择排序（超时）\n    vector<int> selectSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            int idx = i;\n            for (int j = i; j < n; ++j) {\n                if (nums[j] < nums[idx]) {\n                    idx = j;\n                }\n            }\n            swap(nums[i], nums[idx]);\n        }\n        return nums;\n    }\n\n    // 插入排序（超时）\n    vector<int> insertSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = i; j > 0 && nums[j] < nums[j-1]; --j) {\n                swap(nums[j], nums[j-1]);\n            }\n        }\n        return nums;\n    }\n\n    // 快速排序（24 ms）\n    void qSort(vector<int>& nums, int l, int r) {\n        if (l >= r) return;\n        int m = l;\n        for (int i = l; i < r; ++i) {\n            if (nums[i] < nums[r]) {\n                swap(nums[m++], nums[i]);\n            }\n        }\n        swap(nums[m], nums[r]);\n        qSort(nums, l, m-1);\n        qSort(nums, m+1, r);\n    }\n\n    vector<int> quickSort(vector<int>& nums) {\n        int n = nums.size();\n        qSort(nums, 0, n-1);\n        return nums;\n    }\n\n    // 归并排序（192 ms）\n    vector<int> mSort(vector<int>& nums, int l, int r) {\n        if (l >= r) return {nums[l]};\n        int m = l+(r-l)/2;\n        vector<int> lnums = mSort(nums, l, m);\n        vector<int> rnums = mSort(nums, m+1, r);\n        vector<int> res;\n        int i = 0, j = 0;\n        while (i <= m-l && j <= r-m-1) {\n            if (lnums[i] < rnums[j]) {\n                res.push_back(lnums[i++]);\n            } else {\n                res.push_back(rnums[j++]);\n            }\n        }\n        while (i <= m-l) {\n            res.push_back(lnums[i++]);\n        }\n        while (j <= r-m-1) {\n            res.push_back(rnums[j++]);\n        }\n        return res;\n    }\n\n    vector<int> mergeSort(vector<int>& nums) {\n        int n = nums.size();\n        nums = mSort(nums, 0, n-1);\n        return nums;\n    }\n\n    // 归并排序 + 非递归（80 ms）\n    vector<int> mergeSortNR(vector<int>& nums) {\n        int n = nums.size();\n        for (int len = 1; len < n; len <<= 1) {\n            for (int l = 0; l < n-len; l += 2*len) {\n                int m = l+len-1;\n                int r = min(n-1, l+2*len-1);\n                vector<int> res;\n                int i = l, j = m+1;\n                while (i <= m && j <= r) {\n                    if (nums[i] < nums[j]) {\n                        res.push_back(nums[i++]);\n                    } else {\n                        res.push_back(nums[j++]);\n                    }\n                }\n                while (i <= m) {\n                    res.push_back(nums[i++]);\n                }\n                while (j <= r) {\n                    res.push_back(nums[j++]);\n                }\n                for (int i = l; i <= r; ++i) {\n                    nums[i] = res[i-l];\n                }\n            }\n        }\n        return nums;\n    }\n\n    // 希尔排序（40 ms）\n    vector<int> shellSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int gap = n/2; gap > 0; gap /= 2) {\n            for (int i = gap; i < n; ++i) {\n                for (int j = i; j-gap >= 0 && nums[j-gap] > nums[j]; j -= gap) {\n                    swap(nums[j-gap], nums[j]);\n                }\n            }\n        }\n        return nums;\n    }\n\n    // 计数排序（32 ms）\n    vector<int> countSort(vector<int>& nums) {\n        int n = nums.size();\n        if (!n) return {};\n        int minv = *min_element(nums.begin(), nums.end());\n        int maxv = *max_element(nums.begin(), nums.end());\n        int m = maxv-minv+1;\n        vector<int> count(m, 0);\n        for (int i = 0; i < n; ++i) {\n            count[nums[i]-minv]++;\n        }\n        vector<int> res;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < count[i]; ++j) {\n                res.push_back(i+minv);\n            }\n        }\n        return res;\n    }\n\n    // 基数排序（不适用于负数）\n    vector<int> radixSort(vector<int>& nums) {\n        int n = nums.size();\n        int maxv = *max_element(nums.begin(), nums.end());\n        int maxd = 0;\n        while (maxv > 0) {\n            maxv /= 10;\n            maxd++;\n        }\n        vector<int> count(10, 0), rank(n, 0);\n        int base = 1;\n        while (maxd > 0) {\n            count.assign(10, 0);\n            for (int i = 0; i < n; ++i) {\n                count[(nums[i]/base)%10]++;\n            }\n            for (int i = 1; i < 10; ++i) {\n                count[i] += count[i-1];\n            }\n            for (int i = n-1; i >= 0; --i) {\n                rank[--count[(nums[i]/base)%10]] = nums[i];\n            }\n            for (int i = 0; i < n; ++i) {\n                nums[i] = rank[i];\n            }\n            maxd--;\n            base *= 10;\n        }\n        return nums;\n    }\n\n    // 桶排序 (20 ms)\n    vector<int> bucketSort(vector<int>& nums) {\n        int n = nums.size();\n        int maxv = *max_element(nums.begin(), nums.end());\n        int minv = *min_element(nums.begin(), nums.end());\n        int bs = 1000;\n        int m = (maxv-minv)/bs+1;\n        vector<vector<int> > bucket(m);\n        for (int i = 0; i < n; ++i) {\n            bucket[(nums[i]-minv)/bs].push_back(nums[i]);\n        }\n        int idx = 0;\n        for (int i = 0; i < m; ++i) {\n            int sz = bucket[i].size();\n            bucket[i] = quickSort(bucket[i]);\n            for (int j = 0; j < sz; ++j) {\n                nums[idx++] = bucket[i][j];\n            }\n        }\n        return nums;\n    }\n\n    // 堆排序（32 ms）\n    void adjust(vector<int>& nums, int p, int s) {\n        while (2*p+1 < s) {\n            int c1 = 2*p+1;\n            int c2 = 2*p+2;\n            int c = (c2<s && nums[c2]>nums[c1]) ? c2 : c1;\n            if (nums[c] > nums[p]) swap(nums[c], nums[p]);\n            else break;\n            p = c;\n        }\n    }\n\n    vector<int> heapSort(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = n/2-1; i >= 0; --i) {\n            adjust(nums, i, n);\n        }\n        for (int i = n-1; i > 0; --i) {\n            swap(nums[0], nums[i]);\n            adjust(nums, 0, i);\n        }\n        return nums;\n    }\n};\n```","slug":"sort-algorithms","published":1,"updated":"2020-04-04T11:43:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944way002ji4uf2coh7cmd","content":"<blockquote>\n<p>关注公众号【算法码上来】，每日算法干货马上就来！</p>\n</blockquote>\n<p><img src=\"/medias/contact.jpg\" alt></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p>\n<p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p>\n<p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href=\"https://leetcode-cn.com/problems/sort-an-array/\" title=\"LeetCode 912. 排序数组\" target=\"_blank\" rel=\"noopener\">LeetCode 912. 排序数组</a> 这道题。</p>\n<h2 id=\"性质汇总\"><a href=\"#性质汇总\" class=\"headerlink\" title=\"性质汇总\"></a>性质汇总</h2><blockquote>\n<p>如果发现表中有错误，请留言告知。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>最好</th>\n<th>最坏</th>\n<th>平均</th>\n<th>空间</th>\n<th align=\"center\">稳定性</th>\n<th align=\"center\">是否基于比较</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>冒泡排序</td>\n<td>$O(n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\times$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>$O(n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(\\log n)$~$O(n)$</td>\n<td align=\"center\">$\\times$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>$O(n^{1.3})$</td>\n<td>$O(n^2)$</td>\n<td>$O(n\\log n)$~$O(n^2)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\times$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>计数排序</td>\n<td>$O(n+k)$</td>\n<td>$O(n+k)$</td>\n<td>$O(n+k)$</td>\n<td>$O(n+k)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\times$</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>$O(nk)$</td>\n<td>$O(nk)$</td>\n<td>$O(nk)$</td>\n<td>$O(n+k)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\times$</td>\n</tr>\n<tr>\n<td>桶排序</td>\n<td>$O(n)$</td>\n<td>$O(n)$</td>\n<td>$O(n)$</td>\n<td>$O(n+m)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\times$</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\times$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p>\n</blockquote>\n<p><img src=\"1.png\" alt=\"十大经典排序算法性质汇总\"></p>\n<h3 id=\"维基百科\"><a href=\"#维基百科\" class=\"headerlink\" title=\"维基百科\"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p>\n<p><strong>冒泡排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Bubble_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Bubble_sort</a></p>\n<p><strong>选择排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Selection_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Selection_sort</a></p>\n<p><strong>插入排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Insertion_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Insertion_sort</a></p>\n<p><strong>快速排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Quicksort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Quicksort</a></p>\n<p><strong>归并排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Merge_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Merge_sort</a></p>\n<p><strong>希尔排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Shellsort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Shellsort</a></p>\n<p><strong>计数排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Counting_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Counting_sort</a></p>\n<p><strong>基数排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Radix_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Radix_sort</a></p>\n<p><strong>桶排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Bucket_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Bucket_sort</a></p>\n<p><strong>堆排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Heapsort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Heapsort</a></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p>\n<p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">sortArray</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 冒泡排序（超时）</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> n<span class=\"token number\">-2</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> i<span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 选择排序（超时）</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">selectSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> idx <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    idx <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 插入排序（超时）</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">insertSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 快速排序（24 ms）</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">qSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> r<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> l<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> l<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> r<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>m<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">qSort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> m<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">qSort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> m<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">qSort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 归并排序（192 ms）</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">mSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> r<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>nums<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> l<span class=\"token operator\">+</span><span class=\"token punctuation\">(</span>r<span class=\"token operator\">-</span>l<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> lnums <span class=\"token operator\">=</span> <span class=\"token function\">mSort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> rnums <span class=\"token operator\">=</span> <span class=\"token function\">mSort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> m<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> res<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> m<span class=\"token operator\">-</span>l <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">&lt;=</span> r<span class=\"token operator\">-</span>m<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lnums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> rnums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>lnums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>rnums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> m<span class=\"token operator\">-</span>l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>lnums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;=</span> r<span class=\"token operator\">-</span>m<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>rnums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        nums <span class=\"token operator\">=</span> <span class=\"token function\">mSort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 归并排序 + 非递归（80 ms）</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">mergeSortNR</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> len <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> len <span class=\"token operator\">&lt;&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> l <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> l <span class=\"token operator\">&lt;</span> n<span class=\"token operator\">-</span>len<span class=\"token punctuation\">;</span> l <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> l<span class=\"token operator\">+</span>len<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> r <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>n<span class=\"token number\">-1</span><span class=\"token punctuation\">,</span> l<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>len<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> res<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> l<span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> m<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> m <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">&lt;=</span> r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                        res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;=</span> m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;=</span> r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> l<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> r<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> res<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 希尔排序（40 ms）</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">shellSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> gap <span class=\"token operator\">=</span> n<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span> gap <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> gap <span class=\"token operator\">/</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> gap<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">-</span>gap <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span>gap<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">-</span><span class=\"token operator\">=</span> gap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span>gap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 计数排序（32 ms）</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">countSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> minv <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token function\">min_element</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> maxv <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token function\">max_element</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> maxv<span class=\"token operator\">-</span>minv<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            count<span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>minv<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> res<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> count<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                res<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span>minv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 基数排序（不适用于负数）</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> maxv <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token function\">max_element</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> maxd <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>maxv <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            maxv <span class=\"token operator\">/</span><span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n            maxd<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">rank</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> base <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>maxd <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            count<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                count<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span>base<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                count<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> count<span class=\"token punctuation\">[</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                rank<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>count<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span>base<span class=\"token punctuation\">)</span><span class=\"token operator\">%</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> rank<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            maxd<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            base <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 桶排序 (20 ms)</span>\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">bucketSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> maxv <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token function\">max_element</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> minv <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token function\">min_element</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> bs <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>maxv<span class=\"token operator\">-</span>minv<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>bs<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        vector<span class=\"token operator\">&lt;</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token operator\">></span> <span class=\"token function\">bucket</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            bucket<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span>minv<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>bs<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">int</span> idx <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> sz <span class=\"token operator\">=</span> bucket<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            bucket<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> sz<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                nums<span class=\"token punctuation\">[</span>idx<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> bucket<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 堆排序（32 ms）</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">adjust</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> p<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>p<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> c1 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>p<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> c2 <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>p<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>c2<span class=\"token operator\">&lt;</span>s <span class=\"token operator\">&amp;&amp;</span> nums<span class=\"token punctuation\">[</span>c2<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>nums<span class=\"token punctuation\">[</span>c1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> c2 <span class=\"token operator\">:</span> c1<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> nums<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>p<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            p <span class=\"token operator\">=</span> c<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> <span class=\"token function\">heapSort</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">adjust</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> n<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">adjust</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> nums<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<blockquote>\n<p>关注公众号【算法码上来】，每日算法干货马上就来！</p>\n</blockquote>\n<p><img src=\"/medias/contact.jpg\" alt></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p>\n<p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p>\n<p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href=\"https://leetcode-cn.com/problems/sort-an-array/\" title=\"LeetCode 912. 排序数组\" target=\"_blank\" rel=\"noopener\">LeetCode 912. 排序数组</a> 这道题。</p>\n<h2 id=\"性质汇总\"><a href=\"#性质汇总\" class=\"headerlink\" title=\"性质汇总\"></a>性质汇总</h2><blockquote>\n<p>如果发现表中有错误，请留言告知。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>最好</th>\n<th>最坏</th>\n<th>平均</th>\n<th>空间</th>\n<th align=\"center\">稳定性</th>\n<th align=\"center\">是否基于比较</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>冒泡排序</td>\n<td>$O(n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\times$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>$O(n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n^2)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n^2)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(\\log n)$~$O(n)$</td>\n<td align=\"center\">$\\times$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>$O(n^{1.3})$</td>\n<td>$O(n^2)$</td>\n<td>$O(n\\log n)$~$O(n^2)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\times$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n<tr>\n<td>计数排序</td>\n<td>$O(n+k)$</td>\n<td>$O(n+k)$</td>\n<td>$O(n+k)$</td>\n<td>$O(n+k)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\times$</td>\n</tr>\n<tr>\n<td>基数排序</td>\n<td>$O(nk)$</td>\n<td>$O(nk)$</td>\n<td>$O(nk)$</td>\n<td>$O(n+k)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\times$</td>\n</tr>\n<tr>\n<td>桶排序</td>\n<td>$O(n)$</td>\n<td>$O(n)$</td>\n<td>$O(n)$</td>\n<td>$O(n+m)$</td>\n<td align=\"center\">$\\checkmark$</td>\n<td align=\"center\">$\\times$</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(n\\log n)$</td>\n<td>$O(1)$</td>\n<td align=\"center\">$\\times$</td>\n<td align=\"center\">$\\checkmark$</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p>\n</blockquote>\n<p><img src=\"1.png\" alt=\"十大经典排序算法性质汇总\"></p>\n<h3 id=\"维基百科\"><a href=\"#维基百科\" class=\"headerlink\" title=\"维基百科\"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p>\n<p><strong>冒泡排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Bubble_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Bubble_sort</a></p>\n<p><strong>选择排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Selection_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Selection_sort</a></p>\n<p><strong>插入排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Insertion_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Insertion_sort</a></p>\n<p><strong>快速排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Quicksort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Quicksort</a></p>\n<p><strong>归并排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Merge_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Merge_sort</a></p>\n<p><strong>希尔排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Shellsort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Shellsort</a></p>\n<p><strong>计数排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Counting_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Counting_sort</a></p>\n<p><strong>基数排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Radix_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Radix_sort</a></p>\n<p><strong>桶排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Bucket_sort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Bucket_sort</a></p>\n<p><strong>堆排序</strong><br><a href=\"https://en.wikipedia.org/wiki/Heapsort\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Heapsort</a></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p>\n<p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {\n        return quickSort(nums);\n    }\n\n    // 冒泡排序（超时）\n    vector&lt;int&gt; bubbleSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = n-2; j &gt;= i; --j) {\n                if (nums[j] &gt; nums[j+1]) {\n                    swap(nums[j], nums[j+1]);\n                }\n            }\n        }\n        return nums;\n    }\n\n    // 选择排序（超时）\n    vector&lt;int&gt; selectSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        for (int i = 0; i &lt; n; ++i) {\n            int idx = i;\n            for (int j = i; j &lt; n; ++j) {\n                if (nums[j] &lt; nums[idx]) {\n                    idx = j;\n                }\n            }\n            swap(nums[i], nums[idx]);\n        }\n        return nums;\n    }\n\n    // 插入排序（超时）\n    vector&lt;int&gt; insertSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        for (int i = 0; i &lt; n; ++i) {\n            for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; --j) {\n                swap(nums[j], nums[j-1]);\n            }\n        }\n        return nums;\n    }\n\n    // 快速排序（24 ms）\n    void qSort(vector&lt;int&gt;&amp; nums, int l, int r) {\n        if (l &gt;= r) return;\n        int m = l;\n        for (int i = l; i &lt; r; ++i) {\n            if (nums[i] &lt; nums[r]) {\n                swap(nums[m++], nums[i]);\n            }\n        }\n        swap(nums[m], nums[r]);\n        qSort(nums, l, m-1);\n        qSort(nums, m+1, r);\n    }\n\n    vector&lt;int&gt; quickSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        qSort(nums, 0, n-1);\n        return nums;\n    }\n\n    // 归并排序（192 ms）\n    vector&lt;int&gt; mSort(vector&lt;int&gt;&amp; nums, int l, int r) {\n        if (l &gt;= r) return {nums[l]};\n        int m = l+(r-l)/2;\n        vector&lt;int&gt; lnums = mSort(nums, l, m);\n        vector&lt;int&gt; rnums = mSort(nums, m+1, r);\n        vector&lt;int&gt; res;\n        int i = 0, j = 0;\n        while (i &lt;= m-l &amp;&amp; j &lt;= r-m-1) {\n            if (lnums[i] &lt; rnums[j]) {\n                res.push_back(lnums[i++]);\n            } else {\n                res.push_back(rnums[j++]);\n            }\n        }\n        while (i &lt;= m-l) {\n            res.push_back(lnums[i++]);\n        }\n        while (j &lt;= r-m-1) {\n            res.push_back(rnums[j++]);\n        }\n        return res;\n    }\n\n    vector&lt;int&gt; mergeSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        nums = mSort(nums, 0, n-1);\n        return nums;\n    }\n\n    // 归并排序 + 非递归（80 ms）\n    vector&lt;int&gt; mergeSortNR(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        for (int len = 1; len &lt; n; len &lt;&lt;= 1) {\n            for (int l = 0; l &lt; n-len; l += 2*len) {\n                int m = l+len-1;\n                int r = min(n-1, l+2*len-1);\n                vector&lt;int&gt; res;\n                int i = l, j = m+1;\n                while (i &lt;= m &amp;&amp; j &lt;= r) {\n                    if (nums[i] &lt; nums[j]) {\n                        res.push_back(nums[i++]);\n                    } else {\n                        res.push_back(nums[j++]);\n                    }\n                }\n                while (i &lt;= m) {\n                    res.push_back(nums[i++]);\n                }\n                while (j &lt;= r) {\n                    res.push_back(nums[j++]);\n                }\n                for (int i = l; i &lt;= r; ++i) {\n                    nums[i] = res[i-l];\n                }\n            }\n        }\n        return nums;\n    }\n\n    // 希尔排序（40 ms）\n    vector&lt;int&gt; shellSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        for (int gap = n/2; gap &gt; 0; gap /= 2) {\n            for (int i = gap; i &lt; n; ++i) {\n                for (int j = i; j-gap &gt;= 0 &amp;&amp; nums[j-gap] &gt; nums[j]; j -= gap) {\n                    swap(nums[j-gap], nums[j]);\n                }\n            }\n        }\n        return nums;\n    }\n\n    // 计数排序（32 ms）\n    vector&lt;int&gt; countSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (!n) return {};\n        int minv = *min_element(nums.begin(), nums.end());\n        int maxv = *max_element(nums.begin(), nums.end());\n        int m = maxv-minv+1;\n        vector&lt;int&gt; count(m, 0);\n        for (int i = 0; i &lt; n; ++i) {\n            count[nums[i]-minv]++;\n        }\n        vector&lt;int&gt; res;\n        for (int i = 0; i &lt; m; ++i) {\n            for (int j = 0; j &lt; count[i]; ++j) {\n                res.push_back(i+minv);\n            }\n        }\n        return res;\n    }\n\n    // 基数排序（不适用于负数）\n    vector&lt;int&gt; radixSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        int maxv = *max_element(nums.begin(), nums.end());\n        int maxd = 0;\n        while (maxv &gt; 0) {\n            maxv /= 10;\n            maxd++;\n        }\n        vector&lt;int&gt; count(10, 0), rank(n, 0);\n        int base = 1;\n        while (maxd &gt; 0) {\n            count.assign(10, 0);\n            for (int i = 0; i &lt; n; ++i) {\n                count[(nums[i]/base)%10]++;\n            }\n            for (int i = 1; i &lt; 10; ++i) {\n                count[i] += count[i-1];\n            }\n            for (int i = n-1; i &gt;= 0; --i) {\n                rank[--count[(nums[i]/base)%10]] = nums[i];\n            }\n            for (int i = 0; i &lt; n; ++i) {\n                nums[i] = rank[i];\n            }\n            maxd--;\n            base *= 10;\n        }\n        return nums;\n    }\n\n    // 桶排序 (20 ms)\n    vector&lt;int&gt; bucketSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        int maxv = *max_element(nums.begin(), nums.end());\n        int minv = *min_element(nums.begin(), nums.end());\n        int bs = 1000;\n        int m = (maxv-minv)/bs+1;\n        vector&lt;vector&lt;int&gt; &gt; bucket(m);\n        for (int i = 0; i &lt; n; ++i) {\n            bucket[(nums[i]-minv)/bs].push_back(nums[i]);\n        }\n        int idx = 0;\n        for (int i = 0; i &lt; m; ++i) {\n            int sz = bucket[i].size();\n            bucket[i] = quickSort(bucket[i]);\n            for (int j = 0; j &lt; sz; ++j) {\n                nums[idx++] = bucket[i][j];\n            }\n        }\n        return nums;\n    }\n\n    // 堆排序（32 ms）\n    void adjust(vector&lt;int&gt;&amp; nums, int p, int s) {\n        while (2*p+1 &lt; s) {\n            int c1 = 2*p+1;\n            int c2 = 2*p+2;\n            int c = (c2&lt;s &amp;&amp; nums[c2]&gt;nums[c1]) ? c2 : c1;\n            if (nums[c] &gt; nums[p]) swap(nums[c], nums[p]);\n            else break;\n            p = c;\n        }\n    }\n\n    vector&lt;int&gt; heapSort(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        for (int i = n/2-1; i &gt;= 0; --i) {\n            adjust(nums, i, n);\n        }\n        for (int i = n-1; i &gt; 0; --i) {\n            swap(nums[0], nums[i]);\n            adjust(nums, 0, i);\n        }\n        return nums;\n    }\n};</code></pre>\n"},{"title":"事务","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-14T11:57:07.000Z","password":null,"summary":null,"_content":"\n## 事务\n\n事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。\n\n### ACID\n\n- atomicity（原子性） ：要么全执行，要么全都不执行；\n- consistency（一致性）：在事务开始和完成时，数据都必须保持一致状态；\n- isolation（隔离性） ：事务处理过程中的中间状态对外部是不可见的；\n- durability（持久性） ：事务完成之后，它对于数据的修改是永久性的。\n\nInnoDB 采用 redo log 机制来保证事务更新的一致性和持久性。\n\n## Redo log\n\nRedo log称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值。\n\nRedo log 由两部分组成：\n\n- 内存中的重做日志缓冲（redo log buffer）\n- 重做日志文件（redo log file）\n\n每次数据更新会先更新 redo log buffer，然后根据 innodb_flush_log_at_trx_commit 来控制 redo log buffer 更新到redo log file 的时机。innodb_flush_log_at_trx_commit 有三个值可选：\n\n- 0：事务提交时，在事务提交时，每秒触发一次 redo log buffer 写磁盘操作，并调用操作系统 fsync 刷新 IO 缓存。\n- 1：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，并调用操作系统 fsync 刷新 IO 缓存；\n- 2：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，但不是马上调用 fsync 刷新 IO 缓存，而是每秒只做一次磁盘 IO 缓存刷新操作。\n  innodb_flush_log_at_trx_commit 参数的默认值是 1，\n\n## Binlog\n\n二进制日志（binlog）记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句）\n\nBinlog 有以下几个作用：\n\n- 恢复：数据恢复时可以使用二进制日志\n- 复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步\n- 审计：可以通过二进制日志进行审计数据的变更操作\n\nsync_binlog 来控制累积多少个事务后才将二进制日志 fsync 到磁盘。\n\n- sync_binlog=0，表示每次提交事务都只write，不fsync\n- sync_binlog=1，表示每次提交事务都会执行fsync\n- sync_binlog=N(N>1)，表示每次提交事务都write，累积N个事务后才fsync\n\n## 数据库突然断电不丢数据\n\n只要 innodb_flush_log_at_trx_commit 和 sync_binlog 都为 1（通常称为：双一），就能确保MySQL 机器断电重启后，数据不丢失。","source":"_posts/事务.md","raw":"---\ntitle: 事务\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-14 19:57:07\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n## 事务\n\n事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。\n\n### ACID\n\n- atomicity（原子性） ：要么全执行，要么全都不执行；\n- consistency（一致性）：在事务开始和完成时，数据都必须保持一致状态；\n- isolation（隔离性） ：事务处理过程中的中间状态对外部是不可见的；\n- durability（持久性） ：事务完成之后，它对于数据的修改是永久性的。\n\nInnoDB 采用 redo log 机制来保证事务更新的一致性和持久性。\n\n## Redo log\n\nRedo log称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值。\n\nRedo log 由两部分组成：\n\n- 内存中的重做日志缓冲（redo log buffer）\n- 重做日志文件（redo log file）\n\n每次数据更新会先更新 redo log buffer，然后根据 innodb_flush_log_at_trx_commit 来控制 redo log buffer 更新到redo log file 的时机。innodb_flush_log_at_trx_commit 有三个值可选：\n\n- 0：事务提交时，在事务提交时，每秒触发一次 redo log buffer 写磁盘操作，并调用操作系统 fsync 刷新 IO 缓存。\n- 1：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，并调用操作系统 fsync 刷新 IO 缓存；\n- 2：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，但不是马上调用 fsync 刷新 IO 缓存，而是每秒只做一次磁盘 IO 缓存刷新操作。\n  innodb_flush_log_at_trx_commit 参数的默认值是 1，\n\n## Binlog\n\n二进制日志（binlog）记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句）\n\nBinlog 有以下几个作用：\n\n- 恢复：数据恢复时可以使用二进制日志\n- 复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步\n- 审计：可以通过二进制日志进行审计数据的变更操作\n\nsync_binlog 来控制累积多少个事务后才将二进制日志 fsync 到磁盘。\n\n- sync_binlog=0，表示每次提交事务都只write，不fsync\n- sync_binlog=1，表示每次提交事务都会执行fsync\n- sync_binlog=N(N>1)，表示每次提交事务都write，累积N个事务后才fsync\n\n## 数据库突然断电不丢数据\n\n只要 innodb_flush_log_at_trx_commit 和 sync_binlog 都为 1（通常称为：双一），就能确保MySQL 机器断电重启后，数据不丢失。","slug":"事务","published":1,"updated":"2021-03-14T12:07:02.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wb2002mi4ufozagmgiv","content":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p>\n<h3 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h3><ul>\n<li>atomicity（原子性） ：要么全执行，要么全都不执行；</li>\n<li>consistency（一致性）：在事务开始和完成时，数据都必须保持一致状态；</li>\n<li>isolation（隔离性） ：事务处理过程中的中间状态对外部是不可见的；</li>\n<li>durability（持久性） ：事务完成之后，它对于数据的修改是永久性的。</li>\n</ul>\n<p>InnoDB 采用 redo log 机制来保证事务更新的一致性和持久性。</p>\n<h2 id=\"Redo-log\"><a href=\"#Redo-log\" class=\"headerlink\" title=\"Redo log\"></a>Redo log</h2><p>Redo log称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值。</p>\n<p>Redo log 由两部分组成：</p>\n<ul>\n<li>内存中的重做日志缓冲（redo log buffer）</li>\n<li>重做日志文件（redo log file）</li>\n</ul>\n<p>每次数据更新会先更新 redo log buffer，然后根据 innodb_flush_log_at_trx_commit 来控制 redo log buffer 更新到redo log file 的时机。innodb_flush_log_at_trx_commit 有三个值可选：</p>\n<ul>\n<li>0：事务提交时，在事务提交时，每秒触发一次 redo log buffer 写磁盘操作，并调用操作系统 fsync 刷新 IO 缓存。</li>\n<li>1：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，并调用操作系统 fsync 刷新 IO 缓存；</li>\n<li>2：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，但不是马上调用 fsync 刷新 IO 缓存，而是每秒只做一次磁盘 IO 缓存刷新操作。<br>innodb_flush_log_at_trx_commit 参数的默认值是 1，</li>\n</ul>\n<h2 id=\"Binlog\"><a href=\"#Binlog\" class=\"headerlink\" title=\"Binlog\"></a>Binlog</h2><p>二进制日志（binlog）记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句）</p>\n<p>Binlog 有以下几个作用：</p>\n<ul>\n<li>恢复：数据恢复时可以使用二进制日志</li>\n<li>复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步</li>\n<li>审计：可以通过二进制日志进行审计数据的变更操作</li>\n</ul>\n<p>sync_binlog 来控制累积多少个事务后才将二进制日志 fsync 到磁盘。</p>\n<ul>\n<li>sync_binlog=0，表示每次提交事务都只write，不fsync</li>\n<li>sync_binlog=1，表示每次提交事务都会执行fsync</li>\n<li>sync_binlog=N(N&gt;1)，表示每次提交事务都write，累积N个事务后才fsync</li>\n</ul>\n<h2 id=\"数据库突然断电不丢数据\"><a href=\"#数据库突然断电不丢数据\" class=\"headerlink\" title=\"数据库突然断电不丢数据\"></a>数据库突然断电不丢数据</h2><p>只要 innodb_flush_log_at_trx_commit 和 sync_binlog 都为 1（通常称为：双一），就能确保MySQL 机器断电重启后，数据不丢失。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p>\n<h3 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID\"></a>ACID</h3><ul>\n<li>atomicity（原子性） ：要么全执行，要么全都不执行；</li>\n<li>consistency（一致性）：在事务开始和完成时，数据都必须保持一致状态；</li>\n<li>isolation（隔离性） ：事务处理过程中的中间状态对外部是不可见的；</li>\n<li>durability（持久性） ：事务完成之后，它对于数据的修改是永久性的。</li>\n</ul>\n<p>InnoDB 采用 redo log 机制来保证事务更新的一致性和持久性。</p>\n<h2 id=\"Redo-log\"><a href=\"#Redo-log\" class=\"headerlink\" title=\"Redo log\"></a>Redo log</h2><p>Redo log称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值。</p>\n<p>Redo log 由两部分组成：</p>\n<ul>\n<li>内存中的重做日志缓冲（redo log buffer）</li>\n<li>重做日志文件（redo log file）</li>\n</ul>\n<p>每次数据更新会先更新 redo log buffer，然后根据 innodb_flush_log_at_trx_commit 来控制 redo log buffer 更新到redo log file 的时机。innodb_flush_log_at_trx_commit 有三个值可选：</p>\n<ul>\n<li>0：事务提交时，在事务提交时，每秒触发一次 redo log buffer 写磁盘操作，并调用操作系统 fsync 刷新 IO 缓存。</li>\n<li>1：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，并调用操作系统 fsync 刷新 IO 缓存；</li>\n<li>2：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，但不是马上调用 fsync 刷新 IO 缓存，而是每秒只做一次磁盘 IO 缓存刷新操作。<br>innodb_flush_log_at_trx_commit 参数的默认值是 1，</li>\n</ul>\n<h2 id=\"Binlog\"><a href=\"#Binlog\" class=\"headerlink\" title=\"Binlog\"></a>Binlog</h2><p>二进制日志（binlog）记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句）</p>\n<p>Binlog 有以下几个作用：</p>\n<ul>\n<li>恢复：数据恢复时可以使用二进制日志</li>\n<li>复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步</li>\n<li>审计：可以通过二进制日志进行审计数据的变更操作</li>\n</ul>\n<p>sync_binlog 来控制累积多少个事务后才将二进制日志 fsync 到磁盘。</p>\n<ul>\n<li>sync_binlog=0，表示每次提交事务都只write，不fsync</li>\n<li>sync_binlog=1，表示每次提交事务都会执行fsync</li>\n<li>sync_binlog=N(N&gt;1)，表示每次提交事务都write，累积N个事务后才fsync</li>\n</ul>\n<h2 id=\"数据库突然断电不丢数据\"><a href=\"#数据库突然断电不丢数据\" class=\"headerlink\" title=\"数据库突然断电不丢数据\"></a>数据库突然断电不丢数据</h2><p>只要 innodb_flush_log_at_trx_commit 和 sync_binlog 都为 1（通常称为：双一），就能确保MySQL 机器断电重启后，数据不丢失。</p>\n"},{"title":"分页查询优化","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-13T09:15:47.000Z","password":null,"summary":null,"_content":"\n## 自增且连续主键的分页查询\n\n避免前n条记录的读取[mysql manual][https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html]，可以采用：\n\n```mysql\nselect * from t1 where id >99000 limit 2;\n```\n\n要求主链连续且自增，否则很多时候不适用。\n\n## 非主键字段排序的分页查询\n\n可能不走索引\n\n```mysql\nselect * from t1 order by a limit 99000,2;\n```\n\n优化：关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录\n\n```mysql\nselect * from t1 f inner join (select id from t1 order by a limit 99000,2)g on f.id = g.id;\n```\n\n","source":"_posts/分页查询优化.md","raw":"---\ntitle: 分页查询优化\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-13 17:15:47\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n## 自增且连续主键的分页查询\n\n避免前n条记录的读取[mysql manual][https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html]，可以采用：\n\n```mysql\nselect * from t1 where id >99000 limit 2;\n```\n\n要求主链连续且自增，否则很多时候不适用。\n\n## 非主键字段排序的分页查询\n\n可能不走索引\n\n```mysql\nselect * from t1 order by a limit 99000,2;\n```\n\n优化：关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录\n\n```mysql\nselect * from t1 f inner join (select id from t1 order by a limit 99000,2)g on f.id = g.id;\n```\n\n","slug":"分页查询优化","published":1,"updated":"2021-03-13T09:32:42.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wb9002ri4ufibnzjd7a","content":"<h2 id=\"自增且连续主键的分页查询\"><a href=\"#自增且连续主键的分页查询\" class=\"headerlink\" title=\"自增且连续主键的分页查询\"></a>自增且连续主键的分页查询</h2><p>避免前n条记录的读取[mysql manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html]，可以采用：\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html]，可以采用：</a></p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select * from t1 where id >99000 limit 2;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>要求主链连续且自增，否则很多时候不适用。</p>\n<h2 id=\"非主键字段排序的分页查询\"><a href=\"#非主键字段排序的分页查询\" class=\"headerlink\" title=\"非主键字段排序的分页查询\"></a>非主键字段排序的分页查询</h2><p>可能不走索引</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select * from t1 order by a limit 99000,2;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>优化：关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select * from t1 f inner join (select id from t1 order by a limit 99000,2)g on f.id = g.id;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"自增且连续主键的分页查询\"><a href=\"#自增且连续主键的分页查询\" class=\"headerlink\" title=\"自增且连续主键的分页查询\"></a>自增且连续主键的分页查询</h2><p>避免前n条记录的读取[mysql manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html]，可以采用：\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html]，可以采用：</a></p>\n<pre><code class=\"mysql\">select * from t1 where id &gt;99000 limit 2;</code></pre>\n<p>要求主链连续且自增，否则很多时候不适用。</p>\n<h2 id=\"非主键字段排序的分页查询\"><a href=\"#非主键字段排序的分页查询\" class=\"headerlink\" title=\"非主键字段排序的分页查询\"></a>非主键字段排序的分页查询</h2><p>可能不走索引</p>\n<pre><code class=\"mysql\">select * from t1 order by a limit 99000,2;</code></pre>\n<p>优化：关键是让排序时返回的字段尽可能少，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录</p>\n<pre><code class=\"mysql\">select * from t1 f inner join (select id from t1 order by a limit 99000,2)g on f.id = g.id;</code></pre>\n"},{"title":"基于多CPU多核架构的redis性能优化","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2020-10-26T13:40:55.000Z","password":null,"summary":null,"_content":"\n## CPU架构\n\n- 一个 CPU 处理器中一般有多个物理核。\n- 每个物理核都拥有私有的一级缓存（ L1 cache）和私有的二级缓存（L2 cache）。\n- 不同的物理核还会共享一个共同的三级缓存\n- 每个物理核通常都会运行两个超线程，也叫作逻辑核。同一个物理核的逻辑核会共享使用 L1、L2 缓存\n- 不同处理器间通过总线连接\n\n## 问题\n\n1、多CPU：如果应用程序先在一个 Socket（CPU处理器） 上运行，并且把数据保存到了内存，然后被调度到另一个 Socket 上运行，此时，应用程序再进行内存访问时，就需要访问之前 Socket 上连接的内存，这种访问属于远端内存访问。和访问 Socket 直接连接的内存相比，远端内存访问会增加应用程序的延迟。（NUMA）\n\n2、多核：Redis 主线程的运行时信息需要被重新加载到另一个 CPU 物理核上，而且，此时，另一个 CPU 物理核上的 L1、L2 缓存中并没有 Redis 实例之前运行时频繁访问的指令和数据，所以，这些指令和数据都需要重新从 L3 缓存，甚至是内存中加载。\n\n3、Redis 实例和网络中断程序的数据交互：网络中断处理程序从网卡硬件中读取数据，并把数据写入到操作系统内核维护的一块内存缓冲区。内核会通过 epoll 机制触发事件，通知 Redis 实例，Redis 实例再把数据从内核的内存缓冲区拷贝到自己的内存空间。可能存在跨CPU拷贝内存数据。\n\n## 优化\n\n1、把 Redis 实例和 CPU 物理核绑定了，让一个 Redis 实例固定运行在一个 CPU 物理核上\n2、把操作系统的网络中断处理程序和 CPU 物理核绑定。Redis 实例绑定在同一个物理核上。\n3、使用源码优化方案，既可以实现 Redis 实例绑核，避免切换核带来的性能影响，还可以让子进程、后台线程和主线程不在同一个核上运行，避免了它们之间的 CPU 资源竞争。\n\n注：NUMA架构下，先给每个 CPU Socket 中每个物理核的第一个逻辑核依次编号，再给每个 CPU Socket 中的物理核的第二个逻辑核依次编号。","source":"_posts/基于多CPU多核架构的redis性能优化.md","raw":"---\ntitle: 基于多CPU多核架构的redis性能优化\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2020-10-26 21:40:55\npassword:\nsummary:\ntags:\n- redis\ncategories:\n- redis\n---\n\n## CPU架构\n\n- 一个 CPU 处理器中一般有多个物理核。\n- 每个物理核都拥有私有的一级缓存（ L1 cache）和私有的二级缓存（L2 cache）。\n- 不同的物理核还会共享一个共同的三级缓存\n- 每个物理核通常都会运行两个超线程，也叫作逻辑核。同一个物理核的逻辑核会共享使用 L1、L2 缓存\n- 不同处理器间通过总线连接\n\n## 问题\n\n1、多CPU：如果应用程序先在一个 Socket（CPU处理器） 上运行，并且把数据保存到了内存，然后被调度到另一个 Socket 上运行，此时，应用程序再进行内存访问时，就需要访问之前 Socket 上连接的内存，这种访问属于远端内存访问。和访问 Socket 直接连接的内存相比，远端内存访问会增加应用程序的延迟。（NUMA）\n\n2、多核：Redis 主线程的运行时信息需要被重新加载到另一个 CPU 物理核上，而且，此时，另一个 CPU 物理核上的 L1、L2 缓存中并没有 Redis 实例之前运行时频繁访问的指令和数据，所以，这些指令和数据都需要重新从 L3 缓存，甚至是内存中加载。\n\n3、Redis 实例和网络中断程序的数据交互：网络中断处理程序从网卡硬件中读取数据，并把数据写入到操作系统内核维护的一块内存缓冲区。内核会通过 epoll 机制触发事件，通知 Redis 实例，Redis 实例再把数据从内核的内存缓冲区拷贝到自己的内存空间。可能存在跨CPU拷贝内存数据。\n\n## 优化\n\n1、把 Redis 实例和 CPU 物理核绑定了，让一个 Redis 实例固定运行在一个 CPU 物理核上\n2、把操作系统的网络中断处理程序和 CPU 物理核绑定。Redis 实例绑定在同一个物理核上。\n3、使用源码优化方案，既可以实现 Redis 实例绑核，避免切换核带来的性能影响，还可以让子进程、后台线程和主线程不在同一个核上运行，避免了它们之间的 CPU 资源竞争。\n\n注：NUMA架构下，先给每个 CPU Socket 中每个物理核的第一个逻辑核依次编号，再给每个 CPU Socket 中的物理核的第二个逻辑核依次编号。","slug":"基于多CPU多核架构的redis性能优化","published":1,"updated":"2020-10-26T13:41:25.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wbc002ui4ufdunjffwp","content":"<h2 id=\"CPU架构\"><a href=\"#CPU架构\" class=\"headerlink\" title=\"CPU架构\"></a>CPU架构</h2><ul>\n<li>一个 CPU 处理器中一般有多个物理核。</li>\n<li>每个物理核都拥有私有的一级缓存（ L1 cache）和私有的二级缓存（L2 cache）。</li>\n<li>不同的物理核还会共享一个共同的三级缓存</li>\n<li>每个物理核通常都会运行两个超线程，也叫作逻辑核。同一个物理核的逻辑核会共享使用 L1、L2 缓存</li>\n<li>不同处理器间通过总线连接</li>\n</ul>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>1、多CPU：如果应用程序先在一个 Socket（CPU处理器） 上运行，并且把数据保存到了内存，然后被调度到另一个 Socket 上运行，此时，应用程序再进行内存访问时，就需要访问之前 Socket 上连接的内存，这种访问属于远端内存访问。和访问 Socket 直接连接的内存相比，远端内存访问会增加应用程序的延迟。（NUMA）</p>\n<p>2、多核：Redis 主线程的运行时信息需要被重新加载到另一个 CPU 物理核上，而且，此时，另一个 CPU 物理核上的 L1、L2 缓存中并没有 Redis 实例之前运行时频繁访问的指令和数据，所以，这些指令和数据都需要重新从 L3 缓存，甚至是内存中加载。</p>\n<p>3、Redis 实例和网络中断程序的数据交互：网络中断处理程序从网卡硬件中读取数据，并把数据写入到操作系统内核维护的一块内存缓冲区。内核会通过 epoll 机制触发事件，通知 Redis 实例，Redis 实例再把数据从内核的内存缓冲区拷贝到自己的内存空间。可能存在跨CPU拷贝内存数据。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>1、把 Redis 实例和 CPU 物理核绑定了，让一个 Redis 实例固定运行在一个 CPU 物理核上<br>2、把操作系统的网络中断处理程序和 CPU 物理核绑定。Redis 实例绑定在同一个物理核上。<br>3、使用源码优化方案，既可以实现 Redis 实例绑核，避免切换核带来的性能影响，还可以让子进程、后台线程和主线程不在同一个核上运行，避免了它们之间的 CPU 资源竞争。</p>\n<p>注：NUMA架构下，先给每个 CPU Socket 中每个物理核的第一个逻辑核依次编号，再给每个 CPU Socket 中的物理核的第二个逻辑核依次编号。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"CPU架构\"><a href=\"#CPU架构\" class=\"headerlink\" title=\"CPU架构\"></a>CPU架构</h2><ul>\n<li>一个 CPU 处理器中一般有多个物理核。</li>\n<li>每个物理核都拥有私有的一级缓存（ L1 cache）和私有的二级缓存（L2 cache）。</li>\n<li>不同的物理核还会共享一个共同的三级缓存</li>\n<li>每个物理核通常都会运行两个超线程，也叫作逻辑核。同一个物理核的逻辑核会共享使用 L1、L2 缓存</li>\n<li>不同处理器间通过总线连接</li>\n</ul>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>1、多CPU：如果应用程序先在一个 Socket（CPU处理器） 上运行，并且把数据保存到了内存，然后被调度到另一个 Socket 上运行，此时，应用程序再进行内存访问时，就需要访问之前 Socket 上连接的内存，这种访问属于远端内存访问。和访问 Socket 直接连接的内存相比，远端内存访问会增加应用程序的延迟。（NUMA）</p>\n<p>2、多核：Redis 主线程的运行时信息需要被重新加载到另一个 CPU 物理核上，而且，此时，另一个 CPU 物理核上的 L1、L2 缓存中并没有 Redis 实例之前运行时频繁访问的指令和数据，所以，这些指令和数据都需要重新从 L3 缓存，甚至是内存中加载。</p>\n<p>3、Redis 实例和网络中断程序的数据交互：网络中断处理程序从网卡硬件中读取数据，并把数据写入到操作系统内核维护的一块内存缓冲区。内核会通过 epoll 机制触发事件，通知 Redis 实例，Redis 实例再把数据从内核的内存缓冲区拷贝到自己的内存空间。可能存在跨CPU拷贝内存数据。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>1、把 Redis 实例和 CPU 物理核绑定了，让一个 Redis 实例固定运行在一个 CPU 物理核上<br>2、把操作系统的网络中断处理程序和 CPU 物理核绑定。Redis 实例绑定在同一个物理核上。<br>3、使用源码优化方案，既可以实现 Redis 实例绑核，避免切换核带来的性能影响，还可以让子进程、后台线程和主线程不在同一个核上运行，避免了它们之间的 CPU 资源竞争。</p>\n<p>注：NUMA架构下，先给每个 CPU Socket 中每个物理核的第一个逻辑核依次编号，再给每个 CPU Socket 中的物理核的第二个逻辑核依次编号。</p>\n"},{"title":"慢查询定位与分析","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-11T13:58:12.000Z","password":null,"summary":null,"_content":"\n## 定位慢sql\n\n1、查看慢查询日志确定已经执行完的慢查询\n\n```mysql\nmysql> set global slow_query_log = on;\nmysql> set global long_query_time = 1;\nmysql> show global variables like \"datadir\";\nmysql> show global variables like \"slow_query_log_file\";\n\n[root@mysqltest ~]# tail -n5 /data/mysql/data/3306/mysql-slow.log\nTime: 2019-05-21T09:15:06.255554+08:00\nUser@Host: root[root] @ localhost [] Id: 8591152\nQuery_time: 10.000260 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0\nSET timestamp=1558401306;\nselect sleep(10);\n```\n\n可以看到查询时间、表锁时间。\n\n2、show processlist 查看正在执行的慢查询\n\n```mysql\nmysql> show processlist\\G`\n\n`*************************** 10. row ***************************`\n`Id: 7651833`\n`User: one`\n`Host: 192.168.1.251:52154`\n`db: ops`\n`Command: Query`\n`Time: 3`\n`State: User sleep`\n`Info: select sleep(10)`\n`......`\n`10 rows in set (0.00 sec)`\n```\n\n可以看到执行时间和SQL语句\n\n## 分析慢查询\n\n1、使用 explain 分析慢查询\n\n获取 MySQL 中 SQL 语句的执行计划.需要重点关注以下：\n\n- select_type 查询类型：显示本行是简单还是复杂查询\n\n- type 本次查询的表连接类型\n\n- key 实际选择的索引\n\n- rows 预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确\n\n- Extra 附加信息\n\n其中\n\n| select_type          | 含义                                                        |\n| :------------------- | ----------------------------------------------------------- |\n| SIMPLE               | 简单查询(不使用关联查询或子查询)                            |\n| PRIMARY              | 如果包含关联查询或者子查询，则最外层的查询部分标记为primary |\n| UNION                | 联合查询中第二个及后面的查询                                |\n| DEPENDENT UNION      | 满足依赖外部的关联查询中第二个及以后的查询                  |\n| UNION RESULT         | 联合查询的结果                                              |\n| SUBQUERY             | 子查询中的第一个查询                                        |\n| DEPENDENT SUBQUERY   | 子查询中的第一个查询，并且依赖外部查询                      |\n| DERIVED              | 用到派生表的查询                                            |\n| MATERIALIZED         | 被物化的子查询                                              |\n| UNCACHEABLE SUBQUERY | 一个子查询的结果不能被缓存，必须重新评估外层查询的每一行    |\n| UNCACHEABLE UNION    | 关联查询第二个或后面的语句属于不可缓存的子查询              |\n\n| type            | 含义                                     |\n| :-------------- | :--------------------------------------- |\n| system          | 查询对象表只有一行数据,且只能用于        |\n| const           | 基于主键或唯一索引查询，最多返回一条结果 |\n| eq_ref          | 表连接时基于主键或非                     |\n| ref             | 基于普通索引的等值查询，或者表间等值连接 |\n| fulltext        | 全文检索                                 |\n| ref_or_null     | 表连接类型是                             |\n| index_merge     | 利用多个索引                             |\n| unique_subquery | 子查询中使用唯一索引                     |\n| index_subquery  | 子查询中使用普通索引                     |\n| range           | 利用索引进行范围查询                     |\n| index           | 全索引扫描                               |\n| ALL             | 全表扫描                                 |\n\n| Extra                                | 解释                                                         |\n| :----------------------------------- | :----------------------------------------------------------- |\n| Using filesort                       | 将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序 |\n| Using temporary                      | 需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时 |\n| Using index                          | 使用覆盖索引                                                 |\n| Using where                          | 使用 where 语句来处理结果                                    |\n| Impossible WHERE                     | 对 where 子句判断的结果总是 false 而不能选择任何数据         |\n| Using join buffer (BlockNested Loop) | 关联查询中，被驱动表的关联字段没索引                         |\n| Using index condition                | 先条件过滤索引，再查数据                                     |\n| Select tables optimized away         | 使用某些聚合函数（比如 max、min）来访问存在索引的某个字段    |\n\n2、show profile\n\n了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节\n\n```mysql\nmysql> select @@have_profiling;\nmysql> select @@profiling;\nmysql> set profiling=1;\nmysql> select * from t1 where b=1000;\nmysql> show profiles;  /*获取query id*/\nmysql> show profile for query 1;\n\n+----------------------+----------+\n| Status | Duration |\n+----------------------+----------+\n| starting | 0.000115 |\n| checking permissions | 0.000013 |\n| Opening tables | 0.000027 |\n| init | 0.000035 |\n| System lock | 0.000017 |\n| optimizing | 0.000016 |\n| statistics | 0.000025 |\n| preparing | 0.000020 |\n| executing | 0.000006 |\n| Sending data | 0.000294 |\n| end | 0.000009 |\n| query end | 0.000012 |\n| closing tables | 0.000011 |\n| freeing items | 0.000024 |\n| cleaning up | 0.000016 |\n+----------------------+----------+\n15 rows in set, 1 warning (0.00 sec)\n```\n\n3、trace\n\n使用 trace 查看优化器如何选择执行计划\n\n```mysql\nmysql> set session optimizer_trace=\"enabled=on\",end_markers_in_json=on;\n/* optimizer_trace=\"enabled=on\" 表示开启 trace；end_markers_in_json=on 表示 JSON 输出开启结束标记 */\nmysql> select * from t1 where a >900 and b > 910 order by a;\nmysql> SELECT * FROM information_schema.OPTIMIZER_TRACE\\G;\n\n```\n\nTRACE包括准备阶段、优化阶段、执行阶段。trace中可以看到使用每个索引的成本。\n\n","source":"_posts/慢查询定位与分析.md","raw":"---\ntitle: 慢查询定位与分析\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-11 21:58:12\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n## 定位慢sql\n\n1、查看慢查询日志确定已经执行完的慢查询\n\n```mysql\nmysql> set global slow_query_log = on;\nmysql> set global long_query_time = 1;\nmysql> show global variables like \"datadir\";\nmysql> show global variables like \"slow_query_log_file\";\n\n[root@mysqltest ~]# tail -n5 /data/mysql/data/3306/mysql-slow.log\nTime: 2019-05-21T09:15:06.255554+08:00\nUser@Host: root[root] @ localhost [] Id: 8591152\nQuery_time: 10.000260 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0\nSET timestamp=1558401306;\nselect sleep(10);\n```\n\n可以看到查询时间、表锁时间。\n\n2、show processlist 查看正在执行的慢查询\n\n```mysql\nmysql> show processlist\\G`\n\n`*************************** 10. row ***************************`\n`Id: 7651833`\n`User: one`\n`Host: 192.168.1.251:52154`\n`db: ops`\n`Command: Query`\n`Time: 3`\n`State: User sleep`\n`Info: select sleep(10)`\n`......`\n`10 rows in set (0.00 sec)`\n```\n\n可以看到执行时间和SQL语句\n\n## 分析慢查询\n\n1、使用 explain 分析慢查询\n\n获取 MySQL 中 SQL 语句的执行计划.需要重点关注以下：\n\n- select_type 查询类型：显示本行是简单还是复杂查询\n\n- type 本次查询的表连接类型\n\n- key 实际选择的索引\n\n- rows 预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确\n\n- Extra 附加信息\n\n其中\n\n| select_type          | 含义                                                        |\n| :------------------- | ----------------------------------------------------------- |\n| SIMPLE               | 简单查询(不使用关联查询或子查询)                            |\n| PRIMARY              | 如果包含关联查询或者子查询，则最外层的查询部分标记为primary |\n| UNION                | 联合查询中第二个及后面的查询                                |\n| DEPENDENT UNION      | 满足依赖外部的关联查询中第二个及以后的查询                  |\n| UNION RESULT         | 联合查询的结果                                              |\n| SUBQUERY             | 子查询中的第一个查询                                        |\n| DEPENDENT SUBQUERY   | 子查询中的第一个查询，并且依赖外部查询                      |\n| DERIVED              | 用到派生表的查询                                            |\n| MATERIALIZED         | 被物化的子查询                                              |\n| UNCACHEABLE SUBQUERY | 一个子查询的结果不能被缓存，必须重新评估外层查询的每一行    |\n| UNCACHEABLE UNION    | 关联查询第二个或后面的语句属于不可缓存的子查询              |\n\n| type            | 含义                                     |\n| :-------------- | :--------------------------------------- |\n| system          | 查询对象表只有一行数据,且只能用于        |\n| const           | 基于主键或唯一索引查询，最多返回一条结果 |\n| eq_ref          | 表连接时基于主键或非                     |\n| ref             | 基于普通索引的等值查询，或者表间等值连接 |\n| fulltext        | 全文检索                                 |\n| ref_or_null     | 表连接类型是                             |\n| index_merge     | 利用多个索引                             |\n| unique_subquery | 子查询中使用唯一索引                     |\n| index_subquery  | 子查询中使用普通索引                     |\n| range           | 利用索引进行范围查询                     |\n| index           | 全索引扫描                               |\n| ALL             | 全表扫描                                 |\n\n| Extra                                | 解释                                                         |\n| :----------------------------------- | :----------------------------------------------------------- |\n| Using filesort                       | 将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序 |\n| Using temporary                      | 需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时 |\n| Using index                          | 使用覆盖索引                                                 |\n| Using where                          | 使用 where 语句来处理结果                                    |\n| Impossible WHERE                     | 对 where 子句判断的结果总是 false 而不能选择任何数据         |\n| Using join buffer (BlockNested Loop) | 关联查询中，被驱动表的关联字段没索引                         |\n| Using index condition                | 先条件过滤索引，再查数据                                     |\n| Select tables optimized away         | 使用某些聚合函数（比如 max、min）来访问存在索引的某个字段    |\n\n2、show profile\n\n了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节\n\n```mysql\nmysql> select @@have_profiling;\nmysql> select @@profiling;\nmysql> set profiling=1;\nmysql> select * from t1 where b=1000;\nmysql> show profiles;  /*获取query id*/\nmysql> show profile for query 1;\n\n+----------------------+----------+\n| Status | Duration |\n+----------------------+----------+\n| starting | 0.000115 |\n| checking permissions | 0.000013 |\n| Opening tables | 0.000027 |\n| init | 0.000035 |\n| System lock | 0.000017 |\n| optimizing | 0.000016 |\n| statistics | 0.000025 |\n| preparing | 0.000020 |\n| executing | 0.000006 |\n| Sending data | 0.000294 |\n| end | 0.000009 |\n| query end | 0.000012 |\n| closing tables | 0.000011 |\n| freeing items | 0.000024 |\n| cleaning up | 0.000016 |\n+----------------------+----------+\n15 rows in set, 1 warning (0.00 sec)\n```\n\n3、trace\n\n使用 trace 查看优化器如何选择执行计划\n\n```mysql\nmysql> set session optimizer_trace=\"enabled=on\",end_markers_in_json=on;\n/* optimizer_trace=\"enabled=on\" 表示开启 trace；end_markers_in_json=on 表示 JSON 输出开启结束标记 */\nmysql> select * from t1 where a >900 and b > 910 order by a;\nmysql> SELECT * FROM information_schema.OPTIMIZER_TRACE\\G;\n\n```\n\nTRACE包括准备阶段、优化阶段、执行阶段。trace中可以看到使用每个索引的成本。\n\n","slug":"慢查询定位与分析","published":1,"updated":"2021-03-11T14:00:35.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wbf002zi4ufjgoi7d2f","content":"<h2 id=\"定位慢sql\"><a href=\"#定位慢sql\" class=\"headerlink\" title=\"定位慢sql\"></a>定位慢sql</h2><p>1、查看慢查询日志确定已经执行完的慢查询</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">mysql> set global slow_query_log = on;\nmysql> set global long_query_time = 1;\nmysql> show global variables like \"datadir\";\nmysql> show global variables like \"slow_query_log_file\";\n\n[root@mysqltest ~]# tail -n5 /data/mysql/data/3306/mysql-slow.log\nTime: 2019-05-21T09:15:06.255554+08:00\nUser@Host: root[root] @ localhost [] Id: 8591152\nQuery_time: 10.000260 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0\nSET timestamp=1558401306;\nselect sleep(10);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以看到查询时间、表锁时间。</p>\n<p>2、show processlist 查看正在执行的慢查询</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">mysql> show processlist\\G`\n\n`*************************** 10. row ***************************`\n`Id: 7651833`\n`User: one`\n`Host: 192.168.1.251:52154`\n`db: ops`\n`Command: Query`\n`Time: 3`\n`State: User sleep`\n`Info: select sleep(10)`\n`......`\n`10 rows in set (0.00 sec)`<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以看到执行时间和SQL语句</p>\n<h2 id=\"分析慢查询\"><a href=\"#分析慢查询\" class=\"headerlink\" title=\"分析慢查询\"></a>分析慢查询</h2><p>1、使用 explain 分析慢查询</p>\n<p>获取 MySQL 中 SQL 语句的执行计划.需要重点关注以下：</p>\n<ul>\n<li><p>select_type 查询类型：显示本行是简单还是复杂查询</p>\n</li>\n<li><p>type 本次查询的表连接类型</p>\n</li>\n<li><p>key 实际选择的索引</p>\n</li>\n<li><p>rows 预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</p>\n</li>\n<li><p>Extra 附加信息</p>\n</li>\n</ul>\n<p>其中</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">select_type</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">SIMPLE</td>\n<td>简单查询(不使用关联查询或子查询)</td>\n</tr>\n<tr>\n<td align=\"left\">PRIMARY</td>\n<td>如果包含关联查询或者子查询，则最外层的查询部分标记为primary</td>\n</tr>\n<tr>\n<td align=\"left\">UNION</td>\n<td>联合查询中第二个及后面的查询</td>\n</tr>\n<tr>\n<td align=\"left\">DEPENDENT UNION</td>\n<td>满足依赖外部的关联查询中第二个及以后的查询</td>\n</tr>\n<tr>\n<td align=\"left\">UNION RESULT</td>\n<td>联合查询的结果</td>\n</tr>\n<tr>\n<td align=\"left\">SUBQUERY</td>\n<td>子查询中的第一个查询</td>\n</tr>\n<tr>\n<td align=\"left\">DEPENDENT SUBQUERY</td>\n<td>子查询中的第一个查询，并且依赖外部查询</td>\n</tr>\n<tr>\n<td align=\"left\">DERIVED</td>\n<td>用到派生表的查询</td>\n</tr>\n<tr>\n<td align=\"left\">MATERIALIZED</td>\n<td>被物化的子查询</td>\n</tr>\n<tr>\n<td align=\"left\">UNCACHEABLE SUBQUERY</td>\n<td>一个子查询的结果不能被缓存，必须重新评估外层查询的每一行</td>\n</tr>\n<tr>\n<td align=\"left\">UNCACHEABLE UNION</td>\n<td>关联查询第二个或后面的语句属于不可缓存的子查询</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">type</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">system</td>\n<td align=\"left\">查询对象表只有一行数据,且只能用于</td>\n</tr>\n<tr>\n<td align=\"left\">const</td>\n<td align=\"left\">基于主键或唯一索引查询，最多返回一条结果</td>\n</tr>\n<tr>\n<td align=\"left\">eq_ref</td>\n<td align=\"left\">表连接时基于主键或非</td>\n</tr>\n<tr>\n<td align=\"left\">ref</td>\n<td align=\"left\">基于普通索引的等值查询，或者表间等值连接</td>\n</tr>\n<tr>\n<td align=\"left\">fulltext</td>\n<td align=\"left\">全文检索</td>\n</tr>\n<tr>\n<td align=\"left\">ref_or_null</td>\n<td align=\"left\">表连接类型是</td>\n</tr>\n<tr>\n<td align=\"left\">index_merge</td>\n<td align=\"left\">利用多个索引</td>\n</tr>\n<tr>\n<td align=\"left\">unique_subquery</td>\n<td align=\"left\">子查询中使用唯一索引</td>\n</tr>\n<tr>\n<td align=\"left\">index_subquery</td>\n<td align=\"left\">子查询中使用普通索引</td>\n</tr>\n<tr>\n<td align=\"left\">range</td>\n<td align=\"left\">利用索引进行范围查询</td>\n</tr>\n<tr>\n<td align=\"left\">index</td>\n<td align=\"left\">全索引扫描</td>\n</tr>\n<tr>\n<td align=\"left\">ALL</td>\n<td align=\"left\">全表扫描</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Extra</th>\n<th align=\"left\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Using filesort</td>\n<td align=\"left\">将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td>\n</tr>\n<tr>\n<td align=\"left\">Using temporary</td>\n<td align=\"left\">需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td>\n</tr>\n<tr>\n<td align=\"left\">Using index</td>\n<td align=\"left\">使用覆盖索引</td>\n</tr>\n<tr>\n<td align=\"left\">Using where</td>\n<td align=\"left\">使用 where 语句来处理结果</td>\n</tr>\n<tr>\n<td align=\"left\">Impossible WHERE</td>\n<td align=\"left\">对 where 子句判断的结果总是 false 而不能选择任何数据</td>\n</tr>\n<tr>\n<td align=\"left\">Using join buffer (BlockNested Loop)</td>\n<td align=\"left\">关联查询中，被驱动表的关联字段没索引</td>\n</tr>\n<tr>\n<td align=\"left\">Using index condition</td>\n<td align=\"left\">先条件过滤索引，再查数据</td>\n</tr>\n<tr>\n<td align=\"left\">Select tables optimized away</td>\n<td align=\"left\">使用某些聚合函数（比如 max、min）来访问存在索引的某个字段</td>\n</tr>\n</tbody></table>\n<p>2、show profile</p>\n<p>了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">mysql> select @@have_profiling;\nmysql> select @@profiling;\nmysql> set profiling=1;\nmysql> select * from t1 where b=1000;\nmysql> show profiles;  /*获取query id*/\nmysql> show profile for query 1;\n\n+----------------------+----------+\n| Status | Duration |\n+----------------------+----------+\n| starting | 0.000115 |\n| checking permissions | 0.000013 |\n| Opening tables | 0.000027 |\n| init | 0.000035 |\n| System lock | 0.000017 |\n| optimizing | 0.000016 |\n| statistics | 0.000025 |\n| preparing | 0.000020 |\n| executing | 0.000006 |\n| Sending data | 0.000294 |\n| end | 0.000009 |\n| query end | 0.000012 |\n| closing tables | 0.000011 |\n| freeing items | 0.000024 |\n| cleaning up | 0.000016 |\n+----------------------+----------+\n15 rows in set, 1 warning (0.00 sec)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>3、trace</p>\n<p>使用 trace 查看优化器如何选择执行计划</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">mysql> set session optimizer_trace=\"enabled=on\",end_markers_in_json=on;\n/* optimizer_trace=\"enabled=on\" 表示开启 trace；end_markers_in_json=on 表示 JSON 输出开启结束标记 */\nmysql> select * from t1 where a >900 and b > 910 order by a;\nmysql> SELECT * FROM information_schema.OPTIMIZER_TRACE\\G;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>TRACE包括准备阶段、优化阶段、执行阶段。trace中可以看到使用每个索引的成本。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"定位慢sql\"><a href=\"#定位慢sql\" class=\"headerlink\" title=\"定位慢sql\"></a>定位慢sql</h2><p>1、查看慢查询日志确定已经执行完的慢查询</p>\n<pre><code class=\"mysql\">mysql&gt; set global slow_query_log = on;\nmysql&gt; set global long_query_time = 1;\nmysql&gt; show global variables like &quot;datadir&quot;;\nmysql&gt; show global variables like &quot;slow_query_log_file&quot;;\n\n[root@mysqltest ~]# tail -n5 /data/mysql/data/3306/mysql-slow.log\nTime: 2019-05-21T09:15:06.255554+08:00\nUser@Host: root[root] @ localhost [] Id: 8591152\nQuery_time: 10.000260 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0\nSET timestamp=1558401306;\nselect sleep(10);</code></pre>\n<p>可以看到查询时间、表锁时间。</p>\n<p>2、show processlist 查看正在执行的慢查询</p>\n<pre><code class=\"mysql\">mysql&gt; show processlist\\G`\n\n`*************************** 10. row ***************************`\n`Id: 7651833`\n`User: one`\n`Host: 192.168.1.251:52154`\n`db: ops`\n`Command: Query`\n`Time: 3`\n`State: User sleep`\n`Info: select sleep(10)`\n`......`\n`10 rows in set (0.00 sec)`</code></pre>\n<p>可以看到执行时间和SQL语句</p>\n<h2 id=\"分析慢查询\"><a href=\"#分析慢查询\" class=\"headerlink\" title=\"分析慢查询\"></a>分析慢查询</h2><p>1、使用 explain 分析慢查询</p>\n<p>获取 MySQL 中 SQL 语句的执行计划.需要重点关注以下：</p>\n<ul>\n<li><p>select_type 查询类型：显示本行是简单还是复杂查询</p>\n</li>\n<li><p>type 本次查询的表连接类型</p>\n</li>\n<li><p>key 实际选择的索引</p>\n</li>\n<li><p>rows 预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确</p>\n</li>\n<li><p>Extra 附加信息</p>\n</li>\n</ul>\n<p>其中</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">select_type</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">SIMPLE</td>\n<td>简单查询(不使用关联查询或子查询)</td>\n</tr>\n<tr>\n<td align=\"left\">PRIMARY</td>\n<td>如果包含关联查询或者子查询，则最外层的查询部分标记为primary</td>\n</tr>\n<tr>\n<td align=\"left\">UNION</td>\n<td>联合查询中第二个及后面的查询</td>\n</tr>\n<tr>\n<td align=\"left\">DEPENDENT UNION</td>\n<td>满足依赖外部的关联查询中第二个及以后的查询</td>\n</tr>\n<tr>\n<td align=\"left\">UNION RESULT</td>\n<td>联合查询的结果</td>\n</tr>\n<tr>\n<td align=\"left\">SUBQUERY</td>\n<td>子查询中的第一个查询</td>\n</tr>\n<tr>\n<td align=\"left\">DEPENDENT SUBQUERY</td>\n<td>子查询中的第一个查询，并且依赖外部查询</td>\n</tr>\n<tr>\n<td align=\"left\">DERIVED</td>\n<td>用到派生表的查询</td>\n</tr>\n<tr>\n<td align=\"left\">MATERIALIZED</td>\n<td>被物化的子查询</td>\n</tr>\n<tr>\n<td align=\"left\">UNCACHEABLE SUBQUERY</td>\n<td>一个子查询的结果不能被缓存，必须重新评估外层查询的每一行</td>\n</tr>\n<tr>\n<td align=\"left\">UNCACHEABLE UNION</td>\n<td>关联查询第二个或后面的语句属于不可缓存的子查询</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">type</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">system</td>\n<td align=\"left\">查询对象表只有一行数据,且只能用于</td>\n</tr>\n<tr>\n<td align=\"left\">const</td>\n<td align=\"left\">基于主键或唯一索引查询，最多返回一条结果</td>\n</tr>\n<tr>\n<td align=\"left\">eq_ref</td>\n<td align=\"left\">表连接时基于主键或非</td>\n</tr>\n<tr>\n<td align=\"left\">ref</td>\n<td align=\"left\">基于普通索引的等值查询，或者表间等值连接</td>\n</tr>\n<tr>\n<td align=\"left\">fulltext</td>\n<td align=\"left\">全文检索</td>\n</tr>\n<tr>\n<td align=\"left\">ref_or_null</td>\n<td align=\"left\">表连接类型是</td>\n</tr>\n<tr>\n<td align=\"left\">index_merge</td>\n<td align=\"left\">利用多个索引</td>\n</tr>\n<tr>\n<td align=\"left\">unique_subquery</td>\n<td align=\"left\">子查询中使用唯一索引</td>\n</tr>\n<tr>\n<td align=\"left\">index_subquery</td>\n<td align=\"left\">子查询中使用普通索引</td>\n</tr>\n<tr>\n<td align=\"left\">range</td>\n<td align=\"left\">利用索引进行范围查询</td>\n</tr>\n<tr>\n<td align=\"left\">index</td>\n<td align=\"left\">全索引扫描</td>\n</tr>\n<tr>\n<td align=\"left\">ALL</td>\n<td align=\"left\">全表扫描</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Extra</th>\n<th align=\"left\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Using filesort</td>\n<td align=\"left\">将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序</td>\n</tr>\n<tr>\n<td align=\"left\">Using temporary</td>\n<td align=\"left\">需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时</td>\n</tr>\n<tr>\n<td align=\"left\">Using index</td>\n<td align=\"left\">使用覆盖索引</td>\n</tr>\n<tr>\n<td align=\"left\">Using where</td>\n<td align=\"left\">使用 where 语句来处理结果</td>\n</tr>\n<tr>\n<td align=\"left\">Impossible WHERE</td>\n<td align=\"left\">对 where 子句判断的结果总是 false 而不能选择任何数据</td>\n</tr>\n<tr>\n<td align=\"left\">Using join buffer (BlockNested Loop)</td>\n<td align=\"left\">关联查询中，被驱动表的关联字段没索引</td>\n</tr>\n<tr>\n<td align=\"left\">Using index condition</td>\n<td align=\"left\">先条件过滤索引，再查数据</td>\n</tr>\n<tr>\n<td align=\"left\">Select tables optimized away</td>\n<td align=\"left\">使用某些聚合函数（比如 max、min）来访问存在索引的某个字段</td>\n</tr>\n</tbody></table>\n<p>2、show profile</p>\n<p>了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节</p>\n<pre><code class=\"mysql\">mysql&gt; select @@have_profiling;\nmysql&gt; select @@profiling;\nmysql&gt; set profiling=1;\nmysql&gt; select * from t1 where b=1000;\nmysql&gt; show profiles;  /*获取query id*/\nmysql&gt; show profile for query 1;\n\n+----------------------+----------+\n| Status | Duration |\n+----------------------+----------+\n| starting | 0.000115 |\n| checking permissions | 0.000013 |\n| Opening tables | 0.000027 |\n| init | 0.000035 |\n| System lock | 0.000017 |\n| optimizing | 0.000016 |\n| statistics | 0.000025 |\n| preparing | 0.000020 |\n| executing | 0.000006 |\n| Sending data | 0.000294 |\n| end | 0.000009 |\n| query end | 0.000012 |\n| closing tables | 0.000011 |\n| freeing items | 0.000024 |\n| cleaning up | 0.000016 |\n+----------------------+----------+\n15 rows in set, 1 warning (0.00 sec)</code></pre>\n<p>3、trace</p>\n<p>使用 trace 查看优化器如何选择执行计划</p>\n<pre><code class=\"mysql\">mysql&gt; set session optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;\n/* optimizer_trace=&quot;enabled=on&quot; 表示开启 trace；end_markers_in_json=on 表示 JSON 输出开启结束标记 */\nmysql&gt; select * from t1 where a &gt;900 and b &gt; 910 order by a;\nmysql&gt; SELECT * FROM information_schema.OPTIMIZER_TRACE\\G;\n</code></pre>\n<p>TRACE包括准备阶段、优化阶段、执行阶段。trace中可以看到使用每个索引的成本。</p>\n"},{"title":"批量数据导入优化","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-13T03:53:46.000Z","password":null,"summary":null,"_content":"\n插入行所需的时间由以下因素决定([mysql manual][https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html])\n\n- 连接：30%\n- 向服务器发送查询：20%\n- 解析查询：20%\n- 插入行：10% * 行的大小\n- 插入索引：10% * 索引数\n- 结束：10%\n\n## 一次插入多行的值\n\n有大批量导入时，推荐一条insert语句插入多行数据。\n\n原因：减少服务器通信时间\n\n## 关闭自动提交\n\nAutocommit 开启时会为每个插入执行提交。可以在InnoDB导入数据时，关闭自动提交。\n\n原因：合并提交可以减少客户端与服务端通信的时间，减少数据落盘的次数。\n\n## 参数调整\n\ninnodb_flush_log_at_trx_commit：控制重做日志刷新到磁盘的策略\n\n- 0：master线程每秒把redo log buffer写到操作系统缓存，再刷到磁盘；\n- 1：每次提交事务都将redo log buffer写到操作系统缓存，再刷到磁盘；\n- 2：每次事务提交都将redo log buffer写到操作系统缓存，由操作系统来管理刷盘。\n\nsync_binlog：控制binlog的刷盘时机\n\n- 0：二进制日志从不同步到磁盘，依赖OS刷盘机制；\n- 1：二进制日志每次提交都会刷盘；\n- n(n>1) : 每n次提交落盘一次。\n\ninnodb_flush_log_at_trx_commit设置为0、同时sync_binlog设置为0时，写入数据的速度是最快的。","source":"_posts/批量数据导入优化.md","raw":"---\ntitle: 批量数据导入优化\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-13 11:53:46\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n插入行所需的时间由以下因素决定([mysql manual][https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html])\n\n- 连接：30%\n- 向服务器发送查询：20%\n- 解析查询：20%\n- 插入行：10% * 行的大小\n- 插入索引：10% * 索引数\n- 结束：10%\n\n## 一次插入多行的值\n\n有大批量导入时，推荐一条insert语句插入多行数据。\n\n原因：减少服务器通信时间\n\n## 关闭自动提交\n\nAutocommit 开启时会为每个插入执行提交。可以在InnoDB导入数据时，关闭自动提交。\n\n原因：合并提交可以减少客户端与服务端通信的时间，减少数据落盘的次数。\n\n## 参数调整\n\ninnodb_flush_log_at_trx_commit：控制重做日志刷新到磁盘的策略\n\n- 0：master线程每秒把redo log buffer写到操作系统缓存，再刷到磁盘；\n- 1：每次提交事务都将redo log buffer写到操作系统缓存，再刷到磁盘；\n- 2：每次事务提交都将redo log buffer写到操作系统缓存，由操作系统来管理刷盘。\n\nsync_binlog：控制binlog的刷盘时机\n\n- 0：二进制日志从不同步到磁盘，依赖OS刷盘机制；\n- 1：二进制日志每次提交都会刷盘；\n- n(n>1) : 每n次提交落盘一次。\n\ninnodb_flush_log_at_trx_commit设置为0、同时sync_binlog设置为0时，写入数据的速度是最快的。","slug":"批量数据导入优化","published":1,"updated":"2021-03-13T07:32:54.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wbi0032i4uf1xirrq70","content":"<p>插入行所需的时间由以下因素决定([mysql manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html]\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html]</a>)</p>\n<ul>\n<li>连接：30%</li>\n<li>向服务器发送查询：20%</li>\n<li>解析查询：20%</li>\n<li>插入行：10% * 行的大小</li>\n<li>插入索引：10% * 索引数</li>\n<li>结束：10%</li>\n</ul>\n<h2 id=\"一次插入多行的值\"><a href=\"#一次插入多行的值\" class=\"headerlink\" title=\"一次插入多行的值\"></a>一次插入多行的值</h2><p>有大批量导入时，推荐一条insert语句插入多行数据。</p>\n<p>原因：减少服务器通信时间</p>\n<h2 id=\"关闭自动提交\"><a href=\"#关闭自动提交\" class=\"headerlink\" title=\"关闭自动提交\"></a>关闭自动提交</h2><p>Autocommit 开启时会为每个插入执行提交。可以在InnoDB导入数据时，关闭自动提交。</p>\n<p>原因：合并提交可以减少客户端与服务端通信的时间，减少数据落盘的次数。</p>\n<h2 id=\"参数调整\"><a href=\"#参数调整\" class=\"headerlink\" title=\"参数调整\"></a>参数调整</h2><p>innodb_flush_log_at_trx_commit：控制重做日志刷新到磁盘的策略</p>\n<ul>\n<li>0：master线程每秒把redo log buffer写到操作系统缓存，再刷到磁盘；</li>\n<li>1：每次提交事务都将redo log buffer写到操作系统缓存，再刷到磁盘；</li>\n<li>2：每次事务提交都将redo log buffer写到操作系统缓存，由操作系统来管理刷盘。</li>\n</ul>\n<p>sync_binlog：控制binlog的刷盘时机</p>\n<ul>\n<li>0：二进制日志从不同步到磁盘，依赖OS刷盘机制；</li>\n<li>1：二进制日志每次提交都会刷盘；</li>\n<li>n(n&gt;1) : 每n次提交落盘一次。</li>\n</ul>\n<p>innodb_flush_log_at_trx_commit设置为0、同时sync_binlog设置为0时，写入数据的速度是最快的。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<p>插入行所需的时间由以下因素决定([mysql manual][<a href=\"https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html]\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html]</a>)</p>\n<ul>\n<li>连接：30%</li>\n<li>向服务器发送查询：20%</li>\n<li>解析查询：20%</li>\n<li>插入行：10% * 行的大小</li>\n<li>插入索引：10% * 索引数</li>\n<li>结束：10%</li>\n</ul>\n<h2 id=\"一次插入多行的值\"><a href=\"#一次插入多行的值\" class=\"headerlink\" title=\"一次插入多行的值\"></a>一次插入多行的值</h2><p>有大批量导入时，推荐一条insert语句插入多行数据。</p>\n<p>原因：减少服务器通信时间</p>\n<h2 id=\"关闭自动提交\"><a href=\"#关闭自动提交\" class=\"headerlink\" title=\"关闭自动提交\"></a>关闭自动提交</h2><p>Autocommit 开启时会为每个插入执行提交。可以在InnoDB导入数据时，关闭自动提交。</p>\n<p>原因：合并提交可以减少客户端与服务端通信的时间，减少数据落盘的次数。</p>\n<h2 id=\"参数调整\"><a href=\"#参数调整\" class=\"headerlink\" title=\"参数调整\"></a>参数调整</h2><p>innodb_flush_log_at_trx_commit：控制重做日志刷新到磁盘的策略</p>\n<ul>\n<li>0：master线程每秒把redo log buffer写到操作系统缓存，再刷到磁盘；</li>\n<li>1：每次提交事务都将redo log buffer写到操作系统缓存，再刷到磁盘；</li>\n<li>2：每次事务提交都将redo log buffer写到操作系统缓存，由操作系统来管理刷盘。</li>\n</ul>\n<p>sync_binlog：控制binlog的刷盘时机</p>\n<ul>\n<li>0：二进制日志从不同步到磁盘，依赖OS刷盘机制；</li>\n<li>1：二进制日志每次提交都会刷盘；</li>\n<li>n(n&gt;1) : 每n次提交落盘一次。</li>\n</ul>\n<p>innodb_flush_log_at_trx_commit设置为0、同时sync_binlog设置为0时，写入数据的速度是最快的。</p>\n"},{"title":"索引","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-13T14:06:54.000Z","password":null,"summary":null,"_content":"\n## 数据结构\n\n### B 树\n\nB 树每个节点都包含 key 值和 data 值，因此如果 data 比较大时，每一页存储的 key 会比较少；当数据比较多时，有“要经历多层节点才能查询在叶子节点的数据”的问题。\n\n### B+ 树\n\n- 所有叶子节点中包含了全部关键字的信息\n- 各叶子节点用指针进行连接\n- 非叶子节点上只存储 key 的信息，这样相对 B 树，可以增加每一页中存储 key 的数量。\n- B 树是纵向扩展，最终变成一个“瘦高个”，而 B+ 树是横向扩展的，最终会变成一个“矮胖子”\n\n## 索引\n\n### 聚集索引\n\nInnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。\n\n### 辅助索引\n\nInnoDB 存储引擎辅助索引的叶子节点存放的是键值和主键 ID。\n\n当通过辅助索引来寻找数据时，InnoDB 存储引擎会查找到对应记录的主键，然后通过主键索引来找到对应的行数据。\n\n### 使用\n\n- 数据检索\n- 聚合函数（max/count）\n- 排序\n- 避免回表（覆盖索引）\n- 关联查询\n\n### 普通索引和唯一索引\n\n**Insert Buffer**：对于非聚集索引的插入时，先判断插入的非聚集索引页是否在缓冲池（Buffer Pool）中。如果在，则直接插入；如果不在，则先放\n入 Insert Buffer 中，然后再以一定频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge 操作。**要求不是唯一索引**\n\n意义：将多个插入合并到一个操作中，大大提高了非聚集索引的插入性能。\n\n**Change Buffer**：Insert Buffer 的升级，，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。**要求不是唯一索引**\n\n参数：\n\n- innodb_change_buffering：确定哪些场景使用 Change Buffer，它的值包含：none、inserts、deletes、\n  changes、purges、all。默认为 all，表示启用所有。\n\n- innodb_change_buffer_max_size：控制 Change Buffer 最大使用内存占总 buffer pool 的百分比。默认25，表示\n  最多可以使用 buffer pool 的 25%，最大值50。\n\n原因：唯一索引必须要将数据页读入内存才能判断是否违反唯一性约束。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 Change Buffer 了。\n\n**区别**\n\n1、有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。\n\n2、如果对数据有修改操作，则普通索引可以用 Change Buffer，而唯一索引不行。\n\n3、数据修改时，唯一索引在 RR 隔离级别下，更容易出现死锁。\n\n4、查询数据时，普通索引查到满足条件的第一条记录还需要继续查找下一个记录，而唯一索引查找到第一个记录就可以直接返回结果了，但是普通索引多出的查找次数所消耗的资源多数情况可以忽略不计。\n\n**选择**\n\n1、如果业务要求某个字段唯一，但是代码不能完全保证写入唯一值，则添加唯一索引\n\n2、如果代码确定某个字段不会有重复的数据写入，则可以选择添加普通索引。\n\n### 联合索引\n\n对表上的多个列进行索引。适合 where 条件中的多列组合，在某些场景可以避免回表。\n\n使用：\n\n- where 条件中，经常同时出现的列放在联合索引中。\n- 把选择性最大的列放在联合索引的最左边。\n\n联合索引应用：\n\n```mysql\n/*使用完整联合索引*/\nselect * from t11 where a=1 and b=1 and c=1;\nselect * from t11 where c=1 and b=1 and a=1;\nselect * from t11 where a=2 and b in (1,2) and c=2;\nselect * from t11 where a=1 and b=2 order by c;\nselect * from t11 where a=1 order by b,c;\nselect a,b,c from t11 order by a,b,c;\n/*使用部分联合索引idx_a_b_c*/\nselect * from t11 where a=1 and b=1;\nselect * from t11 where a=1 and c=1;//索引a\nselect * from t11 where a=2 and b in (3,4) order by c; //索引ab\n/*覆盖索引,不需要回表查询聚集索引中的记录*/\nselect b,c from t11 where a=3;\nselect c from t11 where a=1 and b=1 ;\nselect id from t11 where a=1 and b=1 and c=1;\n/*不能使用联合索引*/\nselect * from t11 where b=1; //联合索引最左匹配\nselect * from t11 order by b;\n```\n\n### 优化器索引选择\n\n`show index`可以看到索引的Cardinality，即索引中不重复记录数量的预估值。\n\nCardinality 统计信息的更新时机：\n\n- 表中 1/16 的数据已经发生过变化\n- 表中数据发生变化次数超过 2000000000\n\n**统计方法**\n\n随机取出 B+ 树索引中的 8 个叶子节点，统计每个页中不同记录的个数，计算得到每页的平均数后，乘以叶子节点总数\n\n**问题**\n\n通过统计信息来预估扫描行数，Cardinality不精准可能导致选错了索引。\n\n**应对**\n\n```mysql\nanalyze table t13;//更新统计信息\n```\n\n**问题**\n\n如果单次选取的数据量过大，可能也会导致“选错”索引\n\n```mysql\nselect a from t13 where a>70000 limit 1000;//走了主键索引\n```\n\n**应对**\n\nforce index 来强制走索引\n\n```mysql\nselect a from t13 force index(idx_a) where a>70000 limit 1000;\n```\n\n","source":"_posts/索引.md","raw":"---\ntitle: 索引\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-13 22:06:54\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n## 数据结构\n\n### B 树\n\nB 树每个节点都包含 key 值和 data 值，因此如果 data 比较大时，每一页存储的 key 会比较少；当数据比较多时，有“要经历多层节点才能查询在叶子节点的数据”的问题。\n\n### B+ 树\n\n- 所有叶子节点中包含了全部关键字的信息\n- 各叶子节点用指针进行连接\n- 非叶子节点上只存储 key 的信息，这样相对 B 树，可以增加每一页中存储 key 的数量。\n- B 树是纵向扩展，最终变成一个“瘦高个”，而 B+ 树是横向扩展的，最终会变成一个“矮胖子”\n\n## 索引\n\n### 聚集索引\n\nInnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。\n\n### 辅助索引\n\nInnoDB 存储引擎辅助索引的叶子节点存放的是键值和主键 ID。\n\n当通过辅助索引来寻找数据时，InnoDB 存储引擎会查找到对应记录的主键，然后通过主键索引来找到对应的行数据。\n\n### 使用\n\n- 数据检索\n- 聚合函数（max/count）\n- 排序\n- 避免回表（覆盖索引）\n- 关联查询\n\n### 普通索引和唯一索引\n\n**Insert Buffer**：对于非聚集索引的插入时，先判断插入的非聚集索引页是否在缓冲池（Buffer Pool）中。如果在，则直接插入；如果不在，则先放\n入 Insert Buffer 中，然后再以一定频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge 操作。**要求不是唯一索引**\n\n意义：将多个插入合并到一个操作中，大大提高了非聚集索引的插入性能。\n\n**Change Buffer**：Insert Buffer 的升级，，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。**要求不是唯一索引**\n\n参数：\n\n- innodb_change_buffering：确定哪些场景使用 Change Buffer，它的值包含：none、inserts、deletes、\n  changes、purges、all。默认为 all，表示启用所有。\n\n- innodb_change_buffer_max_size：控制 Change Buffer 最大使用内存占总 buffer pool 的百分比。默认25，表示\n  最多可以使用 buffer pool 的 25%，最大值50。\n\n原因：唯一索引必须要将数据页读入内存才能判断是否违反唯一性约束。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 Change Buffer 了。\n\n**区别**\n\n1、有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。\n\n2、如果对数据有修改操作，则普通索引可以用 Change Buffer，而唯一索引不行。\n\n3、数据修改时，唯一索引在 RR 隔离级别下，更容易出现死锁。\n\n4、查询数据时，普通索引查到满足条件的第一条记录还需要继续查找下一个记录，而唯一索引查找到第一个记录就可以直接返回结果了，但是普通索引多出的查找次数所消耗的资源多数情况可以忽略不计。\n\n**选择**\n\n1、如果业务要求某个字段唯一，但是代码不能完全保证写入唯一值，则添加唯一索引\n\n2、如果代码确定某个字段不会有重复的数据写入，则可以选择添加普通索引。\n\n### 联合索引\n\n对表上的多个列进行索引。适合 where 条件中的多列组合，在某些场景可以避免回表。\n\n使用：\n\n- where 条件中，经常同时出现的列放在联合索引中。\n- 把选择性最大的列放在联合索引的最左边。\n\n联合索引应用：\n\n```mysql\n/*使用完整联合索引*/\nselect * from t11 where a=1 and b=1 and c=1;\nselect * from t11 where c=1 and b=1 and a=1;\nselect * from t11 where a=2 and b in (1,2) and c=2;\nselect * from t11 where a=1 and b=2 order by c;\nselect * from t11 where a=1 order by b,c;\nselect a,b,c from t11 order by a,b,c;\n/*使用部分联合索引idx_a_b_c*/\nselect * from t11 where a=1 and b=1;\nselect * from t11 where a=1 and c=1;//索引a\nselect * from t11 where a=2 and b in (3,4) order by c; //索引ab\n/*覆盖索引,不需要回表查询聚集索引中的记录*/\nselect b,c from t11 where a=3;\nselect c from t11 where a=1 and b=1 ;\nselect id from t11 where a=1 and b=1 and c=1;\n/*不能使用联合索引*/\nselect * from t11 where b=1; //联合索引最左匹配\nselect * from t11 order by b;\n```\n\n### 优化器索引选择\n\n`show index`可以看到索引的Cardinality，即索引中不重复记录数量的预估值。\n\nCardinality 统计信息的更新时机：\n\n- 表中 1/16 的数据已经发生过变化\n- 表中数据发生变化次数超过 2000000000\n\n**统计方法**\n\n随机取出 B+ 树索引中的 8 个叶子节点，统计每个页中不同记录的个数，计算得到每页的平均数后，乘以叶子节点总数\n\n**问题**\n\n通过统计信息来预估扫描行数，Cardinality不精准可能导致选错了索引。\n\n**应对**\n\n```mysql\nanalyze table t13;//更新统计信息\n```\n\n**问题**\n\n如果单次选取的数据量过大，可能也会导致“选错”索引\n\n```mysql\nselect a from t13 where a>70000 limit 1000;//走了主键索引\n```\n\n**应对**\n\nforce index 来强制走索引\n\n```mysql\nselect a from t13 force index(idx_a) where a>70000 limit 1000;\n```\n\n","slug":"索引","published":1,"updated":"2021-03-14T11:56:33.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wbo0037i4uf51wmr15e","content":"<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B 树\"></a>B 树</h3><p>B 树每个节点都包含 key 值和 data 值，因此如果 data 比较大时，每一页存储的 key 会比较少；当数据比较多时，有“要经历多层节点才能查询在叶子节点的数据”的问题。</p>\n<h3 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+ 树\"></a>B+ 树</h3><ul>\n<li>所有叶子节点中包含了全部关键字的信息</li>\n<li>各叶子节点用指针进行连接</li>\n<li>非叶子节点上只存储 key 的信息，这样相对 B 树，可以增加每一页中存储 key 的数量。</li>\n<li>B 树是纵向扩展，最终变成一个“瘦高个”，而 B+ 树是横向扩展的，最终会变成一个“矮胖子”</li>\n</ul>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h3 id=\"聚集索引\"><a href=\"#聚集索引\" class=\"headerlink\" title=\"聚集索引\"></a>聚集索引</h3><p>InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。</p>\n<h3 id=\"辅助索引\"><a href=\"#辅助索引\" class=\"headerlink\" title=\"辅助索引\"></a>辅助索引</h3><p>InnoDB 存储引擎辅助索引的叶子节点存放的是键值和主键 ID。</p>\n<p>当通过辅助索引来寻找数据时，InnoDB 存储引擎会查找到对应记录的主键，然后通过主键索引来找到对应的行数据。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>数据检索</li>\n<li>聚合函数（max/count）</li>\n<li>排序</li>\n<li>避免回表（覆盖索引）</li>\n<li>关联查询</li>\n</ul>\n<h3 id=\"普通索引和唯一索引\"><a href=\"#普通索引和唯一索引\" class=\"headerlink\" title=\"普通索引和唯一索引\"></a>普通索引和唯一索引</h3><p><strong>Insert Buffer</strong>：对于非聚集索引的插入时，先判断插入的非聚集索引页是否在缓冲池（Buffer Pool）中。如果在，则直接插入；如果不在，则先放<br>入 Insert Buffer 中，然后再以一定频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge 操作。<strong>要求不是唯一索引</strong></p>\n<p>意义：将多个插入合并到一个操作中，大大提高了非聚集索引的插入性能。</p>\n<p><strong>Change Buffer</strong>：Insert Buffer 的升级，，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。<strong>要求不是唯一索引</strong></p>\n<p>参数：</p>\n<ul>\n<li><p>innodb_change_buffering：确定哪些场景使用 Change Buffer，它的值包含：none、inserts、deletes、<br>changes、purges、all。默认为 all，表示启用所有。</p>\n</li>\n<li><p>innodb_change_buffer_max_size：控制 Change Buffer 最大使用内存占总 buffer pool 的百分比。默认25，表示<br>最多可以使用 buffer pool 的 25%，最大值50。</p>\n</li>\n</ul>\n<p>原因：唯一索引必须要将数据页读入内存才能判断是否违反唯一性约束。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 Change Buffer 了。</p>\n<p><strong>区别</strong></p>\n<p>1、有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。</p>\n<p>2、如果对数据有修改操作，则普通索引可以用 Change Buffer，而唯一索引不行。</p>\n<p>3、数据修改时，唯一索引在 RR 隔离级别下，更容易出现死锁。</p>\n<p>4、查询数据时，普通索引查到满足条件的第一条记录还需要继续查找下一个记录，而唯一索引查找到第一个记录就可以直接返回结果了，但是普通索引多出的查找次数所消耗的资源多数情况可以忽略不计。</p>\n<p><strong>选择</strong></p>\n<p>1、如果业务要求某个字段唯一，但是代码不能完全保证写入唯一值，则添加唯一索引</p>\n<p>2、如果代码确定某个字段不会有重复的数据写入，则可以选择添加普通索引。</p>\n<h3 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h3><p>对表上的多个列进行索引。适合 where 条件中的多列组合，在某些场景可以避免回表。</p>\n<p>使用：</p>\n<ul>\n<li>where 条件中，经常同时出现的列放在联合索引中。</li>\n<li>把选择性最大的列放在联合索引的最左边。</li>\n</ul>\n<p>联合索引应用：</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">/*使用完整联合索引*/\nselect * from t11 where a=1 and b=1 and c=1;\nselect * from t11 where c=1 and b=1 and a=1;\nselect * from t11 where a=2 and b in (1,2) and c=2;\nselect * from t11 where a=1 and b=2 order by c;\nselect * from t11 where a=1 order by b,c;\nselect a,b,c from t11 order by a,b,c;\n/*使用部分联合索引idx_a_b_c*/\nselect * from t11 where a=1 and b=1;\nselect * from t11 where a=1 and c=1;//索引a\nselect * from t11 where a=2 and b in (3,4) order by c; //索引ab\n/*覆盖索引,不需要回表查询聚集索引中的记录*/\nselect b,c from t11 where a=3;\nselect c from t11 where a=1 and b=1 ;\nselect id from t11 where a=1 and b=1 and c=1;\n/*不能使用联合索引*/\nselect * from t11 where b=1; //联合索引最左匹配\nselect * from t11 order by b;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"优化器索引选择\"><a href=\"#优化器索引选择\" class=\"headerlink\" title=\"优化器索引选择\"></a>优化器索引选择</h3><p><code>show index</code>可以看到索引的Cardinality，即索引中不重复记录数量的预估值。</p>\n<p>Cardinality 统计信息的更新时机：</p>\n<ul>\n<li>表中 1/16 的数据已经发生过变化</li>\n<li>表中数据发生变化次数超过 2000000000</li>\n</ul>\n<p><strong>统计方法</strong></p>\n<p>随机取出 B+ 树索引中的 8 个叶子节点，统计每个页中不同记录的个数，计算得到每页的平均数后，乘以叶子节点总数</p>\n<p><strong>问题</strong></p>\n<p>通过统计信息来预估扫描行数，Cardinality不精准可能导致选错了索引。</p>\n<p><strong>应对</strong></p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">analyze table t13;//更新统计信息<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>问题</strong></p>\n<p>如果单次选取的数据量过大，可能也会导致“选错”索引</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select a from t13 where a>70000 limit 1000;//走了主键索引<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>应对</strong></p>\n<p>force index 来强制走索引</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select a from t13 force index(idx_a) where a>70000 limit 1000;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B 树\"></a>B 树</h3><p>B 树每个节点都包含 key 值和 data 值，因此如果 data 比较大时，每一页存储的 key 会比较少；当数据比较多时，有“要经历多层节点才能查询在叶子节点的数据”的问题。</p>\n<h3 id=\"B-树-1\"><a href=\"#B-树-1\" class=\"headerlink\" title=\"B+ 树\"></a>B+ 树</h3><ul>\n<li>所有叶子节点中包含了全部关键字的信息</li>\n<li>各叶子节点用指针进行连接</li>\n<li>非叶子节点上只存储 key 的信息，这样相对 B 树，可以增加每一页中存储 key 的数量。</li>\n<li>B 树是纵向扩展，最终变成一个“瘦高个”，而 B+ 树是横向扩展的，最终会变成一个“矮胖子”</li>\n</ul>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h3 id=\"聚集索引\"><a href=\"#聚集索引\" class=\"headerlink\" title=\"聚集索引\"></a>聚集索引</h3><p>InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。</p>\n<h3 id=\"辅助索引\"><a href=\"#辅助索引\" class=\"headerlink\" title=\"辅助索引\"></a>辅助索引</h3><p>InnoDB 存储引擎辅助索引的叶子节点存放的是键值和主键 ID。</p>\n<p>当通过辅助索引来寻找数据时，InnoDB 存储引擎会查找到对应记录的主键，然后通过主键索引来找到对应的行数据。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>数据检索</li>\n<li>聚合函数（max/count）</li>\n<li>排序</li>\n<li>避免回表（覆盖索引）</li>\n<li>关联查询</li>\n</ul>\n<h3 id=\"普通索引和唯一索引\"><a href=\"#普通索引和唯一索引\" class=\"headerlink\" title=\"普通索引和唯一索引\"></a>普通索引和唯一索引</h3><p><strong>Insert Buffer</strong>：对于非聚集索引的插入时，先判断插入的非聚集索引页是否在缓冲池（Buffer Pool）中。如果在，则直接插入；如果不在，则先放<br>入 Insert Buffer 中，然后再以一定频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge 操作。<strong>要求不是唯一索引</strong></p>\n<p>意义：将多个插入合并到一个操作中，大大提高了非聚集索引的插入性能。</p>\n<p><strong>Change Buffer</strong>：Insert Buffer 的升级，，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。<strong>要求不是唯一索引</strong></p>\n<p>参数：</p>\n<ul>\n<li><p>innodb_change_buffering：确定哪些场景使用 Change Buffer，它的值包含：none、inserts、deletes、<br>changes、purges、all。默认为 all，表示启用所有。</p>\n</li>\n<li><p>innodb_change_buffer_max_size：控制 Change Buffer 最大使用内存占总 buffer pool 的百分比。默认25，表示<br>最多可以使用 buffer pool 的 25%，最大值50。</p>\n</li>\n</ul>\n<p>原因：唯一索引必须要将数据页读入内存才能判断是否违反唯一性约束。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 Change Buffer 了。</p>\n<p><strong>区别</strong></p>\n<p>1、有普通索引的字段可以写入重复的值，而有唯一索引的字段不可以写入重复的值。</p>\n<p>2、如果对数据有修改操作，则普通索引可以用 Change Buffer，而唯一索引不行。</p>\n<p>3、数据修改时，唯一索引在 RR 隔离级别下，更容易出现死锁。</p>\n<p>4、查询数据时，普通索引查到满足条件的第一条记录还需要继续查找下一个记录，而唯一索引查找到第一个记录就可以直接返回结果了，但是普通索引多出的查找次数所消耗的资源多数情况可以忽略不计。</p>\n<p><strong>选择</strong></p>\n<p>1、如果业务要求某个字段唯一，但是代码不能完全保证写入唯一值，则添加唯一索引</p>\n<p>2、如果代码确定某个字段不会有重复的数据写入，则可以选择添加普通索引。</p>\n<h3 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h3><p>对表上的多个列进行索引。适合 where 条件中的多列组合，在某些场景可以避免回表。</p>\n<p>使用：</p>\n<ul>\n<li>where 条件中，经常同时出现的列放在联合索引中。</li>\n<li>把选择性最大的列放在联合索引的最左边。</li>\n</ul>\n<p>联合索引应用：</p>\n<pre><code class=\"mysql\">/*使用完整联合索引*/\nselect * from t11 where a=1 and b=1 and c=1;\nselect * from t11 where c=1 and b=1 and a=1;\nselect * from t11 where a=2 and b in (1,2) and c=2;\nselect * from t11 where a=1 and b=2 order by c;\nselect * from t11 where a=1 order by b,c;\nselect a,b,c from t11 order by a,b,c;\n/*使用部分联合索引idx_a_b_c*/\nselect * from t11 where a=1 and b=1;\nselect * from t11 where a=1 and c=1;//索引a\nselect * from t11 where a=2 and b in (3,4) order by c; //索引ab\n/*覆盖索引,不需要回表查询聚集索引中的记录*/\nselect b,c from t11 where a=3;\nselect c from t11 where a=1 and b=1 ;\nselect id from t11 where a=1 and b=1 and c=1;\n/*不能使用联合索引*/\nselect * from t11 where b=1; //联合索引最左匹配\nselect * from t11 order by b;</code></pre>\n<h3 id=\"优化器索引选择\"><a href=\"#优化器索引选择\" class=\"headerlink\" title=\"优化器索引选择\"></a>优化器索引选择</h3><p><code>show index</code>可以看到索引的Cardinality，即索引中不重复记录数量的预估值。</p>\n<p>Cardinality 统计信息的更新时机：</p>\n<ul>\n<li>表中 1/16 的数据已经发生过变化</li>\n<li>表中数据发生变化次数超过 2000000000</li>\n</ul>\n<p><strong>统计方法</strong></p>\n<p>随机取出 B+ 树索引中的 8 个叶子节点，统计每个页中不同记录的个数，计算得到每页的平均数后，乘以叶子节点总数</p>\n<p><strong>问题</strong></p>\n<p>通过统计信息来预估扫描行数，Cardinality不精准可能导致选错了索引。</p>\n<p><strong>应对</strong></p>\n<pre><code class=\"mysql\">analyze table t13;//更新统计信息</code></pre>\n<p><strong>问题</strong></p>\n<p>如果单次选取的数据量过大，可能也会导致“选错”索引</p>\n<pre><code class=\"mysql\">select a from t13 where a&gt;70000 limit 1000;//走了主键索引</code></pre>\n<p><strong>应对</strong></p>\n<p>force index 来强制走索引</p>\n<pre><code class=\"mysql\">select a from t13 force index(idx_a) where a&gt;70000 limit 1000;</code></pre>\n"},{"title":"索引失效","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-13T03:07:49.000Z","password":null,"summary":null,"_content":"\n## 函数操作\n\n对条件字段做函数操作走不了索引。\n\n```mysql\nselect * from t1 where date(c) ='2019-05-21';\n```\n\n优化：改成范围查询\n\n```mysql\nselect * from t1 where c>='2019-05-21 00:00:00' and c<='2019-05-21 23:59:59';\n```\n\n## 隐式转换\n\n操作符与不同类型的操作对象一起使用时，就会发生类型转换以使操作兼容。\n\n```mysql\nselect user_name,tele_phone from user_info where tele_phone =11111111111; /* tele_phone varchar */\n```\n\n实际会做函数操作：\n\n```mysql\nselect user_name,tele_phone from user_info where cast(tele_phone as singed int) =11111111111; \n```\n\n优化：类型统一\n\n```mysql\nselect user_name,tele_phone from user_info where tele_phone ='11111111111';\n```\n\n## 模糊查询\n\n通配符在前面\n\n```mysql\nselect * from t1 where a like '%1111%';\n```\n\n优化:模糊查询必须包含条件字段前面的值\n\n```mysql\nselect * from t1 where a like '1111%';\n```\n\n## 范围查询\n\n范围查询数据量太多，需要回表，因此不走索引。\n\n```mysql\nselect * from t1 where b>=1 and b <=2000;\n```\n\n优化：降低单次查询范围，分多次查询。（实际可能速度没得快太多,建议走索引）\n\n```\nselect * from t1 where b>=1 and b <=1000;\n\n show profiles;\n+----------+------------+------------------------------------------+\n| Query_ID | Duration   | Query                                    |\n+----------+------------+------------------------------------------+\n|        1 | 0.00534775 | select * from t1 where b>=1 and b <=1000 |\n|        2 | 0.00605625 | select * from t1 where b>=1 and b <=2000 |\n+----------+------------+------------------------------------------+\n2 rows in set, 1 warning (0.00 sec)\n```\n\n## 计算操作\n\n即使是简单的计算\n\n```mysql\nexplain select * from t1 where b-1 =1000;\n```\n\n优化：将计算操作放在等号后面\n\n```mysql\nexplain select * from t1 where b =1000 + 1;\n```\n\n\n\n\n\n","source":"_posts/索引失效.md","raw":"---\ntitle: 索引失效\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-13 11:07:49\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n## 函数操作\n\n对条件字段做函数操作走不了索引。\n\n```mysql\nselect * from t1 where date(c) ='2019-05-21';\n```\n\n优化：改成范围查询\n\n```mysql\nselect * from t1 where c>='2019-05-21 00:00:00' and c<='2019-05-21 23:59:59';\n```\n\n## 隐式转换\n\n操作符与不同类型的操作对象一起使用时，就会发生类型转换以使操作兼容。\n\n```mysql\nselect user_name,tele_phone from user_info where tele_phone =11111111111; /* tele_phone varchar */\n```\n\n实际会做函数操作：\n\n```mysql\nselect user_name,tele_phone from user_info where cast(tele_phone as singed int) =11111111111; \n```\n\n优化：类型统一\n\n```mysql\nselect user_name,tele_phone from user_info where tele_phone ='11111111111';\n```\n\n## 模糊查询\n\n通配符在前面\n\n```mysql\nselect * from t1 where a like '%1111%';\n```\n\n优化:模糊查询必须包含条件字段前面的值\n\n```mysql\nselect * from t1 where a like '1111%';\n```\n\n## 范围查询\n\n范围查询数据量太多，需要回表，因此不走索引。\n\n```mysql\nselect * from t1 where b>=1 and b <=2000;\n```\n\n优化：降低单次查询范围，分多次查询。（实际可能速度没得快太多,建议走索引）\n\n```\nselect * from t1 where b>=1 and b <=1000;\n\n show profiles;\n+----------+------------+------------------------------------------+\n| Query_ID | Duration   | Query                                    |\n+----------+------------+------------------------------------------+\n|        1 | 0.00534775 | select * from t1 where b>=1 and b <=1000 |\n|        2 | 0.00605625 | select * from t1 where b>=1 and b <=2000 |\n+----------+------------+------------------------------------------+\n2 rows in set, 1 warning (0.00 sec)\n```\n\n## 计算操作\n\n即使是简单的计算\n\n```mysql\nexplain select * from t1 where b-1 =1000;\n```\n\n优化：将计算操作放在等号后面\n\n```mysql\nexplain select * from t1 where b =1000 + 1;\n```\n\n\n\n\n\n","slug":"索引失效","published":1,"updated":"2021-03-13T03:45:52.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wbt003ai4ufw6tqvzna","content":"<h2 id=\"函数操作\"><a href=\"#函数操作\" class=\"headerlink\" title=\"函数操作\"></a>函数操作</h2><p>对条件字段做函数操作走不了索引。</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select * from t1 where date(c) ='2019-05-21';<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>优化：改成范围查询</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select * from t1 where c>='2019-05-21 00:00:00' and c<='2019-05-21 23:59:59';<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h2><p>操作符与不同类型的操作对象一起使用时，就会发生类型转换以使操作兼容。</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select user_name,tele_phone from user_info where tele_phone =11111111111; /* tele_phone varchar */<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>实际会做函数操作：</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select user_name,tele_phone from user_info where cast(tele_phone as singed int) =11111111111; <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>优化：类型统一</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select user_name,tele_phone from user_info where tele_phone ='11111111111';<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h2><p>通配符在前面</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select * from t1 where a like '%1111%';<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>优化:模糊查询必须包含条件字段前面的值</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select * from t1 where a like '1111%';<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"范围查询\"><a href=\"#范围查询\" class=\"headerlink\" title=\"范围查询\"></a>范围查询</h2><p>范围查询数据量太多，需要回表，因此不走索引。</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">select * from t1 where b>=1 and b <=2000;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>优化：降低单次查询范围，分多次查询。（实际可能速度没得快太多,建议走索引）</p>\n<pre><code>select * from t1 where b&gt;=1 and b &lt;=1000;\n\n show profiles;\n+----------+------------+------------------------------------------+\n| Query_ID | Duration   | Query                                    |\n+----------+------------+------------------------------------------+\n|        1 | 0.00534775 | select * from t1 where b&gt;=1 and b &lt;=1000 |\n|        2 | 0.00605625 | select * from t1 where b&gt;=1 and b &lt;=2000 |\n+----------+------------+------------------------------------------+\n2 rows in set, 1 warning (0.00 sec)</code></pre><h2 id=\"计算操作\"><a href=\"#计算操作\" class=\"headerlink\" title=\"计算操作\"></a>计算操作</h2><p>即使是简单的计算</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">explain select * from t1 where b-1 =1000;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>优化：将计算操作放在等号后面</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">explain select * from t1 where b =1000 + 1;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<h2 id=\"函数操作\"><a href=\"#函数操作\" class=\"headerlink\" title=\"函数操作\"></a>函数操作</h2><p>对条件字段做函数操作走不了索引。</p>\n<pre><code class=\"mysql\">select * from t1 where date(c) =&#39;2019-05-21&#39;;</code></pre>\n<p>优化：改成范围查询</p>\n<pre><code class=\"mysql\">select * from t1 where c&gt;=&#39;2019-05-21 00:00:00&#39; and c&lt;=&#39;2019-05-21 23:59:59&#39;;</code></pre>\n<h2 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h2><p>操作符与不同类型的操作对象一起使用时，就会发生类型转换以使操作兼容。</p>\n<pre><code class=\"mysql\">select user_name,tele_phone from user_info where tele_phone =11111111111; /* tele_phone varchar */</code></pre>\n<p>实际会做函数操作：</p>\n<pre><code class=\"mysql\">select user_name,tele_phone from user_info where cast(tele_phone as singed int) =11111111111; </code></pre>\n<p>优化：类型统一</p>\n<pre><code class=\"mysql\">select user_name,tele_phone from user_info where tele_phone =&#39;11111111111&#39;;</code></pre>\n<h2 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h2><p>通配符在前面</p>\n<pre><code class=\"mysql\">select * from t1 where a like &#39;%1111%&#39;;</code></pre>\n<p>优化:模糊查询必须包含条件字段前面的值</p>\n<pre><code class=\"mysql\">select * from t1 where a like &#39;1111%&#39;;</code></pre>\n<h2 id=\"范围查询\"><a href=\"#范围查询\" class=\"headerlink\" title=\"范围查询\"></a>范围查询</h2><p>范围查询数据量太多，需要回表，因此不走索引。</p>\n<pre><code class=\"mysql\">select * from t1 where b&gt;=1 and b &lt;=2000;</code></pre>\n<p>优化：降低单次查询范围，分多次查询。（实际可能速度没得快太多,建议走索引）</p>\n<pre><code>select * from t1 where b&gt;=1 and b &lt;=1000;\n\n show profiles;\n+----------+------------+------------------------------------------+\n| Query_ID | Duration   | Query                                    |\n+----------+------------+------------------------------------------+\n|        1 | 0.00534775 | select * from t1 where b&gt;=1 and b &lt;=1000 |\n|        2 | 0.00605625 | select * from t1 where b&gt;=1 and b &lt;=2000 |\n+----------+------------+------------------------------------------+\n2 rows in set, 1 warning (0.00 sec)</code></pre><h2 id=\"计算操作\"><a href=\"#计算操作\" class=\"headerlink\" title=\"计算操作\"></a>计算操作</h2><p>即使是简单的计算</p>\n<pre><code class=\"mysql\">explain select * from t1 where b-1 =1000;</code></pre>\n<p>优化：将计算操作放在等号后面</p>\n<pre><code class=\"mysql\">explain select * from t1 where b =1000 + 1;</code></pre>\n"},{"title":"锁","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2021-03-14T03:14:09.000Z","password":null,"summary":null,"_content":"\n锁就是协调多个用户或者客户端并发访问某一资源的机制，保证数据并发访问时的一致性和有效性。\n\n## 全局锁\n\nMySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。\n\n```mysql\nFLUSH TABLES WITH READ LOCK;\nUNLOCK TABLES;\n```\n\n当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。\n\n场景\n\n一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。\n\nmysqldump 包含一个参数 --single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以建议使用InnoDB 存储引擎。\n\n## 表级锁\n\n表级锁有两种：表锁和元数据锁。\n\n### 表锁\n\n场景\n\n1. 事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；\n2. 事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。\n\n```mysql\nlock tables t14 read;\nlock tables t14 write;\n```\n\n表读锁本线程和其它线程可以读，本线程写会报错，其它线程写会等待。\n\n### 元数据锁\n\nMDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。\n\n对开发而言尽量避免慢查询，事务要及时提交，避免大事务\n\n对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。\n\n## 行锁\n\nInnoDB后来居上：\n\n- InnoDB 支持事务：适合在并发条件下要求数据一致的场景。\n- InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。\n\n### 两阶段锁\n\n锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。\n\n### 行锁\n\n两种类型的行锁：\n\n- 共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；\n- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。\n\n共享锁（S）：select * from table_name where … lock in share mode;\n排他锁（X）：select * from table_name where … for update(当前读)。\n\n### 行锁算法\n\nRecord Lock：单个记录上的索引加锁。\nGap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。\nNext-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。\n\n### 事务隔离级别\n\nRead uncommitted（读未提交）: 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现\n脏读。\n**Read Committed（读已提交，简称： RC）**：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它\n实例在该实例处理期间可能会有新的 commit，**所以可能出现幻读**。\n**Repeatable Read（可重复读，简称：RR）**：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在\n并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，**默认也不会出现幻读**。\n**Serializable（串行）**：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。\n\n脏读：读取未提交的事务。\n幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。\n\n#### 非索引字段查询（RC）\n\n如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 server 层进行过滤。\n\n#### 唯一索引查询（RC）\n\n如果查询的条件是唯一索引，那么 SQL 需要在满足条件的唯一索引上加锁，并且会在对应的聚簇索引上加锁。\n\n#### 非唯一索引查询（RC）\n\n如果查询的条件是非唯一索引，那么 SQL 需要在满足条件的非唯一索引上都加上锁，并且会在它们对应的聚簇索引上加锁。\n\n#### 非索引字段查询（RR）\n\nRR 隔离级别下，非索引字段做条件的当前读不但会把每条记录都加上 X 锁，还会把每个 GAP 加上GAP 锁。（条件字段加索引的重要性！）\n\n#### 唯一索引查询（RR）\n\n如果能确保索引字段唯一，那其实一个等值查询，最多就返回一条记录，而且相同索引记录的值，一定不会再新增，因此不会出现 GAP 锁。\n\n以唯一索引为条件的当前读，不会有 GAP 锁。\n\n#### 非唯一索引查询(RR)\n\n新增GAP锁+对应数据的X锁\n\n## 死锁\n\n死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。\n\n**解决方法**\n\n1. 检测到死锁的循环依赖，立即返回一个错误，将参数 innodb_deadlock_detect设置为 on 表示开启这个逻辑；\n2. 等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是50 秒。\n\n方案1有额外的CPU检测开销，确保无死锁时建议关闭检测。\n\n**降低死锁概率**\n\n1. 更新 SQL 的 where 条件尽量用索引；\n2. 基于 primary 或 unique key 更新数据；\n3. 减少范围更新，尤其非主键、非唯一索引上的范围更新；\n4. 加锁顺序一致，尽可能一次性锁定所有需要行；\n5. 将 RR 隔离级别调整为 RC 隔离级别。\n\n**分析死锁**\n\n```mysql\nshow engine innodb status\\G; //查看最后一次死锁信息\n```\n\n另外设置 innodb_print_all_deadlocks = on 可以在 err log 中记录全部死锁信息。","source":"_posts/锁.md","raw":"---\ntitle: 锁\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2021-03-14 11:14:09\npassword:\nsummary:\ntags:\n- mysql\ncategories:\n- mysql\n---\n\n锁就是协调多个用户或者客户端并发访问某一资源的机制，保证数据并发访问时的一致性和有效性。\n\n## 全局锁\n\nMySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。\n\n```mysql\nFLUSH TABLES WITH READ LOCK;\nUNLOCK TABLES;\n```\n\n当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。\n\n场景\n\n一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。\n\nmysqldump 包含一个参数 --single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以建议使用InnoDB 存储引擎。\n\n## 表级锁\n\n表级锁有两种：表锁和元数据锁。\n\n### 表锁\n\n场景\n\n1. 事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；\n2. 事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。\n\n```mysql\nlock tables t14 read;\nlock tables t14 write;\n```\n\n表读锁本线程和其它线程可以读，本线程写会报错，其它线程写会等待。\n\n### 元数据锁\n\nMDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。\n\n对开发而言尽量避免慢查询，事务要及时提交，避免大事务\n\n对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。\n\n## 行锁\n\nInnoDB后来居上：\n\n- InnoDB 支持事务：适合在并发条件下要求数据一致的场景。\n- InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。\n\n### 两阶段锁\n\n锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。\n\n### 行锁\n\n两种类型的行锁：\n\n- 共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；\n- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。\n\n共享锁（S）：select * from table_name where … lock in share mode;\n排他锁（X）：select * from table_name where … for update(当前读)。\n\n### 行锁算法\n\nRecord Lock：单个记录上的索引加锁。\nGap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。\nNext-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。\n\n### 事务隔离级别\n\nRead uncommitted（读未提交）: 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现\n脏读。\n**Read Committed（读已提交，简称： RC）**：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它\n实例在该实例处理期间可能会有新的 commit，**所以可能出现幻读**。\n**Repeatable Read（可重复读，简称：RR）**：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在\n并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，**默认也不会出现幻读**。\n**Serializable（串行）**：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。\n\n脏读：读取未提交的事务。\n幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。\n\n#### 非索引字段查询（RC）\n\n如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 server 层进行过滤。\n\n#### 唯一索引查询（RC）\n\n如果查询的条件是唯一索引，那么 SQL 需要在满足条件的唯一索引上加锁，并且会在对应的聚簇索引上加锁。\n\n#### 非唯一索引查询（RC）\n\n如果查询的条件是非唯一索引，那么 SQL 需要在满足条件的非唯一索引上都加上锁，并且会在它们对应的聚簇索引上加锁。\n\n#### 非索引字段查询（RR）\n\nRR 隔离级别下，非索引字段做条件的当前读不但会把每条记录都加上 X 锁，还会把每个 GAP 加上GAP 锁。（条件字段加索引的重要性！）\n\n#### 唯一索引查询（RR）\n\n如果能确保索引字段唯一，那其实一个等值查询，最多就返回一条记录，而且相同索引记录的值，一定不会再新增，因此不会出现 GAP 锁。\n\n以唯一索引为条件的当前读，不会有 GAP 锁。\n\n#### 非唯一索引查询(RR)\n\n新增GAP锁+对应数据的X锁\n\n## 死锁\n\n死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。\n\n**解决方法**\n\n1. 检测到死锁的循环依赖，立即返回一个错误，将参数 innodb_deadlock_detect设置为 on 表示开启这个逻辑；\n2. 等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是50 秒。\n\n方案1有额外的CPU检测开销，确保无死锁时建议关闭检测。\n\n**降低死锁概率**\n\n1. 更新 SQL 的 where 条件尽量用索引；\n2. 基于 primary 或 unique key 更新数据；\n3. 减少范围更新，尤其非主键、非唯一索引上的范围更新；\n4. 加锁顺序一致，尽可能一次性锁定所有需要行；\n5. 将 RR 隔离级别调整为 RC 隔离级别。\n\n**分析死锁**\n\n```mysql\nshow engine innodb status\\G; //查看最后一次死锁信息\n```\n\n另外设置 innodb_print_all_deadlocks = on 可以在 err log 中记录全部死锁信息。","slug":"锁","published":1,"updated":"2021-03-14T11:56:37.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckm944wbx003fi4uf1tinzaqy","content":"<p>锁就是协调多个用户或者客户端并发访问某一资源的机制，保证数据并发访问时的一致性和有效性。</p>\n<h2 id=\"全局锁\"><a href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"></a>全局锁</h2><p>MySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。</p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">FLUSH TABLES WITH READ LOCK;\nUNLOCK TABLES;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。</p>\n<p>场景</p>\n<p>一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。</p>\n<p>mysqldump 包含一个参数 –single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以建议使用InnoDB 存储引擎。</p>\n<h2 id=\"表级锁\"><a href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"></a>表级锁</h2><p>表级锁有两种：表锁和元数据锁。</p>\n<h3 id=\"表锁\"><a href=\"#表锁\" class=\"headerlink\" title=\"表锁\"></a>表锁</h3><p>场景</p>\n<ol>\n<li>事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；</li>\n<li>事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。</li>\n</ol>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">lock tables t14 read;\nlock tables t14 write;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>表读锁本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</p>\n<h3 id=\"元数据锁\"><a href=\"#元数据锁\" class=\"headerlink\" title=\"元数据锁\"></a>元数据锁</h3><p>MDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。</p>\n<p>对开发而言尽量避免慢查询，事务要及时提交，避免大事务</p>\n<p>对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。</p>\n<h2 id=\"行锁\"><a href=\"#行锁\" class=\"headerlink\" title=\"行锁\"></a>行锁</h2><p>InnoDB后来居上：</p>\n<ul>\n<li>InnoDB 支持事务：适合在并发条件下要求数据一致的场景。</li>\n<li>InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。</li>\n</ul>\n<h3 id=\"两阶段锁\"><a href=\"#两阶段锁\" class=\"headerlink\" title=\"两阶段锁\"></a>两阶段锁</h3><p>锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p>\n<h3 id=\"行锁-1\"><a href=\"#行锁-1\" class=\"headerlink\" title=\"行锁\"></a>行锁</h3><p>两种类型的行锁：</p>\n<ul>\n<li>共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；</li>\n<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。</li>\n</ul>\n<p>共享锁（S）：select <em> from table_name where … lock in share mode;<br>排他锁（X）：select </em> from table_name where … for update(当前读)。</p>\n<h3 id=\"行锁算法\"><a href=\"#行锁算法\" class=\"headerlink\" title=\"行锁算法\"></a>行锁算法</h3><p>Record Lock：单个记录上的索引加锁。<br>Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。<br>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。</p>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p>Read uncommitted（读未提交）: 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现<br>脏读。<br><strong>Read Committed（读已提交，简称： RC）</strong>：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它<br>实例在该实例处理期间可能会有新的 commit，<strong>所以可能出现幻读</strong>。<br><strong>Repeatable Read（可重复读，简称：RR）</strong>：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在<br>并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，<strong>默认也不会出现幻读</strong>。<br><strong>Serializable（串行）</strong>：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</p>\n<p>脏读：读取未提交的事务。<br>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</p>\n<h4 id=\"非索引字段查询（RC）\"><a href=\"#非索引字段查询（RC）\" class=\"headerlink\" title=\"非索引字段查询（RC）\"></a>非索引字段查询（RC）</h4><p>如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 server 层进行过滤。</p>\n<h4 id=\"唯一索引查询（RC）\"><a href=\"#唯一索引查询（RC）\" class=\"headerlink\" title=\"唯一索引查询（RC）\"></a>唯一索引查询（RC）</h4><p>如果查询的条件是唯一索引，那么 SQL 需要在满足条件的唯一索引上加锁，并且会在对应的聚簇索引上加锁。</p>\n<h4 id=\"非唯一索引查询（RC）\"><a href=\"#非唯一索引查询（RC）\" class=\"headerlink\" title=\"非唯一索引查询（RC）\"></a>非唯一索引查询（RC）</h4><p>如果查询的条件是非唯一索引，那么 SQL 需要在满足条件的非唯一索引上都加上锁，并且会在它们对应的聚簇索引上加锁。</p>\n<h4 id=\"非索引字段查询（RR）\"><a href=\"#非索引字段查询（RR）\" class=\"headerlink\" title=\"非索引字段查询（RR）\"></a>非索引字段查询（RR）</h4><p>RR 隔离级别下，非索引字段做条件的当前读不但会把每条记录都加上 X 锁，还会把每个 GAP 加上GAP 锁。（条件字段加索引的重要性！）</p>\n<h4 id=\"唯一索引查询（RR）\"><a href=\"#唯一索引查询（RR）\" class=\"headerlink\" title=\"唯一索引查询（RR）\"></a>唯一索引查询（RR）</h4><p>如果能确保索引字段唯一，那其实一个等值查询，最多就返回一条记录，而且相同索引记录的值，一定不会再新增，因此不会出现 GAP 锁。</p>\n<p>以唯一索引为条件的当前读，不会有 GAP 锁。</p>\n<h4 id=\"非唯一索引查询-RR\"><a href=\"#非唯一索引查询-RR\" class=\"headerlink\" title=\"非唯一索引查询(RR)\"></a>非唯一索引查询(RR)</h4><p>新增GAP锁+对应数据的X锁</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p>\n<p><strong>解决方法</strong></p>\n<ol>\n<li>检测到死锁的循环依赖，立即返回一个错误，将参数 innodb_deadlock_detect设置为 on 表示开启这个逻辑；</li>\n<li>等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是50 秒。</li>\n</ol>\n<p>方案1有额外的CPU检测开销，确保无死锁时建议关闭检测。</p>\n<p><strong>降低死锁概率</strong></p>\n<ol>\n<li>更新 SQL 的 where 条件尽量用索引；</li>\n<li>基于 primary 或 unique key 更新数据；</li>\n<li>减少范围更新，尤其非主键、非唯一索引上的范围更新；</li>\n<li>加锁顺序一致，尽可能一次性锁定所有需要行；</li>\n<li>将 RR 隔离级别调整为 RC 隔离级别。</li>\n</ol>\n<p><strong>分析死锁</strong></p>\n<pre class=\"line-numbers language-mysql\"><code class=\"language-mysql\">show engine innodb status\\G; //查看最后一次死锁信息<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>另外设置 innodb_print_all_deadlocks = on 可以在 err log 中记录全部死锁信息。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"博客园","url":"https://www.cnblogs.com/hainingwyx/","title":"访问主页","introduction":"hainingwyx博客园主页","avatar":"https://www.cnblogs.com/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM"}]}},"excerpt":"","more":"<p>锁就是协调多个用户或者客户端并发访问某一资源的机制，保证数据并发访问时的一致性和有效性。</p>\n<h2 id=\"全局锁\"><a href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"></a>全局锁</h2><p>MySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。</p>\n<pre><code class=\"mysql\">FLUSH TABLES WITH READ LOCK;\nUNLOCK TABLES;</code></pre>\n<p>当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。</p>\n<p>场景</p>\n<p>一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。</p>\n<p>mysqldump 包含一个参数 –single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以建议使用InnoDB 存储引擎。</p>\n<h2 id=\"表级锁\"><a href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"></a>表级锁</h2><p>表级锁有两种：表锁和元数据锁。</p>\n<h3 id=\"表锁\"><a href=\"#表锁\" class=\"headerlink\" title=\"表锁\"></a>表锁</h3><p>场景</p>\n<ol>\n<li>事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；</li>\n<li>事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。</li>\n</ol>\n<pre><code class=\"mysql\">lock tables t14 read;\nlock tables t14 write;</code></pre>\n<p>表读锁本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</p>\n<h3 id=\"元数据锁\"><a href=\"#元数据锁\" class=\"headerlink\" title=\"元数据锁\"></a>元数据锁</h3><p>MDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。</p>\n<p>对开发而言尽量避免慢查询，事务要及时提交，避免大事务</p>\n<p>对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。</p>\n<h2 id=\"行锁\"><a href=\"#行锁\" class=\"headerlink\" title=\"行锁\"></a>行锁</h2><p>InnoDB后来居上：</p>\n<ul>\n<li>InnoDB 支持事务：适合在并发条件下要求数据一致的场景。</li>\n<li>InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。</li>\n</ul>\n<h3 id=\"两阶段锁\"><a href=\"#两阶段锁\" class=\"headerlink\" title=\"两阶段锁\"></a>两阶段锁</h3><p>锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p>\n<h3 id=\"行锁-1\"><a href=\"#行锁-1\" class=\"headerlink\" title=\"行锁\"></a>行锁</h3><p>两种类型的行锁：</p>\n<ul>\n<li>共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；</li>\n<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。</li>\n</ul>\n<p>共享锁（S）：select <em> from table_name where … lock in share mode;<br>排他锁（X）：select </em> from table_name where … for update(当前读)。</p>\n<h3 id=\"行锁算法\"><a href=\"#行锁算法\" class=\"headerlink\" title=\"行锁算法\"></a>行锁算法</h3><p>Record Lock：单个记录上的索引加锁。<br>Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。<br>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。</p>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><p>Read uncommitted（读未提交）: 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现<br>脏读。<br><strong>Read Committed（读已提交，简称： RC）</strong>：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它<br>实例在该实例处理期间可能会有新的 commit，<strong>所以可能出现幻读</strong>。<br><strong>Repeatable Read（可重复读，简称：RR）</strong>：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在<br>并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，<strong>默认也不会出现幻读</strong>。<br><strong>Serializable（串行）</strong>：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</p>\n<p>脏读：读取未提交的事务。<br>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</p>\n<h4 id=\"非索引字段查询（RC）\"><a href=\"#非索引字段查询（RC）\" class=\"headerlink\" title=\"非索引字段查询（RC）\"></a>非索引字段查询（RC）</h4><p>如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 server 层进行过滤。</p>\n<h4 id=\"唯一索引查询（RC）\"><a href=\"#唯一索引查询（RC）\" class=\"headerlink\" title=\"唯一索引查询（RC）\"></a>唯一索引查询（RC）</h4><p>如果查询的条件是唯一索引，那么 SQL 需要在满足条件的唯一索引上加锁，并且会在对应的聚簇索引上加锁。</p>\n<h4 id=\"非唯一索引查询（RC）\"><a href=\"#非唯一索引查询（RC）\" class=\"headerlink\" title=\"非唯一索引查询（RC）\"></a>非唯一索引查询（RC）</h4><p>如果查询的条件是非唯一索引，那么 SQL 需要在满足条件的非唯一索引上都加上锁，并且会在它们对应的聚簇索引上加锁。</p>\n<h4 id=\"非索引字段查询（RR）\"><a href=\"#非索引字段查询（RR）\" class=\"headerlink\" title=\"非索引字段查询（RR）\"></a>非索引字段查询（RR）</h4><p>RR 隔离级别下，非索引字段做条件的当前读不但会把每条记录都加上 X 锁，还会把每个 GAP 加上GAP 锁。（条件字段加索引的重要性！）</p>\n<h4 id=\"唯一索引查询（RR）\"><a href=\"#唯一索引查询（RR）\" class=\"headerlink\" title=\"唯一索引查询（RR）\"></a>唯一索引查询（RR）</h4><p>如果能确保索引字段唯一，那其实一个等值查询，最多就返回一条记录，而且相同索引记录的值，一定不会再新增，因此不会出现 GAP 锁。</p>\n<p>以唯一索引为条件的当前读，不会有 GAP 锁。</p>\n<h4 id=\"非唯一索引查询-RR\"><a href=\"#非唯一索引查询-RR\" class=\"headerlink\" title=\"非唯一索引查询(RR)\"></a>非唯一索引查询(RR)</h4><p>新增GAP锁+对应数据的X锁</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p>\n<p><strong>解决方法</strong></p>\n<ol>\n<li>检测到死锁的循环依赖，立即返回一个错误，将参数 innodb_deadlock_detect设置为 on 表示开启这个逻辑；</li>\n<li>等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是50 秒。</li>\n</ol>\n<p>方案1有额外的CPU检测开销，确保无死锁时建议关闭检测。</p>\n<p><strong>降低死锁概率</strong></p>\n<ol>\n<li>更新 SQL 的 where 条件尽量用索引；</li>\n<li>基于 primary 或 unique key 更新数据；</li>\n<li>减少范围更新，尤其非主键、非唯一索引上的范围更新；</li>\n<li>加锁顺序一致，尽可能一次性锁定所有需要行；</li>\n<li>将 RR 隔离级别调整为 RC 隔离级别。</li>\n</ol>\n<p><strong>分析死锁</strong></p>\n<pre><code class=\"mysql\">show engine innodb status\\G; //查看最后一次死锁信息</code></pre>\n<p>另外设置 innodb_print_all_deadlocks = on 可以在 err log 中记录全部死锁信息。</p>\n"}],"PostAsset":[{"_id":"source/_posts/redis主从同步/duxiefenli.jpg","slug":"duxiefenli.jpg","post":"ckm944w9a0016i4ufulvvykz4","modified":1,"renderable":0},{"_id":"source/_posts/redis6-0/acl_cmd.jpg","slug":"acl_cmd.jpg","post":"ckm944w960012i4uf9tewpxmj","modified":1,"renderable":0},{"_id":"source/_posts/redis思维导图/redis.png","slug":"redis.png","post":"ckm944w9y001wi4uflyc3v3kt","modified":1,"renderable":0},{"_id":"source/_posts/sort-algorithms/1.png","post":"ckm944way002ji4uf2coh7cmd","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/redis缓存/buyizhi.jpg","slug":"buyizhi.jpg","post":"ckm944wac0026i4uf2xszbp4r","modified":1,"renderable":0},{"_id":"source/_posts/redis缓存/buyizhi2.jpg","slug":"buyizhi2.jpg","post":"ckm944wac0026i4uf2xszbp4r","modified":1,"renderable":0},{"_id":"source/_posts/redis主从同步/master_slave_slave.jpg","slug":"master_slave_slave.jpg","post":"ckm944w9a0016i4ufulvvykz4","modified":1,"renderable":0},{"_id":"source/_posts/redis主从同步/zhucongtongbu.jpg","slug":"zhucongtongbu.jpg","post":"ckm944w9a0016i4ufulvvykz4","modified":1,"renderable":0}],"PostCategory":[{"post_id":"ckm944w850009i4ufjhk4291t","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944w8o000ji4ufrubvkic4"},{"post_id":"ckm944w7m0001i4uf9k2m31a1","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944w8s000oi4ufdx4t6666"},{"post_id":"ckm944w7v0003i4ufzgrzlyz6","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944w8v000qi4ufej98hjne"},{"post_id":"ckm944w820007i4ufv40vrvbi","category_id":"ckm944w8p000ki4ufqcgnui3w","_id":"ckm944w91000wi4ufenyw3uwl"},{"post_id":"ckm944w8w000ti4uf0eu92pjg","category_id":"ckm944w8v000ri4ufoxfl1wfi","_id":"ckm944w970013i4ufiuzhtv14"},{"post_id":"ckm944w8a000bi4ufah2ucimq","category_id":"ckm944w8v000ri4ufoxfl1wfi","_id":"ckm944w9c0017i4uf5oievoq2"},{"post_id":"ckm944w8k000gi4uf32zajvym","category_id":"ckm944w8v000ri4ufoxfl1wfi","_id":"ckm944w9f001bi4ufwetb9fvw"},{"post_id":"ckm944w8n000ii4ufcpnm4ehn","category_id":"ckm944w8v000ri4ufoxfl1wfi","_id":"ckm944w9l001hi4uf3zey57rm"},{"post_id":"ckm944w8r000ni4ufpn20k8gg","category_id":"ckm944w8v000ri4ufoxfl1wfi","_id":"ckm944w9s001ni4uft0p5mgdh"},{"post_id":"ckm944w8t000pi4ufh7qat27o","category_id":"ckm944w8v000ri4ufoxfl1wfi","_id":"ckm944w9x001si4ufp8jyv6il"},{"post_id":"ckm944w9t001pi4ufmhei7hw4","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wa4001zi4uf2q0phy0s"},{"post_id":"ckm944w8z000vi4ufqec9qovy","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wa90024i4ufej2af0rk"},{"post_id":"ckm944w9v001ri4ufarnzk2s2","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944waf0027i4ufkmp9uz0g"},{"post_id":"ckm944w9y001wi4uflyc3v3kt","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944waj002ci4uf19vb2agy"},{"post_id":"ckm944w940010i4ufq2x8t0gq","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wat002fi4uf24kakpfq"},{"post_id":"ckm944wa2001yi4uf5ryusvsr","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wb0002ki4ufz3i4igw4"},{"post_id":"ckm944wa70023i4ufy1mpau47","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wb5002ni4ufpmwcr2q1"},{"post_id":"ckm944w960012i4uf9tewpxmj","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wba002si4ufjyim5gen"},{"post_id":"ckm944wac0026i4uf2xszbp4r","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wbd002vi4ufe3gzbn7w"},{"post_id":"ckm944wai002bi4uf8niy5qnk","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wbh0030i4ufkfadsr68"},{"post_id":"ckm944w9a0016i4ufulvvykz4","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wbk0033i4ufakpy9n0m"},{"post_id":"ckm944waq002ei4uf1roy3d8l","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wbp0038i4uftpc8zca2"},{"post_id":"ckm944w9d0019i4ufz2thty9o","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wbu003bi4uf2yiocue0"},{"post_id":"ckm944wb2002mi4ufozagmgiv","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944wby003gi4ufwokss3bw"},{"post_id":"ckm944wb9002ri4ufibnzjd7a","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944wc1003ii4ufoiajbwqm"},{"post_id":"ckm944w9i001fi4uf3t5z0cq8","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wc3003ki4ufsqa7nyck"},{"post_id":"ckm944wbc002ui4ufdunjffwp","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wc4003ni4uflsve7a43"},{"post_id":"ckm944wbf002zi4ufjgoi7d2f","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944wc5003pi4ufxwl96pz3"},{"post_id":"ckm944w9m001ji4uft4z787p7","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wc6003ri4ufbb83144d"},{"post_id":"ckm944wbi0032i4uf1xirrq70","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944wc7003ti4uf03mzjlhh"},{"post_id":"ckm944wbo0037i4uf51wmr15e","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944wc8003vi4ufuqkvggbn"},{"post_id":"ckm944w9q001li4ufqwyl9gxk","category_id":"ckm944w9s001mi4uf3343k8nx","_id":"ckm944wc9003xi4ufjwaobe5b"},{"post_id":"ckm944wbt003ai4ufw6tqvzna","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944wca003zi4ufz8ew0i4j"},{"post_id":"ckm944wbx003fi4uf1tinzaqy","category_id":"ckm944w7z0005i4ufzswoal5c","_id":"ckm944wcb0041i4ufc8d3zgk7"},{"post_id":"ckm944way002ji4uf2coh7cmd","category_id":"ckm944wbw003di4ufjp397irz","_id":"ckm944wcc0043i4uf67lljg9l"}],"PostTag":[{"post_id":"ckm944w850009i4ufjhk4291t","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944w8j000fi4uf7j8lq24r"},{"post_id":"ckm944w7m0001i4uf9k2m31a1","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944w8m000hi4uf84x1cjvl"},{"post_id":"ckm944w7v0003i4ufzgrzlyz6","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944w8q000mi4uf4r31m6m9"},{"post_id":"ckm944w820007i4ufv40vrvbi","tag_id":"ckm944w8p000li4uf0oorp2ep","_id":"ckm944w8y000ui4ufuuhgnftw"},{"post_id":"ckm944w8w000ti4uf0eu92pjg","tag_id":"ckm944w8w000si4uf4hxiq28b","_id":"ckm944w93000zi4ufj5y6k462"},{"post_id":"ckm944w8a000bi4ufah2ucimq","tag_id":"ckm944w8w000si4uf4hxiq28b","_id":"ckm944w960011i4ufd59iij18"},{"post_id":"ckm944w8k000gi4uf32zajvym","tag_id":"ckm944w8w000si4uf4hxiq28b","_id":"ckm944w9c0018i4ufr2f4h5qp"},{"post_id":"ckm944w8n000ii4ufcpnm4ehn","tag_id":"ckm944w8w000si4uf4hxiq28b","_id":"ckm944w9i001ei4ufanu26ub4"},{"post_id":"ckm944w8r000ni4ufpn20k8gg","tag_id":"ckm944w8w000si4uf4hxiq28b","_id":"ckm944w9o001ki4ufm2ybyvw8"},{"post_id":"ckm944w8t000pi4ufh7qat27o","tag_id":"ckm944w8w000si4uf4hxiq28b","_id":"ckm944w9v001qi4ufvnly9oaq"},{"post_id":"ckm944w9t001pi4ufmhei7hw4","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944w9x001ti4uf7u3zq1yn"},{"post_id":"ckm944w8z000vi4ufqec9qovy","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wa2001xi4uf1ahlp8tc"},{"post_id":"ckm944w9v001ri4ufarnzk2s2","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wa50020i4uf0errt5gd"},{"post_id":"ckm944w9y001wi4uflyc3v3kt","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wac0025i4uf6xj2ojd0"},{"post_id":"ckm944w940010i4ufq2x8t0gq","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wag0028i4uf4n18419s"},{"post_id":"ckm944wa2001yi4uf5ryusvsr","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wap002di4ufb0vl4gdi"},{"post_id":"ckm944wa70023i4ufy1mpau47","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wau002gi4ufdoya87od"},{"post_id":"ckm944w960012i4uf9tewpxmj","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wb1002li4ufiky9w27e"},{"post_id":"ckm944wac0026i4uf2xszbp4r","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wb7002oi4ufy0bqpxa8"},{"post_id":"ckm944wai002bi4uf8niy5qnk","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wbc002ti4ufqtz14m0x"},{"post_id":"ckm944w9a0016i4ufulvvykz4","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wbe002wi4ufurmyxrbx"},{"post_id":"ckm944waq002ei4uf1roy3d8l","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wbi0031i4ufz49vfga9"},{"post_id":"ckm944w9d0019i4ufz2thty9o","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wbm0034i4ufsuvb51vz"},{"post_id":"ckm944wb2002mi4ufozagmgiv","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944wbs0039i4ufdcw4c1be"},{"post_id":"ckm944wb9002ri4ufibnzjd7a","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944wbw003ci4uf1ytw7wcs"},{"post_id":"ckm944w9i001fi4uf3t5z0cq8","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wc1003hi4ufcyzz32x6"},{"post_id":"ckm944wbc002ui4ufdunjffwp","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wc2003ji4ufp0ow4e9g"},{"post_id":"ckm944wbf002zi4ufjgoi7d2f","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944wc3003mi4ufetydxkhu"},{"post_id":"ckm944w9m001ji4uft4z787p7","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wc4003oi4ufkr48ohut"},{"post_id":"ckm944wbi0032i4uf1xirrq70","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944wc5003qi4ufyxkxh702"},{"post_id":"ckm944wbo0037i4uf51wmr15e","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944wc7003si4ufluadvr2e"},{"post_id":"ckm944w9q001li4ufqwyl9gxk","tag_id":"ckm944w9t001oi4ufo8qixfaj","_id":"ckm944wc8003ui4ufp8i7wv8l"},{"post_id":"ckm944wbt003ai4ufw6tqvzna","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944wc8003wi4ufwb4f27xi"},{"post_id":"ckm944wbx003fi4uf1tinzaqy","tag_id":"ckm944w810006i4ufgy5ydt1b","_id":"ckm944wca003yi4uf06rc6c4b"},{"post_id":"ckm944way002ji4uf2coh7cmd","tag_id":"ckm944wbw003ei4ufbxguu29z","_id":"ckm944wcb0040i4uftcih1h5h"},{"post_id":"ckm944way002ji4uf2coh7cmd","tag_id":"ckm944wc3003li4uf2u13zgns","_id":"ckm944wcb0042i4uf4gsh4a0u"}],"Tag":[{"name":"mysql","_id":"ckm944w810006i4ufgy5ydt1b"},{"name":"kafka","_id":"ckm944w8p000li4uf0oorp2ep"},{"name":"rabbitmq","_id":"ckm944w8w000si4uf4hxiq28b"},{"name":"redis","_id":"ckm944w9t001oi4ufo8qixfaj"},{"name":"leetcode","_id":"ckm944wbw003ei4ufbxguu29z"},{"name":"算法","_id":"ckm944wc3003li4uf2u13zgns"}]}}